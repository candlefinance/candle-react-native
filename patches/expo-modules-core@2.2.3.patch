diff --git a/Users/gary/Documents/gary-new/candle-react-native/node_modules/expo-modules-core/.bun-tag-1484b535352943b0 b/.bun-tag-1484b535352943b0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/ios/Api/Builders/ClassComponentBuilder.swift b/ios/Api/Builders/ClassComponentBuilder.swift
index f9fa15a0d85c6c58ad722d5c00a22e95eb301bbe..2507a697c77a71f4f903569aac4a0e4c048cd739 100644
--- a/ios/Api/Builders/ClassComponentBuilder.swift
+++ b/ios/Api/Builders/ClassComponentBuilder.swift
@@ -1,11 +1,11 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- A result builder that captures the ``ClassDefinition`` elements such as functions, constants and properties.
- */
+/// A result builder that captures the ``ClassDefinition`` elements such as functions, constants and properties.
 @resultBuilder
 public struct ClassDefinitionBuilder<OwnerType> {
-  public static func buildBlock(_ elements: AnyClassDefinitionElement...) -> [AnyClassDefinitionElement] {
+  public static func buildBlock(_ elements: AnyClassDefinitionElement...)
+    -> [AnyClassDefinitionElement]
+  {
     return elements
   }
 
diff --git a/ios/Api/Builders/ObjectDefinitionBuilder.swift b/ios/Api/Builders/ObjectDefinitionBuilder.swift
index 5f80ad21c2ce5788de5f053a3842d468d6d85e08..e9b62803ff202d5607e48ea3983b221856a7c626 100644
--- a/ios/Api/Builders/ObjectDefinitionBuilder.swift
+++ b/ios/Api/Builders/ObjectDefinitionBuilder.swift
@@ -4,14 +4,18 @@ public protocol AnyObjectDefinitionElement: AnyDefinition {}
 
 @resultBuilder
 public struct ObjectDefinitionBuilder {
-  public static func buildBlock(_ elements: AnyObjectDefinitionElement...) -> [AnyObjectDefinitionElement] {
+  public static func buildBlock(_ elements: AnyObjectDefinitionElement...)
+    -> [AnyObjectDefinitionElement]
+  {
     return elements
   }
 
   /**
    Default implementation without any constraints that just returns type-erased element.
    */
-  public static func buildExpression<ElementType: AnyObjectDefinitionElement>(_ element: ElementType) -> AnyObjectDefinitionElement {
+  public static func buildExpression<ElementType: AnyObjectDefinitionElement>(
+    _ element: ElementType
+  ) -> AnyObjectDefinitionElement {
     return element
   }
 }
diff --git a/ios/Api/Builders/ViewDefinitionBuilder.swift b/ios/Api/Builders/ViewDefinitionBuilder.swift
index 7c75942c646767dc09a576f9c3c41a46000b5dc1..6bcbaac5bcd3c03049349a49b47120a32964ec1b 100644
--- a/ios/Api/Builders/ViewDefinitionBuilder.swift
+++ b/ios/Api/Builders/ViewDefinitionBuilder.swift
@@ -1,9 +1,9 @@
-/**
- A result builder for the view elements such as prop setters or view events.
- */
+/// A result builder for the view elements such as prop setters or view events.
 @resultBuilder
 public struct ViewDefinitionBuilder<ViewType: UIView> {
-  public static func buildBlock(_ elements: AnyViewDefinitionElement...) -> [AnyViewDefinitionElement] {
+  public static func buildBlock(_ elements: AnyViewDefinitionElement...)
+    -> [AnyViewDefinitionElement]
+  {
     return elements
   }
 
@@ -17,14 +17,18 @@ public struct ViewDefinitionBuilder<ViewType: UIView> {
   /**
    Accepts `Prop` definition element and lets to skip defining the view type — it's inferred from the `View` definition.
    */
-  public static func buildExpression<PropType: AnyArgument>(_ element: ConcreteViewProp<ViewType, PropType>) -> AnyViewDefinitionElement {
+  public static func buildExpression<PropType: AnyArgument>(
+    _ element: ConcreteViewProp<ViewType, PropType>
+  ) -> AnyViewDefinitionElement {
     return element
   }
 
   /**
    Accepts lifecycle methods (such as `OnViewDidUpdateProps`) as a definition element.
    */
-  public static func buildExpression(_ element: ViewLifecycleMethod<ViewType>) -> AnyViewDefinitionElement {
+  public static func buildExpression(_ element: ViewLifecycleMethod<ViewType>)
+    -> AnyViewDefinitionElement
+  {
     return element
   }
 
diff --git a/ios/Api/Factories/AsyncFunctionFactories.swift b/ios/Api/Factories/AsyncFunctionFactories.swift
index 53eba48804825cbd11494481b6d12cbf6982d2fe..5b2a3398fb302d0a2fd27f5f566cd2b21d4d78f6 100644
--- a/ios/Api/Factories/AsyncFunctionFactories.swift
+++ b/ios/Api/Factories/AsyncFunctionFactories.swift
@@ -1,6 +1,4 @@
-/**
- Asynchronous function without arguments.
- */
+/// Asynchronous function without arguments.
 public func AsyncFunction<R>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping () throws -> R
@@ -13,9 +11,7 @@ public func AsyncFunction<R>(
   )
 }
 
-/**
- Asynchronous function with one argument.
- */
+/// Asynchronous function with one argument.
 public func AsyncFunction<R, A0: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0) throws -> R
@@ -28,9 +24,7 @@ public func AsyncFunction<R, A0: AnyArgument>(
   )
 }
 
-/**
- Asynchronous function with two arguments.
- */
+/// Asynchronous function with two arguments.
 public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1) throws -> R
@@ -43,9 +37,7 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument>(
   )
 }
 
-/**
- Asynchronous function with three arguments.
- */
+/// Asynchronous function with three arguments.
 public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2) throws -> R
@@ -56,15 +48,13 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument>(
     dynamicArgumentTypes: [
       ~A0.self,
       ~A1.self,
-      ~A2.self
+      ~A2.self,
     ],
     closure
   )
 }
 
-/**
- Asynchronous function with four arguments.
- */
+/// Asynchronous function with four arguments.
 public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3) throws -> R
@@ -76,16 +66,16 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument,
       ~A0.self,
       ~A1.self,
       ~A2.self,
-      ~A3.self
+      ~A3.self,
     ],
     closure
   )
 }
 
-/**
- Asynchronous function with five arguments.
- */
-public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument>(
+/// Asynchronous function with five arguments.
+public func AsyncFunction<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument
+>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3, A4) throws -> R
 ) -> AsyncFunctionDefinition<(A0, A1, A2, A3, A4), A0, R> {
@@ -97,16 +87,17 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument,
       ~A1.self,
       ~A2.self,
       ~A3.self,
-      ~A4.self
+      ~A4.self,
     ],
     closure
   )
 }
 
-/**
- Asynchronous function with six arguments.
- */
-public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument, A5: AnyArgument>(
+/// Asynchronous function with six arguments.
+public func AsyncFunction<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument,
+  A5: AnyArgument
+>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3, A4, A5) throws -> R
 ) -> AsyncFunctionDefinition<(A0, A1, A2, A3, A4, A5), A0, R> {
@@ -119,16 +110,17 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument,
       ~A2.self,
       ~A3.self,
       ~A4.self,
-      ~A5.self
+      ~A5.self,
     ],
     closure
   )
 }
 
-/**
- Asynchronous function with seven arguments.
- */
-public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument, A5: AnyArgument, A6: AnyArgument>(
+/// Asynchronous function with seven arguments.
+public func AsyncFunction<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument,
+  A5: AnyArgument, A6: AnyArgument
+>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3, A4, A5, A6) throws -> R
 ) -> AsyncFunctionDefinition<(A0, A1, A2, A3, A4, A5, A6), A0, R> {
@@ -142,16 +134,17 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument,
       ~A3.self,
       ~A4.self,
       ~A5.self,
-      ~A6.self
+      ~A6.self,
     ],
     closure
   )
 }
 
-/**
- Asynchronous function with eight arguments.
- */
-public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument, A5: AnyArgument, A6: AnyArgument, A7: AnyArgument>(
+/// Asynchronous function with eight arguments.
+public func AsyncFunction<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument,
+  A5: AnyArgument, A6: AnyArgument, A7: AnyArgument
+>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3, A4, A5, A6, A7) throws -> R
 ) -> AsyncFunctionDefinition<(A0, A1, A2, A3, A4, A5, A6, A7), A0, R> {
@@ -166,7 +159,7 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument,
       ~A4.self,
       ~A5.self,
       ~A6.self,
-      ~A7.self
+      ~A7.self,
     ],
     closure
   )
diff --git a/ios/Api/Factories/ClassFactories.swift b/ios/Api/Factories/ClassFactories.swift
index 360023ffb2185f54a4b0f3be5d7614656aa5a2ad..43f4d6a616a9510492de9be0fa6e338d6d706d46 100644
--- a/ios/Api/Factories/ClassFactories.swift
+++ b/ios/Api/Factories/ClassFactories.swift
@@ -1,96 +1,86 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- Class constructor without arguments.
- */
+/// Class constructor without arguments.
 public func Constructor<R>(
   @_implicitSelfCapture _ body: @escaping () throws -> R
 ) -> SyncFunctionDefinition<(), Void, R> {
   return Function("constructor", body)
 }
 
-/**
- Class constructor with one argument.
- */
+/// Class constructor with one argument.
 public func Constructor<R, A0: AnyArgument>(
   @_implicitSelfCapture _ body: @escaping (A0) throws -> R
 ) -> SyncFunctionDefinition<(A0), A0, R> {
   return Function("constructor", body)
 }
 
-/**
- Class constructor with two arguments.
- */
+/// Class constructor with two arguments.
 public func Constructor<R, A0: AnyArgument, A1: AnyArgument>(
   @_implicitSelfCapture _ body: @escaping (A0, A1) throws -> R
 ) -> SyncFunctionDefinition<(A0, A1), A0, R> {
   return Function("constructor", body)
 }
 
-/**
- Class constructor with three arguments.
- */
+/// Class constructor with three arguments.
 public func Constructor<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument>(
   @_implicitSelfCapture _ body: @escaping (A0, A1, A2) throws -> R
 ) -> SyncFunctionDefinition<(A0, A1, A2), A0, R> {
   return Function("constructor", body)
 }
 
-/**
- Class constructor with four arguments.
- */
+/// Class constructor with four arguments.
 public func Constructor<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument>(
   @_implicitSelfCapture _ body: @escaping (A0, A1, A2, A3) throws -> R
 ) -> SyncFunctionDefinition<(A0, A1, A2, A3), A0, R> {
   return Function("constructor", body)
 }
 
-/**
- Class constructor with five arguments.
- */
-public func Constructor<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument>(
+/// Class constructor with five arguments.
+public func Constructor<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument
+>(
   @_implicitSelfCapture _ body: @escaping (A0, A1, A2, A3, A4) throws -> R
 ) -> SyncFunctionDefinition<(A0, A1, A2, A3, A4), A0, R> {
   return Function("constructor", body)
 }
 
-/**
- Class constructor with six arguments.
- */
-public func Constructor<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument, A5: AnyArgument>(
+/// Class constructor with six arguments.
+public func Constructor<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument,
+  A5: AnyArgument
+>(
   @_implicitSelfCapture _ body: @escaping (A0, A1, A2, A3, A4, A5) throws -> R
 ) -> SyncFunctionDefinition<(A0, A1, A2, A3, A4, A5), A0, R> {
   return Function("constructor", body)
 }
 
-/**
- Creates the definition describing a JavaScript class.
- */
+/// Creates the definition describing a JavaScript class.
 public func Class(
   _ name: String,
-  @ClassDefinitionBuilder<JavaScriptObject> @_implicitSelfCapture _ elements: () -> [AnyClassDefinitionElement]
+  @ClassDefinitionBuilder<JavaScriptObject> @_implicitSelfCapture _ elements: () ->
+    [AnyClassDefinitionElement]
 ) -> ClassDefinition {
   return ClassDefinition(name: name, associatedType: JavaScriptObject.self, elements: elements())
 }
 
-/**
- Creates the definition describing a JavaScript class with an associated native shared object class.
- */
+/// Creates the definition describing a JavaScript class with an associated native shared object class.
 public func Class<SharedObjectType: SharedObject>(
   _ name: String = String(describing: SharedObjectType.self),
   _ sharedObjectType: SharedObjectType.Type,
-  @ClassDefinitionBuilder<SharedObjectType> @_implicitSelfCapture _ elements: () -> [AnyClassDefinitionElement]
+  @ClassDefinitionBuilder<SharedObjectType> @_implicitSelfCapture _ elements: () ->
+    [AnyClassDefinitionElement]
 ) -> ClassDefinition {
   return ClassDefinition(name: name, associatedType: SharedObjectType.self, elements: elements())
 }
 
-/**
- Creates the definition describing a JavaScript class with an associated native shared object class
- and with the name that is inferred from the shared object type.
- */
+/// Creates the definition describing a JavaScript class with an associated native shared object class
+/// and with the name that is inferred from the shared object type.
 public func Class<SharedObjectType: SharedObject>(
   _ sharedObjectType: SharedObjectType.Type,
-  @ClassDefinitionBuilder<SharedObjectType> @_implicitSelfCapture _ elements: () -> [AnyClassDefinitionElement]
+  @ClassDefinitionBuilder<SharedObjectType> @_implicitSelfCapture _ elements: () ->
+    [AnyClassDefinitionElement]
 ) -> ClassDefinition {
-  return ClassDefinition(name: String(describing: SharedObjectType.self), associatedType: SharedObjectType.self, elements: elements())
+  return ClassDefinition(
+    name: String(describing: SharedObjectType.self), associatedType: SharedObjectType.self,
+    elements: elements())
 }
diff --git a/ios/Api/Factories/ConcurrentFunctionFactories.swift b/ios/Api/Factories/ConcurrentFunctionFactories.swift
index bac9ce876a19c353815f09e092b69d5277b95097..68b2742f3870cbde7e4594292f392599bbe8b278 100644
--- a/ios/Api/Factories/ConcurrentFunctionFactories.swift
+++ b/ios/Api/Factories/ConcurrentFunctionFactories.swift
@@ -1,6 +1,4 @@
-/**
- Concurrently-executing asynchronous function without arguments.
- */
+/// Concurrently-executing asynchronous function without arguments.
 public func AsyncFunction<R>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping () async throws -> R
@@ -13,9 +11,7 @@ public func AsyncFunction<R>(
   )
 }
 
-/**
- Concurrently-executing asynchronous function with one argument.
- */
+/// Concurrently-executing asynchronous function with one argument.
 public func AsyncFunction<R, A0: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0) async throws -> R
@@ -28,9 +24,7 @@ public func AsyncFunction<R, A0: AnyArgument>(
   )
 }
 
-/**
- Concurrently-executing asynchronous function with two arguments.
- */
+/// Concurrently-executing asynchronous function with two arguments.
 public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1) async throws -> R
@@ -43,9 +37,7 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument>(
   )
 }
 
-/**
- Concurrently-executing asynchronous function with three arguments.
- */
+/// Concurrently-executing asynchronous function with three arguments.
 public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2) async throws -> R
@@ -56,15 +48,13 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument>(
     dynamicArgumentTypes: [
       ~A0.self,
       ~A1.self,
-      ~A2.self
+      ~A2.self,
     ],
     closure
   )
 }
 
-/**
- Concurrently-executing asynchronous function with four arguments.
- */
+/// Concurrently-executing asynchronous function with four arguments.
 public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3) async throws -> R
@@ -76,16 +66,16 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument,
       ~A0.self,
       ~A1.self,
       ~A2.self,
-      ~A3.self
+      ~A3.self,
     ],
     closure
   )
 }
 
-/**
- Concurrently-executing asynchronous function with five arguments.
- */
-public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument>(
+/// Concurrently-executing asynchronous function with five arguments.
+public func AsyncFunction<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument
+>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3, A4) async throws -> R
 ) -> ConcurrentFunctionDefinition<(A0, A1, A2, A3, A4), A0, R> {
@@ -97,16 +87,17 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument,
       ~A1.self,
       ~A2.self,
       ~A3.self,
-      ~A4.self
+      ~A4.self,
     ],
     closure
   )
 }
 
-/**
- Concurrently-executing asynchronous function with six arguments.
- */
-public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument, A5: AnyArgument>(
+/// Concurrently-executing asynchronous function with six arguments.
+public func AsyncFunction<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument,
+  A5: AnyArgument
+>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3, A4, A5) async throws -> R
 ) -> ConcurrentFunctionDefinition<(A0, A1, A2, A3, A4, A5), A0, R> {
@@ -119,16 +110,17 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument,
       ~A2.self,
       ~A3.self,
       ~A4.self,
-      ~A5.self
+      ~A5.self,
     ],
     closure
   )
 }
 
-/**
- Concurrently-executing asynchronous function with seven arguments.
- */
-public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument, A5: AnyArgument, A6: AnyArgument>(
+/// Concurrently-executing asynchronous function with seven arguments.
+public func AsyncFunction<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument,
+  A5: AnyArgument, A6: AnyArgument
+>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3, A4, A5, A6) async throws -> R
 ) -> ConcurrentFunctionDefinition<(A0, A1, A2, A3, A4, A5, A6), A0, R> {
@@ -142,15 +134,13 @@ public func AsyncFunction<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument,
       ~A3.self,
       ~A4.self,
       ~A5.self,
-      ~A6.self
+      ~A6.self,
     ],
     closure
   )
 }
 
-/**
- Concurrently-executing asynchronous function with eight arguments.
- */
+/// Concurrently-executing asynchronous function with eight arguments.
 public func AsyncFunction<
   R,
   A0: AnyArgument,
@@ -176,7 +166,7 @@ public func AsyncFunction<
       ~A4.self,
       ~A5.self,
       ~A6.self,
-      ~A7.self
+      ~A7.self,
     ],
     closure
   )
diff --git a/ios/Api/Factories/EventListenersFactories.swift b/ios/Api/Factories/EventListenersFactories.swift
index d05118a83619807e3e6ac2b42ae29b17e13a36b1..9757db5ff98a58857e7935103b5f1e1d03346576 100644
--- a/ios/Api/Factories/EventListenersFactories.swift
+++ b/ios/Api/Factories/EventListenersFactories.swift
@@ -1,41 +1,37 @@
-/**
- Creates module's lifecycle listener that is called right after module initialization.
- */
+/// Creates module's lifecycle listener that is called right after module initialization.
 public func OnCreate(@_implicitSelfCapture _ closure: @escaping () -> Void) -> AnyDefinition {
   return EventListener(.moduleCreate, closure)
 }
 
-/**
- Creates module's lifecycle listener that is called when the module is about to be deallocated.
- */
+/// Creates module's lifecycle listener that is called when the module is about to be deallocated.
 public func OnDestroy(@_implicitSelfCapture _ closure: @escaping () -> Void) -> AnyDefinition {
   return EventListener(.moduleDestroy, closure)
 }
 
-/**
- Creates module's lifecycle listener that is called when the app context owning the module is about to be deallocated.
- */
-public func OnAppContextDestroys(@_implicitSelfCapture _ closure: @escaping () -> Void) -> AnyDefinition {
+/// Creates module's lifecycle listener that is called when the app context owning the module is about to be deallocated.
+public func OnAppContextDestroys(@_implicitSelfCapture _ closure: @escaping () -> Void)
+  -> AnyDefinition
+{
   return EventListener(.appContextDestroys, closure)
 }
 
-/**
- Creates a listener that is called when the app is about to enter the foreground mode.
- */
-public func OnAppEntersForeground(@_implicitSelfCapture _ closure: @escaping () -> Void) -> AnyDefinition {
+/// Creates a listener that is called when the app is about to enter the foreground mode.
+public func OnAppEntersForeground(@_implicitSelfCapture _ closure: @escaping () -> Void)
+  -> AnyDefinition
+{
   return EventListener(.appEntersForeground, closure)
 }
 
-/**
- Creates a listener that is called when the app becomes active again.
- */
-public func OnAppBecomesActive(@_implicitSelfCapture _ closure: @escaping () -> Void) -> AnyDefinition {
+/// Creates a listener that is called when the app becomes active again.
+public func OnAppBecomesActive(@_implicitSelfCapture _ closure: @escaping () -> Void)
+  -> AnyDefinition
+{
   return EventListener(.appBecomesActive, closure)
 }
 
-/**
- Creates a listener that is called when the app enters the background mode.
- */
-public func OnAppEntersBackground(@_implicitSelfCapture _ closure: @escaping () -> Void) -> AnyDefinition {
+/// Creates a listener that is called when the app enters the background mode.
+public func OnAppEntersBackground(@_implicitSelfCapture _ closure: @escaping () -> Void)
+  -> AnyDefinition
+{
   return EventListener(.appEntersBackground, closure)
 }
diff --git a/ios/Api/Factories/ModuleFactories.swift b/ios/Api/Factories/ModuleFactories.swift
index a80c571b6005b9c56e9a1cc551a06e09e0d17dc1..46329fe7bc3905e341a2722efc27c68b6ba45a78 100644
--- a/ios/Api/Factories/ModuleFactories.swift
+++ b/ios/Api/Factories/ModuleFactories.swift
@@ -1,6 +1,4 @@
-/**
- Sets the name of the module that is exported to the JavaScript world.
- */
+/// Sets the name of the module that is exported to the JavaScript world.
 public func Name(_ name: String) -> AnyDefinition {
   return ModuleNameDefinition(name: name)
 }
diff --git a/ios/Api/Factories/ObjectFactories.swift b/ios/Api/Factories/ObjectFactories.swift
index 353e5550a08dba8269adc1b96fae5b59b26bed6d..67d5cbb90644cdc9acb5e788208b46d1130a8cea 100644
--- a/ios/Api/Factories/ObjectFactories.swift
+++ b/ios/Api/Factories/ObjectFactories.swift
@@ -3,52 +3,49 @@
 
 // MARK: - Object
 
-public func Object(@ObjectDefinitionBuilder @_implicitSelfCapture _ body: () -> [AnyDefinition]) -> ObjectDefinition {
+public func Object(@ObjectDefinitionBuilder @_implicitSelfCapture _ body: () -> [AnyDefinition])
+  -> ObjectDefinition
+{
   return ObjectDefinition(definitions: body())
 }
 
 // MARK: - Constants
 
-/**
- Definition function setting the module's constants to export.
- */
-public func Constants(@_implicitSelfCapture _ body: @escaping () -> [String: Any?]) -> AnyDefinition {
+/// Definition function setting the module's constants to export.
+public func Constants(@_implicitSelfCapture _ body: @escaping () -> [String: Any?]) -> AnyDefinition
+{
   return ConstantsDefinition(body: body)
 }
 
-/**
- Definition function setting the module's constants to export.
- */
-public func Constants(@_implicitSelfCapture _ body: @autoclosure @escaping () -> [String: Any?]) -> AnyDefinition {
+/// Definition function setting the module's constants to export.
+public func Constants(@_implicitSelfCapture _ body: @autoclosure @escaping () -> [String: Any?])
+  -> AnyDefinition
+{
   return ConstantsDefinition(body: body)
 }
 
 // MARK: - Events
 
-/**
- Defines event names that the object can send to JavaScript.
- */
+/// Defines event names that the object can send to JavaScript.
 public func Events(_ names: String...) -> EventsDefinition {
   return EventsDefinition(names: names)
 }
 
-/**
- Defines event names that the object can send to JavaScript.
- */
+/// Defines event names that the object can send to JavaScript.
 public func Events(_ names: [String]) -> EventsDefinition {
   return EventsDefinition(names: names)
 }
 
-/**
- Function that is invoked when the first event listener is added.
- */
-public func OnStartObserving(_ event: String? = nil, @_implicitSelfCapture _ closure: @escaping () -> Void) -> EventObservingDefinition {
+/// Function that is invoked when the first event listener is added.
+public func OnStartObserving(
+  _ event: String? = nil, @_implicitSelfCapture _ closure: @escaping () -> Void
+) -> EventObservingDefinition {
   return EventObservingDefinition(type: .startObserving, event: event, closure)
 }
 
-/**
- Function that is invoked when all event listeners are removed.
- */
-public func OnStopObserving(_ event: String? = nil, @_implicitSelfCapture _ closure: @escaping () -> Void) -> EventObservingDefinition {
+/// Function that is invoked when all event listeners are removed.
+public func OnStopObserving(
+  _ event: String? = nil, @_implicitSelfCapture _ closure: @escaping () -> Void
+) -> EventObservingDefinition {
   return EventObservingDefinition(type: .stopObserving, event: event, closure)
 }
diff --git a/ios/Api/Factories/PropertyFactories.swift b/ios/Api/Factories/PropertyFactories.swift
index 421c88ebc91213b5ae7c9eb6b66d500628f30bf9..afe75282c0ab9711c3bd4d30d5363e2cacaf52e6 100644
--- a/ios/Api/Factories/PropertyFactories.swift
+++ b/ios/Api/Factories/PropertyFactories.swift
@@ -1,20 +1,16 @@
-/**
- Creates the property with given name. The definition is basically no-op if you don't call `.get(_:)` or `.set(_:)` on it.
- */
+/// Creates the property with given name. The definition is basically no-op if you don't call `.get(_:)` or `.set(_:)` on it.
 public func Property(_ name: String) -> PropertyDefinition<Void> {
   return PropertyDefinition(name: name)
 }
 
-/**
- Creates the read-only property whose getter doesn't take the owner as an argument.
- */
-public func Property<Value: AnyArgument>(_ name: String, @_implicitSelfCapture get: @escaping () -> Value) -> PropertyDefinition<Void> {
+/// Creates the read-only property whose getter doesn't take the owner as an argument.
+public func Property<Value: AnyArgument>(
+  _ name: String, @_implicitSelfCapture get: @escaping () -> Value
+) -> PropertyDefinition<Void> {
   return PropertyDefinition(name: name, getter: get)
 }
 
-/**
- Creates the read-only property whose getter takes the owner as an argument.
- */
+/// Creates the read-only property whose getter takes the owner as an argument.
 public func Property<Value: AnyArgument, OwnerType>(
   _ name: String,
   @_implicitSelfCapture get: @escaping (_ this: OwnerType) -> Value
@@ -22,9 +18,7 @@ public func Property<Value: AnyArgument, OwnerType>(
   return PropertyDefinition<OwnerType>(name: name, getter: get)
 }
 
-/**
- Creates the property that references to an immutable property of the owner object using the key path.
- */
+/// Creates the property that references to an immutable property of the owner object using the key path.
 public func Property<Value: AnyArgument, OwnerType>(
   _ name: String,
   _ keyPath: KeyPath<OwnerType, Value>
@@ -34,9 +28,7 @@ public func Property<Value: AnyArgument, OwnerType>(
   }
 }
 
-/**
- Creates the property that references to a mutable property of the owner object using the key path.
- */
+/// Creates the property that references to a mutable property of the owner object using the key path.
 public func Property<Value: AnyArgument, OwnerType>(
   _ name: String,
   _ keyPath: ReferenceWritableKeyPath<OwnerType, Value>
diff --git a/ios/Api/Factories/SyncFunctionFactories.swift b/ios/Api/Factories/SyncFunctionFactories.swift
index 3757bfaafc9d2429bae1a85d9d6085adcae1cf1a..b4ccd01865a5415d0c46e43bb817372f08897dd7 100644
--- a/ios/Api/Factories/SyncFunctionFactories.swift
+++ b/ios/Api/Factories/SyncFunctionFactories.swift
@@ -1,6 +1,4 @@
-/**
- Synchronous function without arguments.
- */
+/// Synchronous function without arguments.
 public func Function<R>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping () throws -> R
@@ -14,9 +12,7 @@ public func Function<R>(
   )
 }
 
-/**
- Synchronous function with one argument.
- */
+/// Synchronous function with one argument.
 public func Function<R, A0: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0) throws -> R
@@ -30,9 +26,7 @@ public func Function<R, A0: AnyArgument>(
   )
 }
 
-/**
- Synchronous function with two arguments.
- */
+/// Synchronous function with two arguments.
 public func Function<R, A0: AnyArgument, A1: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1) throws -> R
@@ -46,9 +40,7 @@ public func Function<R, A0: AnyArgument, A1: AnyArgument>(
   )
 }
 
-/**
- Synchronous function with three arguments.
- */
+/// Synchronous function with three arguments.
 public func Function<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2) throws -> R
@@ -59,16 +51,14 @@ public func Function<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument>(
     dynamicArgumentTypes: [
       ~A0.self,
       ~A1.self,
-      ~A2.self
+      ~A2.self,
     ],
     returnType: ~R.self,
     closure
   )
 }
 
-/**
- Synchronous function with four arguments.
- */
+/// Synchronous function with four arguments.
 public func Function<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3) throws -> R
@@ -80,17 +70,17 @@ public func Function<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: A
       ~A0.self,
       ~A1.self,
       ~A2.self,
-      ~A3.self
+      ~A3.self,
     ],
     returnType: ~R.self,
     closure
   )
 }
 
-/**
- Synchronous function with five arguments.
- */
-public func Function<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument>(
+/// Synchronous function with five arguments.
+public func Function<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument
+>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3, A4) throws -> R
 ) -> SyncFunctionDefinition<(A0, A1, A2, A3, A4), A0, R> {
@@ -102,17 +92,18 @@ public func Function<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: A
       ~A1.self,
       ~A2.self,
       ~A3.self,
-      ~A4.self
+      ~A4.self,
     ],
     returnType: ~R.self,
     closure
   )
 }
 
-/**
- Synchronous function with six arguments.
- */
-public func Function<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument, A5: AnyArgument>(
+/// Synchronous function with six arguments.
+public func Function<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument,
+  A5: AnyArgument
+>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3, A4, A5) throws -> R
 ) -> SyncFunctionDefinition<(A0, A1, A2, A3, A4, A5), A0, R> {
@@ -125,17 +116,18 @@ public func Function<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: A
       ~A2.self,
       ~A3.self,
       ~A4.self,
-      ~A5.self
+      ~A5.self,
     ],
     returnType: ~R.self,
     closure
   )
 }
 
-/**
- Synchronous function with seven arguments.
- */
-public func Function<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument, A5: AnyArgument, A6: AnyArgument>(
+/// Synchronous function with seven arguments.
+public func Function<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument,
+  A5: AnyArgument, A6: AnyArgument
+>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3, A4, A5, A6) throws -> R
 ) -> SyncFunctionDefinition<(A0, A1, A2, A3, A4, A5, A6), A0, R> {
@@ -149,17 +141,18 @@ public func Function<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: A
       ~A3.self,
       ~A4.self,
       ~A5.self,
-      ~A6.self
+      ~A6.self,
     ],
     returnType: ~R.self,
     closure
   )
 }
 
-/**
- Synchronous function with eight arguments.
- */
-public func Function<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument, A5: AnyArgument, A6: AnyArgument, A7: AnyArgument>(
+/// Synchronous function with eight arguments.
+public func Function<
+  R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: AnyArgument, A4: AnyArgument,
+  A5: AnyArgument, A6: AnyArgument, A7: AnyArgument
+>(
   _ name: String,
   @_implicitSelfCapture _ closure: @escaping (A0, A1, A2, A3, A4, A5, A6, A7) throws -> R
 ) -> SyncFunctionDefinition<(A0, A1, A2, A3, A4, A5, A6, A7), A0, R> {
@@ -174,7 +167,7 @@ public func Function<R, A0: AnyArgument, A1: AnyArgument, A2: AnyArgument, A3: A
       ~A4.self,
       ~A5.self,
       ~A6.self,
-      ~A7.self
+      ~A7.self,
     ],
     returnType: ~R.self,
     closure
diff --git a/ios/Api/Factories/ViewFactories.swift b/ios/Api/Factories/ViewFactories.swift
index 856687cbe1b427e604a66ef7ea201a21807eb424..15d40a39d8f377fcbcbae26c7244ffb300c1a7f2 100644
--- a/ios/Api/Factories/ViewFactories.swift
+++ b/ios/Api/Factories/ViewFactories.swift
@@ -1,8 +1,6 @@
 /// Here we implement factories for the definitions exclusive for native views.
 
-/**
- Creates a view definition describing the native view exported to React.
- */
+/// Creates a view definition describing the native view exported to React.
 public func View<ViewType: UIView>(
   _ viewType: ViewType.Type,
   @ViewDefinitionBuilder<ViewType> _ elements: @escaping () -> [AnyViewDefinitionElement]
@@ -10,9 +8,7 @@ public func View<ViewType: UIView>(
   return ViewDefinition(viewType, elements: elements())
 }
 
-/**
- Creates a view definition describing the native SwiftUI view exported to React.
- */
+/// Creates a view definition describing the native SwiftUI view exported to React.
 public func View<Props: ExpoSwiftUI.ViewProps, ViewType: ExpoSwiftUI.View<Props>>(
   _ viewType: ViewType.Type
 ) -> ExpoSwiftUI.ViewDefinition<Props, ViewType> {
@@ -21,16 +17,15 @@ public func View<Props: ExpoSwiftUI.ViewProps, ViewType: ExpoSwiftUI.View<Props>
 
 public func View<Props: ExpoSwiftUI.ViewProps, ViewType: ExpoSwiftUI.View<Props>>(
   _ viewType: ViewType.Type,
-  @ExpoSwiftUI.ViewDefinitionBuilder<ViewType> _ elements: @escaping () -> [AnyViewDefinitionElement]
+  @ExpoSwiftUI.ViewDefinitionBuilder<ViewType> _ elements: @escaping () ->
+    [AnyViewDefinitionElement]
 ) -> ExpoSwiftUI.ViewDefinition<Props, ViewType> {
   return ExpoSwiftUI.ViewDefinition(ViewType.self, elements: elements())
 }
 
 // MARK: Props
 
-/**
- Creates a view prop that defines its name and setter.
- */
+/// Creates a view prop that defines its name and setter.
 public func Prop<ViewType: UIView, PropType: AnyArgument>(
   _ name: String,
   @_implicitSelfCapture _ setter: @escaping (ViewType, PropType) -> Void
@@ -44,9 +39,7 @@ public func Prop<ViewType: UIView, PropType: AnyArgument>(
 
 // MARK: - View lifecycle
 
-/**
- Defines the view lifecycle method that is called when the view finished updating all props.
- */
+/// Defines the view lifecycle method that is called when the view finished updating all props.
 public func OnViewDidUpdateProps<ViewType: UIView>(
   @_implicitSelfCapture _ closure: @escaping (_ view: ViewType) -> Void
 ) -> ViewLifecycleMethod<ViewType> {
diff --git a/ios/AppDelegates/ExpoAppDelegate.swift b/ios/AppDelegates/ExpoAppDelegate.swift
index 9bd175667255e8a1456b2e6462d378b4288ae44a..a2766ecb6ce51c952087cdd2efec8101719774d2 100644
--- a/ios/AppDelegates/ExpoAppDelegate.swift
+++ b/ios/AppDelegates/ExpoAppDelegate.swift
@@ -4,17 +4,15 @@ import React_RCTAppDelegate
 
 // TODO(vonovak,20250107) - Remove the if expression when we drop SDK 52 / RN 76 support
 #if canImport(ReactAppDependencyProvider)
-import ReactAppDependencyProvider
+  import ReactAppDependencyProvider
 #endif
 
 var subscribers = [ExpoAppDelegateSubscriberProtocol]()
 
-/**
- Allows classes extending `ExpoAppDelegateSubscriber` to hook into project's app delegate
- by forwarding `UIApplicationDelegate` events to the subscribers.
-
- Keep functions and markers in sync with https://developer.apple.com/documentation/uikit/uiapplicationdelegate
- */
+/// Allows classes extending `ExpoAppDelegateSubscriber` to hook into project's app delegate
+/// by forwarding `UIApplicationDelegate` events to the subscribers.
+///
+/// Keep functions and markers in sync with https://developer.apple.com/documentation/uikit/uiapplicationdelegate
 @objc(EXExpoAppDelegate)
 open class ExpoAppDelegate: ExpoAppInstance {
   /**
@@ -26,332 +24,371 @@ open class ExpoAppDelegate: ExpoAppInstance {
   public var shouldCallReactNativeSetup: Bool = true
 
   #if os(iOS) || os(tvOS)
-  // MARK: - Initializing the App
-
-  open override func application(
-    _ application: UIApplication,
-    willFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
-  ) -> Bool {
-    let parsedSubscribers = subscribers.filter {
-      $0.responds(to: #selector(application(_:willFinishLaunchingWithOptions:)))
-    }
+    // MARK: - Initializing the App
+
+    open override func application(
+      _ application: UIApplication,
+      willFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
+    ) -> Bool {
+      let parsedSubscribers = subscribers.filter {
+        $0.responds(to: #selector(application(_:willFinishLaunchingWithOptions:)))
+      }
 
-    // If we can't find a subscriber that implements `willFinishLaunchingWithOptions`, we will delegate the decision if we can handel the passed URL to
-    // the `didFinishLaunchingWithOptions` method by returning `true` here.
-    //  You can read more about how iOS handles deep links here: https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623112-application#discussion
-    if parsedSubscribers.isEmpty {
-      return true
-    }
+      // If we can't find a subscriber that implements `willFinishLaunchingWithOptions`, we will delegate the decision if we can handel the passed URL to
+      // the `didFinishLaunchingWithOptions` method by returning `true` here.
+      //  You can read more about how iOS handles deep links here: https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623112-application#discussion
+      if parsedSubscribers.isEmpty {
+        return true
+      }
 
-    return parsedSubscribers.reduce(false) { result, subscriber in
-      return subscriber.application?(application, willFinishLaunchingWithOptions: launchOptions) ?? false || result
+      return parsedSubscribers.reduce(false) { result, subscriber in
+        return subscriber.application?(application, willFinishLaunchingWithOptions: launchOptions)
+          ?? false || result
+      }
     }
-  }
 
-  open override func application(
-    _ application: UIApplication,
-    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
-  ) -> Bool {
-#if canImport(ReactAppDependencyProvider)
-    self.dependencyProvider = RCTAppDependencyProvider()
-#endif
-    if shouldCallReactNativeSetup {
-      super.application(application, didFinishLaunchingWithOptions: launchOptions)
-    }
+    open override func application(
+      _ application: UIApplication,
+      didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
+    ) -> Bool {
+      #if canImport(ReactAppDependencyProvider)
+        self.dependencyProvider = RCTAppDependencyProvider()
+      #endif
+      if shouldCallReactNativeSetup {
+        super.application(application, didFinishLaunchingWithOptions: launchOptions)
+      }
 
-    subscribers.forEach { subscriber in
-      // Subscriber result is ignored as it doesn't matter if any subscriber handled the incoming URL – we always return `true` anyway.
-      _ = subscriber.application?(application, didFinishLaunchingWithOptions: launchOptions)
+      subscribers.forEach { subscriber in
+        // Subscriber result is ignored as it doesn't matter if any subscriber handled the incoming URL – we always return `true` anyway.
+        _ = subscriber.application?(application, didFinishLaunchingWithOptions: launchOptions)
+      }
+      return true
     }
-    return true
-  }
 
-  // TODO: - Configuring and Discarding Scenes
+    // TODO: - Configuring and Discarding Scenes
 
-  // MARK: - Responding to App Life-Cycle Events
+    // MARK: - Responding to App Life-Cycle Events
 
-  @objc
-  open override func applicationDidBecomeActive(_ application: UIApplication) {
-    subscribers.forEach { $0.applicationDidBecomeActive?(application) }
-  }
+    @objc
+    open override func applicationDidBecomeActive(_ application: UIApplication) {
+      subscribers.forEach { $0.applicationDidBecomeActive?(application) }
+    }
 
-  @objc
-  open override func applicationWillResignActive(_ application: UIApplication) {
-    subscribers.forEach { $0.applicationWillResignActive?(application) }
-  }
+    @objc
+    open override func applicationWillResignActive(_ application: UIApplication) {
+      subscribers.forEach { $0.applicationWillResignActive?(application) }
+    }
 
-  @objc
-  open override func applicationDidEnterBackground(_ application: UIApplication) {
-    subscribers.forEach { $0.applicationDidEnterBackground?(application) }
-  }
+    @objc
+    open override func applicationDidEnterBackground(_ application: UIApplication) {
+      subscribers.forEach { $0.applicationDidEnterBackground?(application) }
+    }
 
-  open override func applicationWillEnterForeground(_ application: UIApplication) {
-    subscribers.forEach { $0.applicationWillEnterForeground?(application) }
-  }
+    open override func applicationWillEnterForeground(_ application: UIApplication) {
+      subscribers.forEach { $0.applicationWillEnterForeground?(application) }
+    }
 
-  open override func applicationWillTerminate(_ application: UIApplication) {
-    subscribers.forEach { $0.applicationWillTerminate?(application) }
-  }
+    open override func applicationWillTerminate(_ application: UIApplication) {
+      subscribers.forEach { $0.applicationWillTerminate?(application) }
+    }
 
-  // TODO: - Responding to Environment Changes
+    // TODO: - Responding to Environment Changes
 
-  // TODO: - Managing App State Restoration
+    // TODO: - Managing App State Restoration
 
-  // MARK: - Downloading Data in the Background
+    // MARK: - Downloading Data in the Background
 
-  open override func application(
-    _ application: UIApplication,
-    handleEventsForBackgroundURLSession identifier: String,
-    completionHandler: @escaping () -> Void
-  ) {
-    let selector = #selector(application(_:handleEventsForBackgroundURLSession:completionHandler:))
-    let subs = subscribers.filter { $0.responds(to: selector) }
-    var subscribersLeft = subs.count
-    let dispatchQueue = DispatchQueue(label: "expo.application.handleBackgroundEvents")
+    open override func application(
+      _ application: UIApplication,
+      handleEventsForBackgroundURLSession identifier: String,
+      completionHandler: @escaping () -> Void
+    ) {
+      let selector = #selector(
+        application(_:handleEventsForBackgroundURLSession:completionHandler:))
+      let subs = subscribers.filter { $0.responds(to: selector) }
+      var subscribersLeft = subs.count
+      let dispatchQueue = DispatchQueue(label: "expo.application.handleBackgroundEvents")
 
-    let handler = {
-      dispatchQueue.sync {
-        subscribersLeft -= 1
+      let handler = {
+        dispatchQueue.sync {
+          subscribersLeft -= 1
 
-        if subscribersLeft == 0 {
-          completionHandler()
+          if subscribersLeft == 0 {
+            completionHandler()
+          }
         }
       }
-    }
 
-    if subs.isEmpty {
-      completionHandler()
-    } else {
-      subs.forEach {
-        $0.application?(application, handleEventsForBackgroundURLSession: identifier, completionHandler: handler)
+      if subs.isEmpty {
+        completionHandler()
+      } else {
+        subs.forEach {
+          $0.application?(
+            application, handleEventsForBackgroundURLSession: identifier, completionHandler: handler
+          )
+        }
       }
     }
-  }
 
-  // MARK: - Handling Remote Notification Registration
+    // MARK: - Handling Remote Notification Registration
 
-  open override func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
-    subscribers.forEach { $0.application?(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken) }
-  }
+    open override func application(
+      _ application: UIApplication,
+      didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data
+    ) {
+      subscribers.forEach {
+        $0.application?(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken)
+      }
+    }
 
-  open override func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
-    subscribers.forEach { $0.application?(application, didFailToRegisterForRemoteNotificationsWithError: error) }
-  }
+    open override func application(
+      _ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error
+    ) {
+      subscribers.forEach {
+        $0.application?(application, didFailToRegisterForRemoteNotificationsWithError: error)
+      }
+    }
 
-  open override func application(
-    _ application: UIApplication,
-    didReceiveRemoteNotification userInfo: [AnyHashable: Any],
-    fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void
-  ) {
-    let selector = #selector(application(_:didReceiveRemoteNotification:fetchCompletionHandler:))
-    let subs = subscribers.filter { $0.responds(to: selector) }
-    var subscribersLeft = subs.count
-    let dispatchQueue = DispatchQueue(label: "expo.application.remoteNotification", qos: .userInteractive)
-    var failedCount = 0
-    var newDataCount = 0
-
-    let handler = { (result: UIBackgroundFetchResult) in
-      dispatchQueue.sync {
-        if result == .failed {
-          failedCount += 1
-        } else if result == .newData {
-          newDataCount += 1
-        }
+    open override func application(
+      _ application: UIApplication,
+      didReceiveRemoteNotification userInfo: [AnyHashable: Any],
+      fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void
+    ) {
+      let selector = #selector(application(_:didReceiveRemoteNotification:fetchCompletionHandler:))
+      let subs = subscribers.filter { $0.responds(to: selector) }
+      var subscribersLeft = subs.count
+      let dispatchQueue = DispatchQueue(
+        label: "expo.application.remoteNotification", qos: .userInteractive)
+      var failedCount = 0
+      var newDataCount = 0
+
+      let handler = { (result: UIBackgroundFetchResult) in
+        dispatchQueue.sync {
+          if result == .failed {
+            failedCount += 1
+          } else if result == .newData {
+            newDataCount += 1
+          }
 
-        subscribersLeft -= 1
+          subscribersLeft -= 1
 
-        if subscribersLeft == 0 {
-          if newDataCount > 0 {
-            completionHandler(.newData)
-          } else if failedCount > 0 {
-            completionHandler(.failed)
-          } else {
-            completionHandler(.noData)
+          if subscribersLeft == 0 {
+            if newDataCount > 0 {
+              completionHandler(.newData)
+            } else if failedCount > 0 {
+              completionHandler(.failed)
+            } else {
+              completionHandler(.noData)
+            }
           }
         }
       }
-    }
 
-    if subs.isEmpty {
-      completionHandler(.noData)
-    } else {
-      subs.forEach { subscriber in
-        subscriber.application?(application, didReceiveRemoteNotification: userInfo, fetchCompletionHandler: handler)
+      if subs.isEmpty {
+        completionHandler(.noData)
+      } else {
+        subs.forEach { subscriber in
+          subscriber.application?(
+            application, didReceiveRemoteNotification: userInfo, fetchCompletionHandler: handler)
+        }
       }
     }
-  }
 
-  // MARK: - Continuing User Activity and Handling Quick Actions
+    // MARK: - Continuing User Activity and Handling Quick Actions
 
-  open override func application(_ application: UIApplication, willContinueUserActivityWithType userActivityType: String) -> Bool {
-    return subscribers.reduce(false) { result, subscriber in
-      return subscriber.application?(application, willContinueUserActivityWithType: userActivityType) ?? false || result
+    open override func application(
+      _ application: UIApplication, willContinueUserActivityWithType userActivityType: String
+    ) -> Bool {
+      return subscribers.reduce(false) { result, subscriber in
+        return subscriber.application?(
+          application, willContinueUserActivityWithType: userActivityType) ?? false || result
+      }
     }
-  }
 
-  open override func application(
-    _ application: UIApplication,
-    continue userActivity: NSUserActivity,
-    restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void
-  ) -> Bool {
-    let selector = #selector(application(_:continue:restorationHandler:))
-    let subs = subscribers.filter { $0.responds(to: selector) }
-    var subscribersLeft = subs.count
-    let dispatchQueue = DispatchQueue(label: "expo.application.continueUserActivity", qos: .userInteractive)
-    var allRestorableObjects = [UIUserActivityRestoring]()
-
-    let handler = { (restorableObjects: [UIUserActivityRestoring]?) in
-      dispatchQueue.sync {
-        if let restorableObjects = restorableObjects {
-          allRestorableObjects.append(contentsOf: restorableObjects)
-        }
+    open override func application(
+      _ application: UIApplication,
+      continue userActivity: NSUserActivity,
+      restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void
+    ) -> Bool {
+      let selector = #selector(application(_:continue:restorationHandler:))
+      let subs = subscribers.filter { $0.responds(to: selector) }
+      var subscribersLeft = subs.count
+      let dispatchQueue = DispatchQueue(
+        label: "expo.application.continueUserActivity", qos: .userInteractive)
+      var allRestorableObjects = [UIUserActivityRestoring]()
+
+      let handler = { (restorableObjects: [UIUserActivityRestoring]?) in
+        dispatchQueue.sync {
+          if let restorableObjects = restorableObjects {
+            allRestorableObjects.append(contentsOf: restorableObjects)
+          }
 
-        subscribersLeft -= 1
+          subscribersLeft -= 1
 
-        if subscribersLeft == 0 {
-          restorationHandler(allRestorableObjects)
+          if subscribersLeft == 0 {
+            restorationHandler(allRestorableObjects)
+          }
         }
       }
-    }
 
-    return subs.reduce(false) { result, subscriber in
-      return subscriber.application?(application, continue: userActivity, restorationHandler: handler) ?? false || result
+      return subs.reduce(false) { result, subscriber in
+        return subscriber.application?(
+          application, continue: userActivity, restorationHandler: handler) ?? false || result
+      }
     }
-  }
-
-  open override func application(_ application: UIApplication, didUpdate userActivity: NSUserActivity) {
-    return subscribers.forEach { $0.application?(application, didUpdate: userActivity) }
-  }
 
-  open override func application(_ application: UIApplication, didFailToContinueUserActivityWithType userActivityType: String, error: Error) {
-    return subscribers.forEach {
-      $0.application?(application, didFailToContinueUserActivityWithType: userActivityType, error: error)
+    open override func application(
+      _ application: UIApplication, didUpdate userActivity: NSUserActivity
+    ) {
+      return subscribers.forEach { $0.application?(application, didUpdate: userActivity) }
     }
-  }
 
-#if !os(tvOS)
-  open override func application(
-    _ application: UIApplication,
-    performActionFor shortcutItem: UIApplicationShortcutItem,
-    completionHandler: @escaping (Bool) -> Void
-  ) {
-    let selector = #selector(application(_:performActionFor:completionHandler:))
-    let subs = subscribers.filter { $0.responds(to: selector) }
-    var subscribersLeft = subs.count
-    var result: Bool = false
-    let dispatchQueue = DispatchQueue(label: "expo.application.performAction", qos: .userInteractive)
-
-    let handler = { (succeeded: Bool) in
-      dispatchQueue.sync {
-        result = result || succeeded
-        subscribersLeft -= 1
-
-        if subscribersLeft == 0 {
-          completionHandler(result)
-        }
+    open override func application(
+      _ application: UIApplication, didFailToContinueUserActivityWithType userActivityType: String,
+      error: Error
+    ) {
+      return subscribers.forEach {
+        $0.application?(
+          application, didFailToContinueUserActivityWithType: userActivityType, error: error)
       }
     }
 
-    if subs.isEmpty {
-      completionHandler(result)
-    } else {
-      subs.forEach { subscriber in
-        subscriber.application?(application, performActionFor: shortcutItem, completionHandler: handler)
-      }
-    }
-  }
-#endif
+    #if !os(tvOS)
+      open override func application(
+        _ application: UIApplication,
+        performActionFor shortcutItem: UIApplicationShortcutItem,
+        completionHandler: @escaping (Bool) -> Void
+      ) {
+        let selector = #selector(application(_:performActionFor:completionHandler:))
+        let subs = subscribers.filter { $0.responds(to: selector) }
+        var subscribersLeft = subs.count
+        var result: Bool = false
+        let dispatchQueue = DispatchQueue(
+          label: "expo.application.performAction", qos: .userInteractive)
+
+        let handler = { (succeeded: Bool) in
+          dispatchQueue.sync {
+            result = result || succeeded
+            subscribersLeft -= 1
+
+            if subscribersLeft == 0 {
+              completionHandler(result)
+            }
+          }
+        }
 
-  // MARK: - Background Fetch
-
-  open override func application(
-    _ application: UIApplication,
-    performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void
-  ) {
-    let selector = #selector(application(_:performFetchWithCompletionHandler:))
-    let subs = subscribers.filter { $0.responds(to: selector) }
-    var subscribersLeft = subs.count
-    let dispatchQueue = DispatchQueue(label: "expo.application.performFetch", qos: .userInteractive)
-    var failedCount = 0
-    var newDataCount = 0
-
-    let handler = { (result: UIBackgroundFetchResult) in
-      dispatchQueue.sync {
-        if result == .failed {
-          failedCount += 1
-        } else if result == .newData {
-          newDataCount += 1
+        if subs.isEmpty {
+          completionHandler(result)
+        } else {
+          subs.forEach { subscriber in
+            subscriber.application?(
+              application, performActionFor: shortcutItem, completionHandler: handler)
+          }
         }
+      }
+    #endif
+
+    // MARK: - Background Fetch
+
+    open override func application(
+      _ application: UIApplication,
+      performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) ->
+        Void
+    ) {
+      let selector = #selector(application(_:performFetchWithCompletionHandler:))
+      let subs = subscribers.filter { $0.responds(to: selector) }
+      var subscribersLeft = subs.count
+      let dispatchQueue = DispatchQueue(
+        label: "expo.application.performFetch", qos: .userInteractive)
+      var failedCount = 0
+      var newDataCount = 0
+
+      let handler = { (result: UIBackgroundFetchResult) in
+        dispatchQueue.sync {
+          if result == .failed {
+            failedCount += 1
+          } else if result == .newData {
+            newDataCount += 1
+          }
 
-        subscribersLeft -= 1
+          subscribersLeft -= 1
 
-        if subscribersLeft == 0 {
-          if newDataCount > 0 {
-            completionHandler(.newData)
-          } else if failedCount > 0 {
-            completionHandler(.failed)
-          } else {
-            completionHandler(.noData)
+          if subscribersLeft == 0 {
+            if newDataCount > 0 {
+              completionHandler(.newData)
+            } else if failedCount > 0 {
+              completionHandler(.failed)
+            } else {
+              completionHandler(.noData)
+            }
           }
         }
       }
-    }
 
-    if subs.isEmpty {
-      completionHandler(.noData)
-    } else {
-      subs.forEach { subscriber in
-        subscriber.application?(application, performFetchWithCompletionHandler: handler)
+      if subs.isEmpty {
+        completionHandler(.noData)
+      } else {
+        subs.forEach { subscriber in
+          subscriber.application?(application, performFetchWithCompletionHandler: handler)
+        }
       }
     }
-  }
 
-  // TODO: - Interacting With WatchKit
+    // TODO: - Interacting With WatchKit
 
-  // TODO: - Interacting With HealthKit
+    // TODO: - Interacting With HealthKit
 
-  // MARK: - Opening a URL-Specified Resource
+    // MARK: - Opening a URL-Specified Resource
 
-  open override func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
-    return subscribers.reduce(false) { result, subscriber in
-      return subscriber.application?(app, open: url, options: options) ?? false || result
+    open override func application(
+      _ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]
+    ) -> Bool {
+      return subscribers.reduce(false) { result, subscriber in
+        return subscriber.application?(app, open: url, options: options) ?? false || result
+      }
     }
-  }
 
-  // TODO: - Disallowing Specified App Extension Types
+    // TODO: - Disallowing Specified App Extension Types
 
-  // TODO: - Handling SiriKit Intents
+    // TODO: - Handling SiriKit Intents
 
-  // TODO: - Handling CloudKit Invitations
+    // TODO: - Handling CloudKit Invitations
 
-  // MARK: - Managing Interface Geometry
+    // MARK: - Managing Interface Geometry
 
-  /**
-   * Sets allowed orientations for the application. It will use the values from `Info.plist`as the orientation mask unless a subscriber requested
-   * a different orientation.
-   */
-#if !os(tvOS)
-  open override func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -> UIInterfaceOrientationMask {
-    let deviceOrientationMask = allowedOrientations(for: UIDevice.current.userInterfaceIdiom)
-    let universalOrientationMask = allowedOrientations(for: .unspecified)
-    let infoPlistOrientations = deviceOrientationMask.isEmpty ? universalOrientationMask : deviceOrientationMask
-
-    let parsedSubscribers = subscribers.filter {
-      $0.responds(to: #selector(application(_:supportedInterfaceOrientationsFor:)))
-    }
+    /**
+     * Sets allowed orientations for the application. It will use the values from `Info.plist`as the orientation mask unless a subscriber requested
+     * a different orientation.
+     */
+    #if !os(tvOS)
+      open override func application(
+        _ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?
+      ) -> UIInterfaceOrientationMask {
+        let deviceOrientationMask = allowedOrientations(for: UIDevice.current.userInterfaceIdiom)
+        let universalOrientationMask = allowedOrientations(for: .unspecified)
+        let infoPlistOrientations =
+          deviceOrientationMask.isEmpty ? universalOrientationMask : deviceOrientationMask
 
-    // We want to create an intersection of all orientations set by subscribers.
-    let subscribersMask: UIInterfaceOrientationMask = parsedSubscribers.reduce(.all) { result, subscriber in
-      guard let requestedOrientation = subscriber.application?(application, supportedInterfaceOrientationsFor: window) else {
-        return result
+        let parsedSubscribers = subscribers.filter {
+          $0.responds(to: #selector(application(_:supportedInterfaceOrientationsFor:)))
+        }
+
+        // We want to create an intersection of all orientations set by subscribers.
+        let subscribersMask: UIInterfaceOrientationMask = parsedSubscribers.reduce(.all) {
+          result, subscriber in
+          guard
+            let requestedOrientation = subscriber.application?(
+              application, supportedInterfaceOrientationsFor: window)
+          else {
+            return result
+          }
+          return requestedOrientation.intersection(result)
+        }
+        return parsedSubscribers.isEmpty ? infoPlistOrientations : subscribersMask
       }
-      return requestedOrientation.intersection(result)
-    }
-    return parsedSubscribers.isEmpty ? infoPlistOrientations : subscribersMask
-  }
-#endif
+    #endif
 
-  #endif // os(iOS)
+  #endif  // os(iOS)
 
   // MARK: - ExpoAppDelegateSubscriberProtocol
 
@@ -372,7 +409,8 @@ open class ExpoAppDelegate: ExpoAppInstance {
   @objc
   public static func registerSubscriber(_ subscriber: ExpoAppDelegateSubscriberProtocol) {
     if subscribers.contains(where: { $0 === subscriber }) {
-      fatalError("Given app delegate subscriber `\(String(describing: subscriber))` is already registered.")
+      fatalError(
+        "Given app delegate subscriber `\(String(describing: subscriber))` is already registered.")
     }
     subscribers.append(subscriber)
   }
@@ -388,28 +426,33 @@ open class ExpoAppDelegate: ExpoAppInstance {
 }
 
 #if os(iOS)
-private func allowedOrientations(for userInterfaceIdiom: UIUserInterfaceIdiom) -> UIInterfaceOrientationMask {
-  // For now only iPad-specific orientations are supported
-  let deviceString = userInterfaceIdiom == .pad ? "~pad" : ""
-  var mask: UIInterfaceOrientationMask = []
-  guard let orientations = Bundle.main.infoDictionary?["UISupportedInterfaceOrientations\(deviceString)"] as? [String] else {
-    return mask
-  }
+  private func allowedOrientations(for userInterfaceIdiom: UIUserInterfaceIdiom)
+    -> UIInterfaceOrientationMask
+  {
+    // For now only iPad-specific orientations are supported
+    let deviceString = userInterfaceIdiom == .pad ? "~pad" : ""
+    var mask: UIInterfaceOrientationMask = []
+    guard
+      let orientations = Bundle.main.infoDictionary?[
+        "UISupportedInterfaceOrientations\(deviceString)"] as? [String]
+    else {
+      return mask
+    }
 
-  for orientation in orientations {
-    switch orientation {
-    case "UIInterfaceOrientationPortrait":
-      mask.insert(.portrait)
-    case "UIInterfaceOrientationLandscapeLeft":
-      mask.insert(.landscapeLeft)
-    case "UIInterfaceOrientationLandscapeRight":
-      mask.insert(.landscapeRight)
-    case "UIInterfaceOrientationPortraitUpsideDown":
-      mask.insert(.portraitUpsideDown)
-    default:
-      break
+    for orientation in orientations {
+      switch orientation {
+      case "UIInterfaceOrientationPortrait":
+        mask.insert(.portrait)
+      case "UIInterfaceOrientationLandscapeLeft":
+        mask.insert(.landscapeLeft)
+      case "UIInterfaceOrientationLandscapeRight":
+        mask.insert(.landscapeRight)
+      case "UIInterfaceOrientationPortraitUpsideDown":
+        mask.insert(.portraitUpsideDown)
+      default:
+        break
+      }
     }
+    return mask
   }
-  return mask
-}
-#endif // os(iOS)
+#endif  // os(iOS)
diff --git a/ios/AppDelegates/ExpoAppDelegateSubscriber.swift b/ios/AppDelegates/ExpoAppDelegateSubscriber.swift
index 9fc8da061e8cabbe866957a1e49e6e37375a1ede..b5137d0ef81b81062844213f59705e7334f9c020 100644
--- a/ios/AppDelegates/ExpoAppDelegateSubscriber.swift
+++ b/ios/AppDelegates/ExpoAppDelegateSubscriber.swift
@@ -1,9 +1,7 @@
 // Copyright 2018-present 650 Industries. All rights reserved.
 
-/**
- Base class for app delegate subscribers. Ensures the class
- inherits from `UIResponder` and has `required init()` initializer.
- */
+/// Base class for app delegate subscribers. Ensures the class
+/// inherits from `UIResponder` and has `required init()` initializer.
 @objc(EXBaseAppDelegateSubscriber)
 open class BaseExpoAppDelegateSubscriber: UIResponder {
   public override required init() {
@@ -11,23 +9,20 @@ open class BaseExpoAppDelegateSubscriber: UIResponder {
   }
 
   #if os(macOS)
-  @available(*, unavailable)
-  public required init?(coder: NSCoder) {
-    fatalError("init(coder:) has not been implemented")
-  }
-  #endif // os(macOS)
+    @available(*, unavailable)
+    public required init?(coder: NSCoder) {
+      fatalError("init(coder:) has not been implemented")
+    }
+  #endif  // os(macOS)
 }
 
-/**
- Typealias to `UIApplicationDelegate` protocol.
- Might be useful for compatibility reasons if we decide to add more things here.
- */
+/// Typealias to `UIApplicationDelegate` protocol.
+/// Might be useful for compatibility reasons if we decide to add more things here.
 @objc(EXAppDelegateSubscriberProtocol)
 public protocol ExpoAppDelegateSubscriberProtocol: UIApplicationDelegate {
   @objc optional func customizeRootView(_ rootView: UIView)
 }
 
-/**
- Typealias merging the base class for app delegate subscribers and protocol inheritance to `UIApplicationDelegate`.
- */
-public typealias ExpoAppDelegateSubscriber = BaseExpoAppDelegateSubscriber & ExpoAppDelegateSubscriberProtocol
+/// Typealias merging the base class for app delegate subscribers and protocol inheritance to `UIApplicationDelegate`.
+public typealias ExpoAppDelegateSubscriber = BaseExpoAppDelegateSubscriber
+  & ExpoAppDelegateSubscriberProtocol
diff --git a/ios/AppDelegates/ExpoAppInstance.swift b/ios/AppDelegates/ExpoAppInstance.swift
index 1e6e7ecd77770b1c10c861d1b59f38db5b3fe70a..683b486657848ad521d61212094b092ca8871f79 100644
--- a/ios/AppDelegates/ExpoAppInstance.swift
+++ b/ios/AppDelegates/ExpoAppInstance.swift
@@ -25,11 +25,12 @@ open class ExpoAppInstance: RCTAppDelegate {
   }
 
   open override func bundleURL() -> URL? {
-#if DEBUG
-    return RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: ".expo/.virtual-metro-entry")
-#else
-    return Bundle.main.url(forResource: "main", withExtension: "jsbundle")
-#endif
+    #if DEBUG
+      return RCTBundleURLProvider.sharedSettings().jsBundleURL(
+        forBundleRoot: ".expo/.virtual-metro-entry")
+    #else
+      return Bundle.main.url(forResource: "main", withExtension: "jsbundle")
+    #endif
   }
 
   @objc
diff --git a/ios/Core/AppCodeSignEntitlements.swift b/ios/Core/AppCodeSignEntitlements.swift
index df8161ab0a558d4c85eea496ecb4e1aea486d761..e7fdb4e95a94c89585d575f57db680e97fdd2d00 100644
--- a/ios/Core/AppCodeSignEntitlements.swift
+++ b/ios/Core/AppCodeSignEntitlements.swift
@@ -1,8 +1,6 @@
 // Copyright 2015-present 650 Industries. All rights reserved.
 
-/**
- App code signing entitlements passed from autolinking
- */
+/// App code signing entitlements passed from autolinking
 public struct AppCodeSignEntitlements: Codable {
   /**
    https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_security_application-groups
diff --git a/ios/Core/AppContext.swift b/ios/Core/AppContext.swift
index 035532130ea5585747530e23d2a909b4e7c3f21e..f837f33599ca9c72505dda9ca599fcba165b19ba 100644
--- a/ios/Core/AppContext.swift
+++ b/ios/Core/AppContext.swift
@@ -1,8 +1,6 @@
 import React
 
-/**
- The app context is an interface to a single Expo app.
- */
+/// The app context is an interface to a single Expo app.
 @objc(EXAppContext)
 public final class AppContext: NSObject {
   internal static func create() -> AppContext {
@@ -37,9 +35,12 @@ public final class AppContext: NSObject {
   public weak var legacyModuleRegistry: EXModuleRegistry? {
     didSet {
       if let registry = legacyModuleRegistry,
-        let legacyModule = registry.getModuleImplementingProtocol(EXFileSystemInterface.self) as? EXFileSystemInterface,
-        let fileSystemLegacyModule = legacyModule as? FileSystemLegacyUtilities {
-        fileSystemLegacyModule.maybeInitAppGroupSharedDirectories(self.config.appGroupSharedDirectories)
+        let legacyModule = registry.getModuleImplementingProtocol(EXFileSystemInterface.self)
+          as? EXFileSystemInterface,
+        let fileSystemLegacyModule = legacyModule as? FileSystemLegacyUtilities
+      {
+        fileSystemLegacyModule.maybeInitAppGroupSharedDirectories(
+          self.config.appGroupSharedDirectories)
       }
     }
   }
@@ -93,12 +94,12 @@ public final class AppContext: NSObject {
   @objc
   public var appIdentifier: String? {
     #if RCT_NEW_ARCH_ENABLED
-    guard let moduleRegistry = reactBridge?.moduleRegistry else {
-      return nil
-    }
-    return "\(abs(ObjectIdentifier(moduleRegistry).hashValue))"
+      guard let moduleRegistry = reactBridge?.moduleRegistry else {
+        return nil
+      }
+      return "\(abs(ObjectIdentifier(moduleRegistry).hashValue))"
     #else
-    return nil
+      return nil
     #endif
   }
 
@@ -115,7 +116,8 @@ public final class AppContext: NSObject {
   /**
    The module holder for the core module.
    */
-  internal private(set) lazy var coreModuleHolder = ModuleHolder(appContext: self, module: coreModule)
+  internal private(set) lazy var coreModuleHolder = ModuleHolder(
+    appContext: self, module: coreModule)
 
   internal private(set) lazy var converter = MainValueConverter(appContext: self)
 
@@ -123,13 +125,18 @@ public final class AppContext: NSObject {
    Designated initializer without modules provider.
    */
   public init(config: AppContextConfig? = nil) {
-    self.config = config ?? AppContextConfig(documentDirectory: nil, cacheDirectory: nil, appGroups: appCodeSignEntitlements.appGroups)
+    self.config =
+      config
+      ?? AppContextConfig(
+        documentDirectory: nil, cacheDirectory: nil, appGroups: appCodeSignEntitlements.appGroups)
 
     super.init()
     listenToClientAppNotifications()
   }
 
-  public convenience init(legacyModulesProxy: Any, legacyModuleRegistry: Any, config: AppContextConfig? = nil) {
+  public convenience init(
+    legacyModulesProxy: Any, legacyModuleRegistry: Any, config: AppContextConfig? = nil
+  ) {
     self.init(config: config)
     self.legacyModulesProxy = legacyModulesProxy as? LegacyNativeModulesProxy
     self.legacyModuleRegistry = legacyModuleRegistry as? EXModuleRegistry
@@ -198,7 +205,8 @@ public final class AppContext: NSObject {
   /**
    Returns a legacy module implementing given protocol/interface.
    */
-  public func legacyModule<ModuleProtocol>(implementing moduleProtocol: Protocol) -> ModuleProtocol? {
+  public func legacyModule<ModuleProtocol>(implementing moduleProtocol: Protocol) -> ModuleProtocol?
+  {
     return legacyModuleRegistry?.getModuleImplementingProtocol(moduleProtocol) as? ModuleProtocol
   }
 
@@ -249,21 +257,22 @@ public final class AppContext: NSObject {
    */
   private func listenToClientAppNotifications() {
     #if os(iOS) || os(tvOS)
-    let notifications = [
-      UIApplication.willEnterForegroundNotification,
-      UIApplication.didBecomeActiveNotification,
-      UIApplication.didEnterBackgroundNotification
-    ]
+      let notifications = [
+        UIApplication.willEnterForegroundNotification,
+        UIApplication.didBecomeActiveNotification,
+        UIApplication.didEnterBackgroundNotification,
+      ]
     #elseif os(macOS)
-    let notifications = [
-      NSApplication.willUnhideNotification,
-      NSApplication.didBecomeActiveNotification,
-      NSApplication.didHideNotification
-    ]
+      let notifications = [
+        NSApplication.willUnhideNotification,
+        NSApplication.didBecomeActiveNotification,
+        NSApplication.didHideNotification,
+      ]
     #endif
 
     notifications.forEach { name in
-      NotificationCenter.default.addObserver(self, selector: #selector(handleClientAppNotification(_:)), name: name, object: nil)
+      NotificationCenter.default.addObserver(
+        self, selector: #selector(handleClientAppNotification(_:)), name: name, object: nil)
     }
   }
 
@@ -274,19 +283,19 @@ public final class AppContext: NSObject {
   private func handleClientAppNotification(_ notification: Notification) {
     switch notification.name {
     #if os(iOS) || os(tvOS)
-    case UIApplication.willEnterForegroundNotification:
-      moduleRegistry.post(event: .appEntersForeground)
-    case UIApplication.didBecomeActiveNotification:
-      moduleRegistry.post(event: .appBecomesActive)
-    case UIApplication.didEnterBackgroundNotification:
-      moduleRegistry.post(event: .appEntersBackground)
+      case UIApplication.willEnterForegroundNotification:
+        moduleRegistry.post(event: .appEntersForeground)
+      case UIApplication.didBecomeActiveNotification:
+        moduleRegistry.post(event: .appBecomesActive)
+      case UIApplication.didEnterBackgroundNotification:
+        moduleRegistry.post(event: .appEntersBackground)
     #elseif os(macOS)
-    case NSApplication.willUnhideNotification:
-      moduleRegistry.post(event: .appEntersForeground)
-    case NSApplication.didBecomeActiveNotification:
-      moduleRegistry.post(event: .appBecomesActive)
-    case NSApplication.didHideNotification:
-      moduleRegistry.post(event: .appEntersBackground)
+      case NSApplication.willUnhideNotification:
+        moduleRegistry.post(event: .appEntersForeground)
+      case NSApplication.didBecomeActiveNotification:
+        moduleRegistry.post(event: .appBecomesActive)
+      case NSApplication.didHideNotification:
+        moduleRegistry.post(event: .appEntersBackground)
     #endif
     default:
       return
@@ -379,9 +388,10 @@ public final class AppContext: NSObject {
   }
 
   @objc
-  public final lazy var expoModulesConfig = ModulesProxyConfig(constants: self.exportedModulesConstants(),
-                                                               methodNames: self.exportedFunctionNames(),
-                                                               viewManagers: self.viewManagersMetadata())
+  public final lazy var expoModulesConfig = ModulesProxyConfig(
+    constants: self.exportedModulesConstants(),
+    methodNames: self.exportedFunctionNames(),
+    viewManagers: self.viewManagersMetadata())
 
   private func exportedFunctionNames() -> [String: [[String: Any]]] {
     var constants = [String: [[String: Any]]]()
@@ -391,7 +401,7 @@ public final class AppContext: NSObject {
         return [
           "name": functionName,
           "argumentsCount": function.argumentsCount,
-          "key": functionName
+          "key": functionName,
         ]
       })
     }
@@ -399,7 +409,8 @@ public final class AppContext: NSObject {
   }
 
   private func exportedModulesConstants() -> [String: Any] {
-    return moduleRegistry
+    return
+      moduleRegistry
       // prevent infinite recursion - exclude NativeProxyModule constants
       .filter { $0.name != NativeModulesProxyModule.moduleName }
       .reduce(into: [String: Any]()) { acc, holder in
@@ -434,10 +445,11 @@ public final class AppContext: NSObject {
     EXJavaScriptRuntimeManager.installEventEmitterClass(runtime)
 
     // Install `global.expo.SharedObject`.
-    EXJavaScriptRuntimeManager.installSharedObjectClass(runtime) { [weak sharedObjectRegistry] objectId in
+    EXJavaScriptRuntimeManager.installSharedObjectClass(runtime) {
+      [weak sharedObjectRegistry] objectId in
       sharedObjectRegistry?.delete(objectId)
     }
-    
+
     // Install `global.expo.SharedRef`.
     EXJavaScriptRuntimeManager.installSharedRefClass(runtime)
 
@@ -483,11 +495,15 @@ public final class AppContext: NSObject {
    The provider is usually generated in application's `ExpoModulesProviders` files group.
    */
   @objc
-  public static func modulesProvider(withName providerName: String = "ExpoModulesProvider") -> ModulesProvider {
+  public static func modulesProvider(withName providerName: String = "ExpoModulesProvider")
+    -> ModulesProvider
+  {
     // [0] When ExpoModulesCore is built as separated framework/module,
     // we should explicitly load main bundle's `ExpoModulesProvider` class.
     if let bundleName = Bundle.main.infoDictionary?["CFBundleName"],
-       let providerClass = NSClassFromString("\(bundleName).\(providerName)") as? ModulesProvider.Type {
+      let providerClass = NSClassFromString("\(bundleName).\(providerName)")
+        as? ModulesProvider.Type
+    {
       return providerClass.init()
     }
 
diff --git a/ios/Core/AppContextConfig.swift b/ios/Core/AppContextConfig.swift
index e2e9259a84fd5dae5fce0c8445ad1697d6625d78..bc2eb919f9268c1dda918699238a1f93578fde2a 100644
--- a/ios/Core/AppContextConfig.swift
+++ b/ios/Core/AppContextConfig.swift
@@ -6,12 +6,17 @@ public struct AppContextConfig {
   public let appGroupSharedDirectories: [URL]
 
   public init(documentDirectory: URL?, cacheDirectory: URL?, appGroups: [String]?) {
-    self.documentDirectory = documentDirectory ?? FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first
-    self.cacheDirectory = cacheDirectory ?? FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first
+    self.documentDirectory =
+      documentDirectory
+      ?? FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first
+    self.cacheDirectory =
+      cacheDirectory ?? FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first
 
     var sharedDirectories: [URL] = []
     for appGroup in appGroups ?? [] {
-      if let directory = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: appGroup) {
+      if let directory = FileManager.default.containerURL(
+        forSecurityApplicationGroupIdentifier: appGroup)
+      {
         sharedDirectories.append(directory)
       }
     }
diff --git a/ios/Core/Arguments/AnyArgument.swift b/ios/Core/Arguments/AnyArgument.swift
index 50b8147d8561a1bc18f7e072fd4409a1b7efe290..8270518916895ea65f849fd8ca8f5da2752bc028 100644
--- a/ios/Core/Arguments/AnyArgument.swift
+++ b/ios/Core/Arguments/AnyArgument.swift
@@ -1,8 +1,6 @@
 // Copyright 2021-present 650 Industries. All rights reserved.
 
-/**
- A protocol for classes/structs accepted as an argument of functions.
- */
+/// A protocol for classes/structs accepted as an argument of functions.
 public protocol AnyArgument {
   static func getDynamicType() -> AnyDynamicType
 }
diff --git a/ios/Core/Arguments/Convertible.swift b/ios/Core/Arguments/Convertible.swift
index 83abc0c28b4186b9c907fda1b9e94418cd1504d4..6660584366c0eb88f5e24c0ce6618fd60448a80a 100644
--- a/ios/Core/Arguments/Convertible.swift
+++ b/ios/Core/Arguments/Convertible.swift
@@ -1,11 +1,9 @@
 // Copyright 2018-present 650 Industries. All rights reserved.
 
-/**
- A protocol that allows custom classes or structs to be used as function arguments.
- It requires static `convert(from:appContext:)` function that knows how to convert incoming
- value of `Any` type to the type implemented by this protocol. It should throw an error
- when the value is not recognized, is invalid or doesn't meet type requirements.
- */
+/// A protocol that allows custom classes or structs to be used as function arguments.
+/// It requires static `convert(from:appContext:)` function that knows how to convert incoming
+/// value of `Any` type to the type implemented by this protocol. It should throw an error
+/// when the value is not recognized, is invalid or doesn't meet type requirements.
 public protocol Convertible: AnyArgument {
   /**
    Converts any value to the instance of its class (or struct) in the given app context.
diff --git a/ios/Core/Arguments/Convertibles.swift b/ios/Core/Arguments/Convertibles.swift
index a126e112b37e3641556be5baad81d27521ae2b49..89050cee032febe27db26f04ac6dd96d3b8aa2e2 100644
--- a/ios/Core/Arguments/Convertibles.swift
+++ b/ios/Core/Arguments/Convertibles.swift
@@ -30,7 +30,9 @@ extension URL: Convertible {
     }
 
     // If we get here, the string is not the file url and may require percent-encoding characters that are not URL-safe according to RFC 3986.
-    if let encodedValue = percentEncodeUrlString(value), let url = convertToUrl(string: encodedValue) {
+    if let encodedValue = percentEncodeUrlString(value),
+      let url = convertToUrl(string: encodedValue)
+    {
       return url
     }
 
@@ -41,7 +43,8 @@ extension URL: Convertible {
 
 internal class UrlContainsInvalidCharactersException: Exception {
   override var reason: String {
-    return "Unable to create a URL object from the given string, make sure to percent-encode these characters: \(urlAllowedCharacters)"
+    return
+      "Unable to create a URL object from the given string, make sure to percent-encode these characters: \(urlAllowedCharacters)"
   }
 }
 
@@ -66,7 +69,8 @@ extension CGSize: Convertible {
       return CGSize(width: value[0], height: value[1])
     }
     if let value = value as? [String: Any] {
-      let args = try Conversions.pickValues(from: value, byKeys: ["width", "height"], as: Double.self)
+      let args = try Conversions.pickValues(
+        from: value, byKeys: ["width", "height"], as: Double.self)
       return CGSize(width: args[0], height: args[1])
     }
     if let size = value as? CGSize {
@@ -98,7 +102,8 @@ extension CGRect: Convertible {
       return CGRect(x: value[0], y: value[1], width: value[2], height: value[3])
     }
     if let value = value as? [String: Any] {
-      let args = try Conversions.pickValues(from: value, byKeys: ["x", "y", "width", "height"], as: Double.self)
+      let args = try Conversions.pickValues(
+        from: value, byKeys: ["x", "y", "width", "height"], as: Double.self)
       return CGRect(x: args[0], y: args[1], width: args[2], height: args[3])
     }
     if let rect = value as? CGRect {
diff --git a/ios/Core/Arguments/Either.swift b/ios/Core/Arguments/Either.swift
index cd94b2188e329c8b822eff5c325f36faeecc705a..668ba27050e479cc9c4c3348e793c7553aaa72f2 100644
--- a/ios/Core/Arguments/Either.swift
+++ b/ios/Core/Arguments/Either.swift
@@ -102,9 +102,13 @@ open class EitherOfThree<FirstType, SecondType, ThirdType>: Either<FirstType, Se
 /*
  A convertible type wrapper for a value that should be either of four generic types.
  */
-open class EitherOfFour<FirstType, SecondType, ThirdType, FourthType>: EitherOfThree<FirstType, SecondType, ThirdType> {
+open class EitherOfFour<FirstType, SecondType, ThirdType, FourthType>: EitherOfThree<
+  FirstType, SecondType, ThirdType
+>
+{
   override public class func getDynamicType() -> any AnyDynamicType {
-    return DynamicEitherType(eitherType: EitherOfFour<FirstType, SecondType, ThirdType, FourthType>.self)
+    return DynamicEitherType(
+      eitherType: EitherOfFour<FirstType, SecondType, ThirdType, FourthType>.self)
   }
 
   override class func dynamicTypes() -> [AnyDynamicType] {
@@ -128,14 +132,13 @@ open class EitherOfFour<FirstType, SecondType, ThirdType, FourthType>: EitherOfT
 
 // MARK: - Exceptions
 
-/**
- An exception thrown when the value is of neither type.
- */
+/// An exception thrown when the value is of neither type.
 internal class NeitherTypeException: GenericException<[AnyDynamicType]> {
   override var reason: String {
     var typeDescriptions = param.map({ $0.description })
     let lastTypeDescription = typeDescriptions.removeLast()
 
-    return "Type must be either: \(typeDescriptions.joined(separator: ", ")) or \(lastTypeDescription)"
+    return
+      "Type must be either: \(typeDescriptions.joined(separator: ", ")) or \(lastTypeDescription)"
   }
 }
diff --git a/ios/Core/Arguments/Enumerable.swift b/ios/Core/Arguments/Enumerable.swift
index 65621d52b3c1f0cbd02a1d21b11e8ce93c9a66a9..878eae04ed5820486e0a373cfbfaa46663975ad3 100644
--- a/ios/Core/Arguments/Enumerable.swift
+++ b/ios/Core/Arguments/Enumerable.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- A protocol that allows converting raw values to enum cases.
- */
+/// A protocol that allows converting raw values to enum cases.
 public protocol Enumerable: AnyArgument, CaseIterable {
   /**
    Tries to create an enum case using given raw value.
@@ -30,12 +28,10 @@ extension Enumerable {
   }
 }
 
-/**
- Extension for `Enumerable` that also conforms to `RawRepresentable`.
- This constraint allows us to reference the associated `RawValue` type.
- */
-public extension Enumerable where Self: RawRepresentable, Self: Hashable {
-  static func create<ArgType>(fromRawValue rawValue: ArgType) throws -> Self {
+/// Extension for `Enumerable` that also conforms to `RawRepresentable`.
+/// This constraint allows us to reference the associated `RawValue` type.
+extension Enumerable where Self: RawRepresentable, Self: Hashable {
+  public static func create<ArgType>(fromRawValue rawValue: ArgType) throws -> Self {
     guard let rawValue = rawValue as? RawValue else {
       throw EnumCastingException((type: RawValue.self, value: rawValue))
     }
@@ -45,27 +41,23 @@ public extension Enumerable where Self: RawRepresentable, Self: Hashable {
     return enumCase
   }
 
-  var anyRawValue: Any {
+  public var anyRawValue: Any {
     rawValue
   }
 
-  static var allRawValues: [Any] {
+  public static var allRawValues: [Any] {
     return allCases.map { $0.rawValue }
   }
 }
 
-/**
- An error that is thrown when the value cannot be cast to associated `RawValue`.
- */
+/// An error that is thrown when the value cannot be cast to associated `RawValue`.
 internal class EnumCastingException: GenericException<(type: Any.Type, value: Any)> {
   override var reason: String {
     "Unable to cast '\(param.value)' to expected type \(param.type)"
   }
 }
 
-/**
- An error that is thrown when the value doesn't match any available case.
- */
+/// An error that is thrown when the value doesn't match any available case.
 internal class EnumNoSuchValueException: GenericException<(type: Enumerable.Type, value: Any)> {
   var allRawValuesFormatted: String {
     return param.type.allRawValues
diff --git a/ios/Core/Classes/AnyClassDefinitionElement.swift b/ios/Core/Classes/AnyClassDefinitionElement.swift
index 1df01c32c77ea7bac8e9bb3b88419cf1914a1582..96bf7dffc7897c26ab998e712932c558b854394a 100644
--- a/ios/Core/Classes/AnyClassDefinitionElement.swift
+++ b/ios/Core/Classes/AnyClassDefinitionElement.swift
@@ -1,14 +1,10 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- A type-erased protocol that must be implemented by the definitions passed as ``ClassDefinition`` elements.
- */
+/// A type-erased protocol that must be implemented by the definitions passed as ``ClassDefinition`` elements.
 public protocol AnyClassDefinitionElement: AnyDefinition {}
 
-/**
- Class definition element with an associated owner type. The `OwnerType` should refer to
- the type that the parent `Class` definition is associated with (e.g. the shared object type).
- */
+/// Class definition element with an associated owner type. The `OwnerType` should refer to
+/// the type that the parent `Class` definition is associated with (e.g. the shared object type).
 public protocol ClassDefinitionElement: AnyClassDefinitionElement {
   associatedtype OwnerType
 }
diff --git a/ios/Core/Classes/ClassDefinition.swift b/ios/Core/Classes/ClassDefinition.swift
index 14bd7351e298c404f79033f00ffbd22811cc46b3..7782e918be459fc968f0c53a022ea74cda174f57 100644
--- a/ios/Core/Classes/ClassDefinition.swift
+++ b/ios/Core/Classes/ClassDefinition.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- Represents a JavaScript class.
- */
+/// Represents a JavaScript class.
 public final class ClassDefinition: ObjectDefinition {
   /**
    Name of the class.
@@ -51,7 +49,8 @@ public final class ClassDefinition: ObjectDefinition {
       }
 
       // Call the native constructor when defined.
-      let result = try? self.constructor?.call(by: this, withArguments: arguments, appContext: appContext)
+      let result = try? self.constructor?.call(
+        by: this, withArguments: arguments, appContext: appContext)
 
       // Register the shared object if returned by the constructor.
       if let result = result as? SharedObject {
@@ -65,7 +64,8 @@ public final class ClassDefinition: ObjectDefinition {
 
     // Register the JS class and its associated native type.
     if let sharedObjectType = associatedType as? DynamicSharedObjectType {
-      appContext.classRegistry.register(nativeClassId: sharedObjectType.typeIdentifier, javaScriptClass: klass)
+      appContext.classRegistry.register(
+        nativeClassId: sharedObjectType.typeIdentifier, javaScriptClass: klass)
     }
 
     return klass
@@ -81,21 +81,21 @@ public final class ClassDefinition: ObjectDefinition {
     try decorateWithClasses(object: prototype, appContext: appContext)
     try decorateWithProperties(object: prototype, appContext: appContext)
   }
-  
-  private func createClass(appContext: AppContext, name: String, consturctor: @escaping ClassConstructorBlock) throws -> JavaScriptObject {
+
+  private func createClass(
+    appContext: AppContext, name: String, consturctor: @escaping ClassConstructorBlock
+  ) throws -> JavaScriptObject {
     if isSharedRef {
       return try appContext.runtime.createSharedRefClass(name, constructor: consturctor)
     }
-    
+
     return try appContext.runtime.createSharedObjectClass(name, constructor: consturctor)
   }
 }
 
 // MARK: - ClassAssociatedObject
 
-/**
- A protocol for types that can be used an associated type of the ``ClassDefinition``.
- */
+/// A protocol for types that can be used an associated type of the ``ClassDefinition``.
 internal protocol ClassAssociatedObject {}
 
 // Basically we only need these two
@@ -111,14 +111,12 @@ extension SharedObject: ClassAssociatedObject {}
 
 // MARK: - Privates
 
-/**
- Checks whether the definition item is a constructor — a synchronous function whose name is "constructor".
-
- We do it that way for the following two reasons:
- - It's easier to reuse existing `SyncFunctionDefinition`.
- - Redefining prototype's `constructor` is a bad idea so a function with this name
-   needs to be filtered out when decorating the prototype.
- */
-fileprivate func isConstructor(_ item: AnyDefinition) -> Bool {
+/// Checks whether the definition item is a constructor — a synchronous function whose name is "constructor".
+///
+/// We do it that way for the following two reasons:
+/// - It's easier to reuse existing `SyncFunctionDefinition`.
+/// - Redefining prototype's `constructor` is a bad idea so a function with this name
+///   needs to be filtered out when decorating the prototype.
+private func isConstructor(_ item: AnyDefinition) -> Bool {
   return (item as? AnySyncFunctionDefinition)?.name == "constructor"
 }
diff --git a/ios/Core/Conversions.swift b/ios/Core/Conversions.swift
index d7500b7a198d420881d27c0427c1de6f5ab40471..22ea30760cf586f9d784ac4ffdb117eb0afd6df8 100644
--- a/ios/Core/Conversions.swift
+++ b/ios/Core/Conversions.swift
@@ -23,9 +23,14 @@ public struct Conversions {
     case 8:
       return (array[0], array[1], array[2], array[3], array[4], array[5], array[6], array[7])
     case 9:
-      return (array[0], array[1], array[2], array[3], array[4], array[5], array[6], array[7], array[8])
+      return (
+        array[0], array[1], array[2], array[3], array[4], array[5], array[6], array[7], array[8]
+      )
     case 10:
-      return (array[0], array[1], array[2], array[3], array[4], array[5], array[6], array[7], array[8], array[9])
+      return (
+        array[0], array[1], array[2], array[3], array[4], array[5], array[6], array[7], array[8],
+        array[9]
+      )
     default:
       throw TooManyArgumentsException((count: array.count, limit: 10))
     }
@@ -36,7 +41,9 @@ public struct Conversions {
     case let object as NSArray:
       return object.map { Conversions.fromNSObject($0) }
     case let object as NSDictionary:
-      let keyValuePairs: [(String, Any)] = object.map { ($0 as! String, Conversions.fromNSObject($1)) }
+      let keyValuePairs: [(String, Any)] = object.map {
+        ($0 as! String, Conversions.fromNSObject($1))
+      }
       return Dictionary(uniqueKeysWithValues: keyValuePairs)
     case is NSNull:
       return Optional<Any>.none as Any
@@ -50,7 +57,9 @@ public struct Conversions {
    - The dictionary is missing some of the given keys (`MissingKeysException`)
    - Some of the values cannot be cast to specified type (`CastingValuesException`)
    */
-  public static func pickValues<ValueType>(from dict: [String: Any], byKeys keys: [String], as type: ValueType.Type) throws -> [ValueType] {
+  public static func pickValues<ValueType>(
+    from dict: [String: Any], byKeys keys: [String], as type: ValueType.Type
+  ) throws -> [ValueType] {
     var result = (
       values: [ValueType](),
       missingKeys: [String](),
@@ -80,7 +89,8 @@ public struct Conversions {
    Converts hex string to `UIColor` or throws an exception if the string is corrupted.
    */
   static func toColor(hexString hex: String) throws -> UIColor {
-    var hexStr = hex
+    var hexStr =
+      hex
       .trimmingCharacters(in: .whitespacesAndNewlines)
       .replacingOccurrences(of: "#", with: "")
 
@@ -95,14 +105,15 @@ public struct Conversions {
         String(repeating: chars[0], count: 2),
         String(repeating: chars[1], count: 2),
         String(repeating: chars[2], count: 2),
-        String(repeating: chars[3], count: 2)
+        String(repeating: chars[3], count: 2),
       ].joined(separator: "")
     }
 
     var rgba: UInt64 = 0
 
     guard hexStr.range(of: #"^[0-9a-fA-F]{8}$"#, options: .regularExpression) != nil,
-          Scanner(string: hexStr).scanHexInt64(&rgba) else {
+      Scanner(string: hexStr).scanHexInt64(&rgba)
+    else {
       throw InvalidHexColorException(hex)
     }
     return try toColor(rgba: rgba)
@@ -117,9 +128,9 @@ public struct Conversions {
       throw HexColorOverflowException(argb)
     }
     let alpha = CGFloat((argb >> 24) & 0xff) / 255.0
-    let red   = CGFloat((argb >> 16) & 0xff) / 255.0
+    let red = CGFloat((argb >> 16) & 0xff) / 255.0
     let green = CGFloat((argb >> 8) & 0xff) / 255.0
-    let blue  = CGFloat(argb & 0xff) / 255.0
+    let blue = CGFloat(argb & 0xff) / 255.0
     return UIColor(red: red, green: green, blue: blue, alpha: alpha)
   }
 
@@ -130,9 +141,9 @@ public struct Conversions {
     guard rgba <= UInt32.max else {
       throw HexColorOverflowException(rgba)
     }
-    let red   = CGFloat((rgba >> 24) & 0xff) / 255.0
+    let red = CGFloat((rgba >> 24) & 0xff) / 255.0
     let green = CGFloat((rgba >> 16) & 0xff) / 255.0
-    let blue  = CGFloat((rgba >> 8) & 0xff) / 255.0
+    let blue = CGFloat((rgba >> 8) & 0xff) / 255.0
     let alpha = CGFloat(rgba & 0xff) / 255.0
     return UIColor(red: red, green: green, blue: blue, alpha: alpha)
   }
@@ -156,7 +167,9 @@ public struct Conversions {
     appContext: AppContext? = nil,
     dynamicType: AnyDynamicType? = nil
   ) -> Any {
-    if let appContext, let result = try? dynamicType?.convertResult(value as Any, appContext: appContext) {
+    if let appContext,
+      let result = try? dynamicType?.convertResult(value as Any, appContext: appContext)
+    {
       return result
     }
     return convertFunctionResultInRuntime(value, appContext: appContext)
@@ -168,7 +181,9 @@ public struct Conversions {
    so it is quite limited, e.g. it does not handle shared objects.
    Currently it is required to handle results of the promise.
    */
-  static func convertFunctionResultInRuntime<ValueType>(_ value: ValueType?, appContext: AppContext? = nil) -> Any {
+  static func convertFunctionResultInRuntime<ValueType>(
+    _ value: ValueType?, appContext: AppContext? = nil
+  ) -> Any {
     if let value = value as? Record {
       return value.toDictionary(appContext: appContext)
     }
@@ -195,7 +210,10 @@ public struct Conversions {
   /**
    An exception thrown when the native value cannot be converted to JavaScript value.
    */
-  internal final class ConversionToJSFailedException: GenericException<(kind: JavaScriptValueKind, nativeType: Any.Type)> {
+  internal final class ConversionToJSFailedException: GenericException<
+    (kind: JavaScriptValueKind, nativeType: Any.Type)
+  >
+  {
     override var code: String {
       "ERR_CONVERTING_TO_JS_FAILED"
     }
@@ -207,7 +225,10 @@ public struct Conversions {
   /**
    An exception thrown when the JavaScript value cannot be converted to native value.
    */
-  internal final class ConversionToNativeFailedException: GenericException<(kind: JavaScriptValueKind, nativeType: Any.Type)> {
+  internal final class ConversionToNativeFailedException: GenericException<
+    (kind: JavaScriptValueKind, nativeType: Any.Type)
+  >
+  {
     override var code: String {
       "ERR_CONVERTING_TO_NATIVE_FAILED"
     }
diff --git a/ios/Core/Convertibles/Convertibles+Color.swift b/ios/Core/Convertibles/Convertibles+Color.swift
index bba9b04f7c3f6a88cc5f89ca35159c5195e743ac..67d382386d457faa9ac9fad19516cb79b55cdaf5 100644
--- a/ios/Core/Convertibles/Convertibles+Color.swift
+++ b/ios/Core/Convertibles/Convertibles+Color.swift
@@ -19,7 +19,8 @@ extension UIColor: Convertible {
     // Handle `PlatformColor` and `DynamicColorIOS`
     if let opaqueValue = value as? [String: Any] {
       if let semanticName = opaqueValue["semantic"] as? String,
-        let color = resolveNamedColor(name: semanticName) {
+        let color = resolveNamedColor(name: semanticName)
+      {
         return color as! Self
       }
       if let semanticArray = opaqueValue["semantic"] as? [String] {
@@ -30,42 +31,51 @@ extension UIColor: Convertible {
         }
       }
       if let appearances = opaqueValue["dynamic"] as? [String: Any],
-        let lightColor = try appearances["light"].map({ try UIColor.convert(from: $0, appContext: appContext) }),
-        let darkColor = try appearances["dark"].map({ try UIColor.convert(from: $0, appContext: appContext) }) {
-        let highContrastLightColor = try appearances["highContrastLight"].map({ try UIColor.convert(from: $0, appContext: appContext) })
-        let highContrastDarkColor = try appearances["highContrastDark"].map({ try UIColor.convert(from: $0, appContext: appContext) })
+        let lightColor = try appearances["light"].map({
+          try UIColor.convert(from: $0, appContext: appContext)
+        }),
+        let darkColor = try appearances["dark"].map({
+          try UIColor.convert(from: $0, appContext: appContext)
+        })
+      {
+        let highContrastLightColor = try appearances["highContrastLight"].map({
+          try UIColor.convert(from: $0, appContext: appContext)
+        })
+        let highContrastDarkColor = try appearances["highContrastDark"].map({
+          try UIColor.convert(from: $0, appContext: appContext)
+        })
 
         #if os(iOS) || os(tvOS)
-        let color = UIColor { (traitCollection: UITraitCollection) -> UIColor in
-          if traitCollection.userInterfaceStyle == .dark {
-            if traitCollection.accessibilityContrast == .high, let highContrastDarkColor {
-              return highContrastDarkColor
+          let color = UIColor { (traitCollection: UITraitCollection) -> UIColor in
+            if traitCollection.userInterfaceStyle == .dark {
+              if traitCollection.accessibilityContrast == .high, let highContrastDarkColor {
+                return highContrastDarkColor
+              }
+              return darkColor
             }
-            return darkColor
-          }
 
-          if traitCollection.accessibilityContrast == .high, let highContrastLightColor {
-            return highContrastLightColor
+            if traitCollection.accessibilityContrast == .high, let highContrastLightColor {
+              return highContrastLightColor
+            }
+            return lightColor
           }
-          return lightColor
-        }
         #elseif os(macOS)
-        let color = NSColor(name: nil) { (appearance: NSAppearance) -> NSColor in
-          let isDarkMode = appearance.bestMatch(from: [.darkAqua, .aqua]) == .darkAqua
-          let isHighContrast = NSWorkspace.shared.accessibilityDisplayShouldIncreaseContrast
+          let color = NSColor(name: nil) { (appearance: NSAppearance) -> NSColor in
+            let isDarkMode = appearance.bestMatch(from: [.darkAqua, .aqua]) == .darkAqua
+            let isHighContrast = NSWorkspace.shared.accessibilityDisplayShouldIncreaseContrast
 
-          if isDarkMode {
-            if isHighContrast, let highContrastDarkColor = highContrastDarkColor {
-              return highContrastDarkColor
+            if isDarkMode {
+              if isHighContrast, let highContrastDarkColor = highContrastDarkColor {
+                return highContrastDarkColor
+              }
+              return darkColor
             }
-            return darkColor
-          }
 
-          if isHighContrast, let highContrastLightColor = highContrastLightColor {
-            return highContrastLightColor
+            if isHighContrast, let highContrastLightColor = highContrastLightColor {
+              return highContrastLightColor
+            }
+            return lightColor
           }
-          return lightColor
-        }
         #endif
         return color as! Self
       }
@@ -114,10 +124,8 @@ private func uiColorWithComponents(_ components: [Double]) -> UIColor {
   return UIColor(red: components[0], green: components[1], blue: components[2], alpha: alpha)
 }
 
-/**
- Color components for named colors following the [CSS3/SVG specification](https://www.w3.org/TR/css-color-3/#svg-color)
- and additionally the transparent color.
- */
+/// Color components for named colors following the [CSS3/SVG specification](https://www.w3.org/TR/css-color-3/#svg-color)
+/// and additionally the transparent color.
 private let namedColors: [String: [Double]] = [
   "aliceblue": [240, 248, 255, 255],
   "antiquewhite": [250, 235, 215, 255],
@@ -267,5 +275,5 @@ private let namedColors: [String: [Double]] = [
   "white": [255, 255, 255, 255],
   "whitesmoke": [245, 245, 245, 255],
   "yellow": [255, 255, 0, 255],
-  "yellowgreen": [154, 205, 50, 255]
+  "yellowgreen": [154, 205, 50, 255],
 ]
diff --git a/ios/Core/DynamicTypes/AnyDynamicType.swift b/ios/Core/DynamicTypes/AnyDynamicType.swift
index 6203087c5d8b7f066391a6c25c311de12edbf85e..0b0c3632bdf35105c0b3d1007a58eee1d8ad3819 100644
--- a/ios/Core/DynamicTypes/AnyDynamicType.swift
+++ b/ios/Core/DynamicTypes/AnyDynamicType.swift
@@ -1,9 +1,7 @@
 // Copyright 2021-present 650 Industries. All rights reserved.
 
-/**
- A protocol whose intention is to wrap any type
- to keep its real signature and not type-erase it by the compiler.
- */
+/// A protocol whose intention is to wrap any type
+/// to keep its real signature and not type-erase it by the compiler.
 public protocol AnyDynamicType: CustomStringConvertible {
   /**
    Checks whether the inner type is the same as the given type.
diff --git a/ios/Core/DynamicTypes/DynamicArrayType.swift b/ios/Core/DynamicTypes/DynamicArrayType.swift
index ffcb265f62bcd3101b276c06b6a6188d06f06877..af2bc40c9bd81dac2561237c66eff28545efe44e 100644
--- a/ios/Core/DynamicTypes/DynamicArrayType.swift
+++ b/ios/Core/DynamicTypes/DynamicArrayType.swift
@@ -1,9 +1,7 @@
 // Copyright 2021-present 650 Industries. All rights reserved.
 
-/**
- A dynamic type representing array types. Requires the array's element type
- for the initialization as it delegates casting to that type for each element in the array.
- */
+/// A dynamic type representing array types. Requires the array's element type
+/// for the initialization as it delegates casting to that type for each element in the array.
 internal struct DynamicArrayType: AnyDynamicType {
   let elementType: AnyDynamicType
 
@@ -44,10 +42,8 @@ internal struct DynamicArrayType: AnyDynamicType {
   }
 }
 
-/**
- A type-erased protocol used to recognize if the generic type is an array type.
- `Array` is a generic type, so it's impossible to check the inheritance directly.
- */
+/// A type-erased protocol used to recognize if the generic type is an array type.
+/// `Array` is a generic type, so it's impossible to check the inheritance directly.
 internal protocol AnyArray {
   /**
    Exposes the `Element` generic type wrapped by the dynamic type to preserve its metadata.
@@ -55,9 +51,7 @@ internal protocol AnyArray {
   static func getElementDynamicType() -> AnyDynamicType
 }
 
-/**
- Extends the `Array` type to expose its generic `Element` as a dynamic type.
- */
+/// Extends the `Array` type to expose its generic `Element` as a dynamic type.
 extension Array: AnyArray {
   static func getElementDynamicType() -> AnyDynamicType {
     return ~Element.self
diff --git a/ios/Core/DynamicTypes/DynamicConvertibleType.swift b/ios/Core/DynamicTypes/DynamicConvertibleType.swift
index a8b556d493534a92c1fc7607bf881013d31ef66b..99fc24c076dfc98248549acc6124dfbd0358a431 100644
--- a/ios/Core/DynamicTypes/DynamicConvertibleType.swift
+++ b/ios/Core/DynamicTypes/DynamicConvertibleType.swift
@@ -1,8 +1,6 @@
 // Copyright 2021-present 650 Industries. All rights reserved.
 
-/**
- A dynamic type that wraps any type conforming to `Convertible` protocol.
- */
+/// A dynamic type that wraps any type conforming to `Convertible` protocol.
 internal struct DynamicConvertibleType: AnyDynamicType {
   let innerType: Convertible.Type
 
diff --git a/ios/Core/DynamicTypes/DynamicDataType.swift b/ios/Core/DynamicTypes/DynamicDataType.swift
index 74950340c46d152bbdc09b4614f5d984113edcac..3f3622e62e2d11e52a0ca84c5981447f8daa3610 100644
--- a/ios/Core/DynamicTypes/DynamicDataType.swift
+++ b/ios/Core/DynamicTypes/DynamicDataType.swift
@@ -1,8 +1,6 @@
 // Copyright 2015-present 650 Industries. All rights reserved.
 
-/**
- A dynamic type representing Swift `Data` or Objective-C `NSData` type and backing by JavaScript `Uint8Array`.
- */
+/// A dynamic type representing Swift `Data` or Objective-C `NSData` type and backing by JavaScript `Uint8Array`.
 internal struct DynamicDataType: AnyDynamicType {
   static let shared = DynamicDataType()
 
@@ -18,10 +16,13 @@ internal struct DynamicDataType: AnyDynamicType {
    Converts JS typed array to its native representation.
    */
   func cast(jsValue: JavaScriptValue, appContext: AppContext) throws -> Any {
-    guard let jsTypedArray = jsValue.getTypedArray(), jsTypedArray.kind == TypedArrayKind.Uint8Array else {
+    guard let jsTypedArray = jsValue.getTypedArray(), jsTypedArray.kind == TypedArrayKind.Uint8Array
+    else {
       throw Conversions.CastingException<Uint8Array>(jsValue)
     }
-    return Data(bytes: jsTypedArray.getUnsafeMutableRawPointer(), count: jsTypedArray.getProperty("byteLength").getInt())
+    return Data(
+      bytes: jsTypedArray.getUnsafeMutableRawPointer(),
+      count: jsTypedArray.getProperty("byteLength").getInt())
   }
 
   var description: String {
diff --git a/ios/Core/DynamicTypes/DynamicDictionaryType.swift b/ios/Core/DynamicTypes/DynamicDictionaryType.swift
index 1e9bdf0378f60d282715e4573253604d7cd70731..cc0719b1cd82dd4d67c86ba49356937fa77b5fb7 100644
--- a/ios/Core/DynamicTypes/DynamicDictionaryType.swift
+++ b/ios/Core/DynamicTypes/DynamicDictionaryType.swift
@@ -1,9 +1,7 @@
 // Copyright 2015-present 650 Industries. All rights reserved.
 
-/**
- A dynamic type representing dictionary types. Requires the dictionary's value type
- for the initialization as it delegates casting to that type for each element in the dictionary.
- */
+/// A dynamic type representing dictionary types. Requires the dictionary's value type
+/// for the initialization as it delegates casting to that type for each element in the dictionary.
 internal struct DynamicDictionaryType: AnyDynamicType {
   let valueType: AnyDynamicType
 
@@ -46,10 +44,8 @@ internal struct DynamicDictionaryType: AnyDynamicType {
   }
 }
 
-/**
- A type-erased protocol used to recognize if the generic type is a dictionary type.
- `Dictionary` is a generic type, so it's impossible to check the inheritance directly.
- */
+/// A type-erased protocol used to recognize if the generic type is a dictionary type.
+/// `Dictionary` is a generic type, so it's impossible to check the inheritance directly.
 internal protocol AnyDictionary {
   /**
    Exposes the `Value` generic type wrapped by the dynamic type to preserve its metadata.
@@ -57,9 +53,7 @@ internal protocol AnyDictionary {
   static func getValueDynamicType() -> AnyDynamicType
 }
 
-/**
- Extends the `Dictionary` type to expose its generic `Value` as a dynamic type.
- */
+/// Extends the `Dictionary` type to expose its generic `Value` as a dynamic type.
 extension Dictionary: AnyDictionary {
   static func getValueDynamicType() -> AnyDynamicType {
     return ~Value.self
diff --git a/ios/Core/DynamicTypes/DynamicEitherType.swift b/ios/Core/DynamicTypes/DynamicEitherType.swift
index 10fc144794b98f34c563a6b9362ef6412f981ede..00777d00406c503a46ea35f2032b17a76aa531c4 100644
--- a/ios/Core/DynamicTypes/DynamicEitherType.swift
+++ b/ios/Core/DynamicTypes/DynamicEitherType.swift
@@ -18,7 +18,8 @@ internal struct DynamicEitherType<EitherType: AnyEither>: AnyDynamicType {
 
     for type in types {
       if let preliminaryValue = try? type.cast(jsValue: jsValue, appContext: appContext),
-        let value = try? type.cast(preliminaryValue, appContext: appContext) {
+        let value = try? type.cast(preliminaryValue, appContext: appContext)
+      {
         return EitherType(value)
       }
     }
diff --git a/ios/Core/DynamicTypes/DynamicEnumType.swift b/ios/Core/DynamicTypes/DynamicEnumType.swift
index 05b9b5dc25c910bdff3395dbcb6d1172ddb09fdd..519b62e406b9ebdeab898258e9c1385db8d65367 100644
--- a/ios/Core/DynamicTypes/DynamicEnumType.swift
+++ b/ios/Core/DynamicTypes/DynamicEnumType.swift
@@ -1,8 +1,6 @@
 // Copyright 2021-present 650 Industries. All rights reserved.
 
-/**
- A dynamic type representing an enum that conforms to `Enumerable`.
- */
+/// A dynamic type representing an enum that conforms to `Enumerable`.
 internal struct DynamicEnumType: AnyDynamicType {
   let innerType: any Enumerable.Type
 
diff --git a/ios/Core/DynamicTypes/DynamicJavaScriptType.swift b/ios/Core/DynamicTypes/DynamicJavaScriptType.swift
index 6ff4c5bcf9e4fde8f33b5491369d178d79086917..ba3953c34a9e8f7f3e0487667b751c5191c30168 100644
--- a/ios/Core/DynamicTypes/DynamicJavaScriptType.swift
+++ b/ios/Core/DynamicTypes/DynamicJavaScriptType.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- A dynamic type representing various types of JavaScript values.
- */
+/// A dynamic type representing various types of JavaScript values.
 internal struct DynamicJavaScriptType: AnyDynamicType {
   let innerType: AnyJavaScriptValue.Type
 
diff --git a/ios/Core/DynamicTypes/DynamicNumberType.swift b/ios/Core/DynamicTypes/DynamicNumberType.swift
index fd0eff85eee1527392a9b9e6ccd11cc9795cb997..a5d3692401961230c6f47620746e1ccd97e5a721 100644
--- a/ios/Core/DynamicTypes/DynamicNumberType.swift
+++ b/ios/Core/DynamicTypes/DynamicNumberType.swift
@@ -22,7 +22,8 @@ internal struct DynamicNumberType<NumberType>: AnyDynamicType {
         return IntegerType.init(jsValue.getDouble().rounded())
       }
     }
-    throw Conversions.ConversionToNativeFailedException((kind: jsValue.kind, nativeType: numberType))
+    throw Conversions.ConversionToNativeFailedException(
+      (kind: jsValue.kind, nativeType: numberType))
   }
 
   func cast<ValueType>(_ value: ValueType, appContext: AppContext) throws -> Any {
diff --git a/ios/Core/DynamicTypes/DynamicOptionalType.swift b/ios/Core/DynamicTypes/DynamicOptionalType.swift
index b8c865983ef6e65258162886e8f7fb99dad9b578..68358985ff2981548e251f678c6e70fde72489fe 100644
--- a/ios/Core/DynamicTypes/DynamicOptionalType.swift
+++ b/ios/Core/DynamicTypes/DynamicOptionalType.swift
@@ -1,9 +1,7 @@
 // Copyright 2021-present 650 Industries. All rights reserved.
 
-/**
- A dynamic type that represents an optional type, which allows `nil` to be passed when casting.
- Requires the optional's wrapped type as it delegates casting to that type for non-nil values.
- */
+/// A dynamic type that represents an optional type, which allows `nil` to be passed when casting.
+/// Requires the optional's wrapped type as it delegates casting to that type for non-nil values.
 internal struct DynamicOptionalType: AnyDynamicType {
   let wrappedType: AnyDynamicType
 
@@ -45,10 +43,8 @@ internal struct DynamicOptionalType: AnyDynamicType {
   }
 }
 
-/**
- A type-erased protocol used to recognize if the generic type is an optional type.
- `Optional` is a generic enum, so it's impossible to check the inheritance directly.
- */
+/// A type-erased protocol used to recognize if the generic type is an optional type.
+/// `Optional` is a generic enum, so it's impossible to check the inheritance directly.
 internal protocol AnyOptional {
   /**
    Exposes the `Wrapped` generic type wrapped by the dynamic type to preserve its metadata.`
@@ -56,9 +52,7 @@ internal protocol AnyOptional {
   static func getWrappedDynamicType() -> AnyDynamicType
 }
 
-/**
- Make generic `Optional` implement non-generic `AnyOptional` and add handy check against type-erased `nil`.
- */
+/// Make generic `Optional` implement non-generic `AnyOptional` and add handy check against type-erased `nil`.
 extension Optional: AnyOptional {
   static func getWrappedDynamicType() -> AnyDynamicType {
     return ~Wrapped.self
diff --git a/ios/Core/DynamicTypes/DynamicRawType.swift b/ios/Core/DynamicTypes/DynamicRawType.swift
index 30e24da6cea42cacbca75c0eef9e46d941c3bbb3..c14b0951f8bf0beb1e1c78eb7815d45aca2a830f 100644
--- a/ios/Core/DynamicTypes/DynamicRawType.swift
+++ b/ios/Core/DynamicTypes/DynamicRawType.swift
@@ -1,9 +1,7 @@
 // Copyright 2021-present 650 Industries. All rights reserved.
 
-/**
- A dynamic type that can wrap any type, but it casts only type-compatible values using `as?` keyword.
- The innermost type of the other dynamic types like `ArrayArgumentType` and `OptionalArgumentType`.
- */
+/// A dynamic type that can wrap any type, but it casts only type-compatible values using `as?` keyword.
+/// The innermost type of the other dynamic types like `ArrayArgumentType` and `OptionalArgumentType`.
 internal struct DynamicRawType<InnerType>: AnyDynamicType {
   let innerType: InnerType.Type
 
diff --git a/ios/Core/DynamicTypes/DynamicSharedObjectType.swift b/ios/Core/DynamicTypes/DynamicSharedObjectType.swift
index 8080bc53b2d9983bd4864b828caba6d83146e219..0b734c22181377f00689308522c1968c341180fd 100644
--- a/ios/Core/DynamicTypes/DynamicSharedObjectType.swift
+++ b/ios/Core/DynamicTypes/DynamicSharedObjectType.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- A dynamic type representing the `SharedObject` type and its subclasses.
- */
+/// A dynamic type representing the `SharedObject` type and its subclasses.
 internal struct DynamicSharedObjectType: AnyDynamicType {
   let innerType: AnySharedObject.Type
 
@@ -36,7 +34,8 @@ internal struct DynamicSharedObjectType: AnyDynamicType {
 
     // If the given value is a shared object id, search the registry for its native representation
     if let sharedObjectId = value as? SharedObjectId,
-      let nativeSharedObject = appContext.sharedObjectRegistry.get(sharedObjectId)?.native {
+      let nativeSharedObject = appContext.sharedObjectRegistry.get(sharedObjectId)?.native
+    {
       return nativeSharedObject
     }
     throw NativeSharedObjectNotFoundException()
@@ -46,13 +45,15 @@ internal struct DynamicSharedObjectType: AnyDynamicType {
     if jsValue.kind == .number {
       let sharedObjectId = jsValue.getInt() as SharedObjectId
 
-      guard let nativeSharedObject = appContext.sharedObjectRegistry.get(sharedObjectId)?.native else {
+      guard let nativeSharedObject = appContext.sharedObjectRegistry.get(sharedObjectId)?.native
+      else {
         throw NativeSharedObjectNotFoundException()
       }
       return nativeSharedObject
     }
     if let jsObject = try? jsValue.asObject(),
-      let nativeSharedObject = appContext.sharedObjectRegistry.toNativeObject(jsObject) {
+      let nativeSharedObject = appContext.sharedObjectRegistry.toNativeObject(jsObject)
+    {
       return nativeSharedObject
     }
     throw NativeSharedObjectNotFoundException()
diff --git a/ios/Core/DynamicTypes/DynamicStringType.swift b/ios/Core/DynamicTypes/DynamicStringType.swift
index f3a4b836db6c387de3382be3243d2dc30dfd68d3..2bfec6565669977d914b794af9331cd4007b44ce 100644
--- a/ios/Core/DynamicTypes/DynamicStringType.swift
+++ b/ios/Core/DynamicTypes/DynamicStringType.swift
@@ -22,7 +22,8 @@ internal struct DynamicStringType: AnyDynamicType {
     if jsValue.kind == .string {
       return jsValue.getString()
     }
-    throw Conversions.ConversionToNativeFailedException((kind: jsValue.kind, nativeType: String.self))
+    throw Conversions.ConversionToNativeFailedException(
+      (kind: jsValue.kind, nativeType: String.self))
   }
 
   func castToJS<ValueType>(_ value: ValueType, appContext: AppContext) throws -> JavaScriptValue {
diff --git a/ios/Core/DynamicTypes/DynamicSwiftUIViewType.swift b/ios/Core/DynamicTypes/DynamicSwiftUIViewType.swift
index 0ab5287dfff7a0a2a27f862364e0f6b324e956cb..3c5d9a5c3fe1b48ed1204248ab03b00d4decefca 100644
--- a/ios/Core/DynamicTypes/DynamicSwiftUIViewType.swift
+++ b/ios/Core/DynamicTypes/DynamicSwiftUIViewType.swift
@@ -34,7 +34,8 @@ internal struct DynamicSwiftUIViewType<ViewType: ExpoSwiftUIView>: AnyDynamicTyp
     guard Thread.isMainThread else {
       throw NonMainThreadException()
     }
-    guard let view = appContext.findView(withTag: viewTag, ofType: AnyExpoSwiftUIHostingView.self) else {
+    guard let view = appContext.findView(withTag: viewTag, ofType: AnyExpoSwiftUIHostingView.self)
+    else {
       throw Exceptions.SwiftUIViewNotFound((tag: viewTag, type: innerType.self))
     }
     return view.getContentView()
diff --git a/ios/Core/DynamicTypes/DynamicType.swift b/ios/Core/DynamicTypes/DynamicType.swift
index 638c43c705bc404e451a450e272383f94d0b996c..e48928c8cb3e840978307aaf39af36436c26d705 100644
--- a/ios/Core/DynamicTypes/DynamicType.swift
+++ b/ios/Core/DynamicTypes/DynamicType.swift
@@ -4,12 +4,10 @@
 // we want it to be uppercase as we treat it more like a generic class.
 // swiftlint:disable identifier_name
 
-/**
- Factory creating an instance of the dynamic type wrapper conforming to `AnyDynamicType`.
- Depending on the given type, it may return one of `DynamicArrayType`, `DynamicOptionalType`, `DynamicConvertibleType`, etc.
- Note that this goes through many type checks, thus it might be a bit more expensive than using generic type constraints,
- see the `~` prefix operator below that handles types conforming to `AnyArgument` in a faster way.
- */
+/// Factory creating an instance of the dynamic type wrapper conforming to `AnyDynamicType`.
+/// Depending on the given type, it may return one of `DynamicArrayType`, `DynamicOptionalType`, `DynamicConvertibleType`, etc.
+/// Note that this goes through many type checks, thus it might be a bit more expensive than using generic type constraints,
+/// see the `~` prefix operator below that handles types conforming to `AnyArgument` in a faster way.
 private func DynamicType<T>(_ type: T.Type) -> AnyDynamicType {
   if type is any Numeric.Type {
     return DynamicNumberType(numberType: T.self)
diff --git a/ios/Core/DynamicTypes/DynamicTypedArrayType.swift b/ios/Core/DynamicTypes/DynamicTypedArrayType.swift
index f9708f38c4ad0f077462f1fb77df4e6b7030de2a..dae3435528cb2c2b475708f158e40f20dd4733c6 100644
--- a/ios/Core/DynamicTypes/DynamicTypedArrayType.swift
+++ b/ios/Core/DynamicTypes/DynamicTypedArrayType.swift
@@ -44,7 +44,10 @@ internal struct DynamicTypedArrayType: AnyDynamicType {
   }
 }
 
-internal final class ArrayTypeMismatchException: GenericException<(received: Any.Type, expected: Any.Type)> {
+internal final class ArrayTypeMismatchException: GenericException<
+  (received: Any.Type, expected: Any.Type)
+>
+{
   override var reason: String {
     "Received a typed array of type \(param.received), expected \(param.expected)"
   }
diff --git a/ios/Core/EventListener.swift b/ios/Core/EventListener.swift
index da12336d6bcf00aebcc6e03350a8457decc6478b..cc2d1dbe0dc0400c25213c406468ca031d44a1cc 100644
--- a/ios/Core/EventListener.swift
+++ b/ios/Core/EventListener.swift
@@ -1,6 +1,4 @@
-/**
- Represents a listener for the specific event.
- */
+/// Represents a listener for the specific event.
 internal struct EventListener: AnyDefinition {
   let name: EventName
   let call: (Any?, Any?) throws -> Void
@@ -29,7 +27,8 @@ internal struct EventListener: AnyDefinition {
   /**
    Listener initializer for events that specify the payload.
    */
-  init<Sender, PayloadType>(_ name: EventName, _ listener: @escaping (Sender, PayloadType?) -> Void) {
+  init<Sender, PayloadType>(_ name: EventName, _ listener: @escaping (Sender, PayloadType?) -> Void)
+  {
     self.name = name
     self.call = { sender, payload in
       guard let sender = sender as? Sender else {
diff --git a/ios/Core/Events/Callback.swift b/ios/Core/Events/Callback.swift
index aee1a02b5d1c265c3839ff733d711ef815fefd60..1eb3874246e403b8727f43c85d1502fa3e162081 100644
--- a/ios/Core/Events/Callback.swift
+++ b/ios/Core/Events/Callback.swift
@@ -1,13 +1,9 @@
 // Copyright 2021-present 650 Industries. All rights reserved.
 
-/**
- An alias for type-erased callback handler.
- */
+/// An alias for type-erased callback handler.
 typealias AnyCallbackHandlerType = @convention(block) ([String: Any]) -> Void
 
-/**
- Public type-erased protocol that `Callback` object conforms to.
- */
+/// Public type-erased protocol that `Callback` object conforms to.
 public protocol AnyCallback {
   /**
    Initializes an empty callback (no-op).
@@ -15,9 +11,7 @@ public protocol AnyCallback {
   init()
 }
 
-/**
- Internal type-erased protocol for `Callback` object.
- */
+/// Internal type-erased protocol for `Callback` object.
 internal protocol AnyCallbackInternal: AnyCallback {
   /**
    Sets the callback handler. By default the callback
@@ -31,9 +25,7 @@ internal protocol AnyCallbackInternal: AnyCallback {
   func invalidate()
 }
 
-/**
- Callable object that represents a JavaScript function.
- */
+/// Callable object that represents a JavaScript function.
 public class Callback<ArgType>: AnyCallback, AnyCallbackInternal {
   /**
    The underlying closure to invoke when the callback is called.
diff --git a/ios/Core/Events/EventDispatcher.swift b/ios/Core/Events/EventDispatcher.swift
index 91b52cdab2ac9d32ff8e0b374bc08ce7db66a213..a77fbaca9b5dd34df72fc6f768bd8699d2a400f3 100644
--- a/ios/Core/Events/EventDispatcher.swift
+++ b/ios/Core/Events/EventDispatcher.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- An object that can dispatch native events.
- */
+/// An object that can dispatch native events.
 public final class EventDispatcher {
   /**
    Type of the event dispatcher handler.
@@ -53,11 +51,11 @@ public final class EventDispatcher {
   }
 }
 
-/**
- Installs convenient event dispatchers for the given event and view.
- The provided handler can be specific to Paper or Fabric.
- */
-internal func installEventDispatcher<ViewType>(forEvent eventName: String, onView view: ViewType, handler: @escaping EventDispatcher.Handler) {
+/// Installs convenient event dispatchers for the given event and view.
+/// The provided handler can be specific to Paper or Fabric.
+internal func installEventDispatcher<ViewType>(
+  forEvent eventName: String, onView view: ViewType, handler: @escaping EventDispatcher.Handler
+) {
   // Find view's property that is of type `EventDispatcher` and refers to this particular event name.
   let child = Mirror(reflecting: view).children.first {
     return isEventDispatcherWithName($0, eventName)
@@ -74,12 +72,11 @@ internal func installEventDispatcher<ViewType>(forEvent eventName: String, onVie
   }
 }
 
-/**
- Checks whether the mirror child refers to the event dispatcher with the given event name.
- */
+/// Checks whether the mirror child refers to the event dispatcher with the given event name.
 private func isEventDispatcherWithName(_ mirrorChild: Mirror.Child, _ eventName: String) -> Bool {
   guard let eventDispatcher = mirrorChild.value as? EventDispatcher else {
     return false
   }
-  return eventDispatcher.customName != nil ? eventDispatcher.customName == eventName : mirrorChild.label == eventName
+  return eventDispatcher.customName != nil
+    ? eventDispatcher.customName == eventName : mirrorChild.label == eventName
 }
diff --git a/ios/Core/Events/LegacyEventEmitterCompat.swift b/ios/Core/Events/LegacyEventEmitterCompat.swift
index 73a46ad11c410757013f631e9605d9187a1b8083..eb6fade8990db4fc9f1dc730d9b46986f4366721 100644
--- a/ios/Core/Events/LegacyEventEmitterCompat.swift
+++ b/ios/Core/Events/LegacyEventEmitterCompat.swift
@@ -11,7 +11,9 @@ public final class LegacyEventEmitterCompat: EXEventEmitterService {
   // swiftlint:disable:next implicitly_unwrapped_optional
   public func sendEvent(withName name: String!, body: Any!) {
     guard let appContext, let runtime = try? appContext.runtime else {
-      log.warn("Unable to send an event '\(String(describing: name))' because the runtime is not available")
+      log.warn(
+        "Unable to send an event '\(String(describing: name))' because the runtime is not available"
+      )
       return
     }
 
diff --git a/ios/Core/Exceptions/ChainableException.swift b/ios/Core/Exceptions/ChainableException.swift
index 98dd9dd6f66cb7b6714d2c643fd5bd6970063853..8fea4ace7320a5c882bee9cce976c6daa0dc79d5 100644
--- a/ios/Core/Exceptions/ChainableException.swift
+++ b/ios/Core/Exceptions/ChainableException.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- An exception that may have been caused by another error.
- */
+/// An exception that may have been caused by another error.
 public protocol ChainableException: Error, AnyObject {
   /**
    The direct cause of the exception.
@@ -25,8 +23,8 @@ public protocol ChainableException: Error, AnyObject {
   func isCausedBy<ErrorType: Error>(_ errorType: ErrorType.Type) -> Bool
 }
 
-public extension ChainableException {
-  var rootCause: Error? {
+extension ChainableException {
+  public var rootCause: Error? {
     if let cause = cause as? ChainableException {
       return cause.rootCause ?? cause
     }
@@ -34,12 +32,12 @@ public extension ChainableException {
   }
 
   @discardableResult
-  func causedBy(_ error: Error?) -> Self {
+  public func causedBy(_ error: Error?) -> Self {
     cause = error ?? cause
     return self
   }
 
-  func isCausedBy<ErrorType: Error>(_ errorType: ErrorType.Type) -> Bool {
+  public func isCausedBy<ErrorType: Error>(_ errorType: ErrorType.Type) -> Bool {
     if cause is ErrorType {
       return true
     }
diff --git a/ios/Core/Exceptions/CodedError.swift b/ios/Core/Exceptions/CodedError.swift
index 9e13858615faaabc916dbbb893a1c4161b22eb7e..1162c72809592c2bf51d8414ea6d9330c0045a51 100644
--- a/ios/Core/Exceptions/CodedError.swift
+++ b/ios/Core/Exceptions/CodedError.swift
@@ -1,37 +1,31 @@
 import Foundation
 
-/**
- A protocol for errors specyfing its `code` and providing the `description`.
- */
+/// A protocol for errors specyfing its `code` and providing the `description`.
 public protocol CodedError: Error, CustomStringConvertible {
   var code: String { get }
   var description: String { get }
 }
 
-/**
- Extends the `CodedError` to make a fallback for `code` and `description`.
- */
-public extension CodedError {
+/// Extends the `CodedError` to make a fallback for `code` and `description`.
+extension CodedError {
   /**
    The code is inferred from the class name — e.g. the code of `ModuleNotFoundError` becomes `ERR_MODULE_NOT_FOUND`.
    To obtain the code, the class name is cut off from generics and `Error` suffix, then it's converted to snake case and uppercased.
    */
-  var code: String {
+  public var code: String {
     return errorCodeFromString(String(describing: type(of: self)))
   }
 
   /**
    The description falls back to object's localized description.
    */
-  var description: String {
+  public var description: String {
     return localizedDescription
   }
 }
 
-/**
- Basic implementation of `CodedError` protocol,
- where the code and the description are provided in the initializer.
- */
+/// Basic implementation of `CodedError` protocol,
+/// where the code and the description are provided in the initializer.
 public struct SimpleCodedError: CodedError {
   public var code: String
   public var description: String
@@ -43,13 +37,15 @@ public struct SimpleCodedError: CodedError {
 }
 
 func errorCodeFromString(_ str: String) -> String {
-  let name = str.replacingOccurrences(of: #"(Error|Exception)?(<.*>)?$"#, with: "", options: .regularExpression)
+  let name = str.replacingOccurrences(
+    of: #"(Error|Exception)?(<.*>)?$"#, with: "", options: .regularExpression)
   // The pattern is valid, so it'll never throw
   // swiftlint:disable:next force_try
   let regex = try! NSRegularExpression(pattern: "(.)([A-Z])", options: [])
   let range = NSRange(location: 0, length: name.count)
 
-  return "ERR_" + regex
+  return "ERR_"
+    + regex
     .stringByReplacingMatches(in: name, options: [], range: range, withTemplate: "$1_$2")
     .uppercased()
 }
diff --git a/ios/Core/Exceptions/CommonExceptions.swift b/ios/Core/Exceptions/CommonExceptions.swift
index 692104f209263d2e9cc465411c5c180c0412a8cb..7166c6cff75eb6cc2b01991f888d9f05441e7d80 100644
--- a/ios/Core/Exceptions/CommonExceptions.swift
+++ b/ios/Core/Exceptions/CommonExceptions.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- A group of the most common exceptions that might be necessary for modules.
- */
+/// A group of the most common exceptions that might be necessary for modules.
 public struct Exceptions {
   /**
    The Expo app context is no longer available.
@@ -34,12 +32,18 @@ public struct Exceptions {
   /**
    An exception to throw when the view with the given tag and class cannot be found.
    */
-  public final class ViewNotFound<ViewType: UIView>: GenericException<(tag: Int, type: ViewType.Type)> {
+  public final class ViewNotFound<ViewType: UIView>: GenericException<
+    (tag: Int, type: ViewType.Type)
+  >
+  {
     override public var reason: String {
       "Unable to find the '\(param.type)' view with tag '\(param.tag)'"
     }
   }
-  public final class SwiftUIViewNotFound<ViewType: ExpoSwiftUIView>: GenericException<(tag: Int, type: ViewType.Type)> {
+  public final class SwiftUIViewNotFound<ViewType: ExpoSwiftUIView>: GenericException<
+    (tag: Int, type: ViewType.Type)
+  >
+  {
     override public var reason: String {
       "Unable to find the '\(param.type)' view with tag '\(param.tag)'"
     }
diff --git a/ios/Core/Exceptions/Exception.swift b/ios/Core/Exceptions/Exception.swift
index 11761597ad1849bc5877fc504be7813627d01778..1c6be51c90d65a3fe0cecac99cc3f4ef33c66411 100644
--- a/ios/Core/Exceptions/Exception.swift
+++ b/ios/Core/Exceptions/Exception.swift
@@ -1,6 +1,8 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-open class Exception: CodedError, ChainableException, CustomStringConvertible, CustomDebugStringConvertible {
+open class Exception: CodedError, ChainableException, CustomStringConvertible,
+  CustomDebugStringConvertible
+{
   open lazy var name: String = String(describing: Self.self)
 
   /**
@@ -29,7 +31,10 @@ open class Exception: CodedError, ChainableException, CustomStringConvertible, C
     self.customCode = nil
   }
 
-  public init(name: String, description: String, code: String? = nil, file: String = #fileID, line: UInt = #line, function: String = #function) {
+  public init(
+    name: String, description: String, code: String? = nil, file: String = #fileID,
+    line: UInt = #line, function: String = #function
+  ) {
     self.origin = ExceptionOrigin(file: file, line: line, function: function)
     self.customCode = code
     self.name = name
@@ -58,10 +63,10 @@ open class Exception: CodedError, ChainableException, CustomStringConvertible, C
   }
 }
 
-/**
- Concatenates the exception description with its cause description.
- */
-private func concatDescription(_ description: String, withCause cause: Error?, debug: Bool = false) -> String {
+/// Concatenates the exception description with its cause description.
+private func concatDescription(_ description: String, withCause cause: Error?, debug: Bool = false)
+  -> String
+{
   let causeSeparator = "\n→ Caused by: "
   switch cause {
   case let cause as Exception:
diff --git a/ios/Core/Exceptions/ExceptionOrigin.swift b/ios/Core/Exceptions/ExceptionOrigin.swift
index d78a77a7f09aeba161d75fdbff989a5f67303d0b..0084f78ed103e53f9867920066f891dcbfc1a4f8 100644
--- a/ios/Core/Exceptions/ExceptionOrigin.swift
+++ b/ios/Core/Exceptions/ExceptionOrigin.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- Represents the place in code where the exception was created.
- */
+/// Represents the place in code where the exception was created.
 public struct ExceptionOrigin: CustomStringConvertible {
   /**
    The path to the file in which the exception was created.
diff --git a/ios/Core/Exceptions/GenericException.swift b/ios/Core/Exceptions/GenericException.swift
index d7c7369e42b20f9c88e9d746284b485414f5278d..db0dcf8ddae2d49bba7ca182a3a3775302bb073e 100644
--- a/ios/Core/Exceptions/GenericException.swift
+++ b/ios/Core/Exceptions/GenericException.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- The exception that needs some additional parameters to be best described.
- */
+/// The exception that needs some additional parameters to be best described.
 open class GenericException<ParamType>: Exception {
   /**
    The additional parameter passed to the initializer.
@@ -13,7 +11,9 @@ open class GenericException<ParamType>: Exception {
    The default initializer that takes a param and captures the place in the code where the exception was created.
    - Warning: Call it only with one argument! If you need to pass more parameters, use a tuple instead.
    */
-  public init(_ param: ParamType, file: String = #fileID, line: UInt = #line, function: String = #function) {
+  public init(
+    _ param: ParamType, file: String = #fileID, line: UInt = #line, function: String = #function
+  ) {
     self.param = param
     super.init(file: file, line: line, function: function)
   }
diff --git a/ios/Core/Exceptions/UnexpectedException.swift b/ios/Core/Exceptions/UnexpectedException.swift
index 283ed494c4e56c09db97916d59fbfc206fa298ca..164a2f15c284709eef8a17c46c0acc5cba41f77b 100644
--- a/ios/Core/Exceptions/UnexpectedException.swift
+++ b/ios/Core/Exceptions/UnexpectedException.swift
@@ -1,12 +1,12 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- Exception wrapper used to handle unexpected internal native errors.
- */
+/// Exception wrapper used to handle unexpected internal native errors.
 public class UnexpectedException: Exception {
   private let errorDescription: String
 
-  public init(_ error: Error, file: String = #fileID, line: UInt = #line, function: String = #function) {
+  public init(
+    _ error: Error, file: String = #fileID, line: UInt = #line, function: String = #function
+  ) {
     self.errorDescription = error.localizedDescription
     super.init(file: file, line: line, function: function)
   }
diff --git a/ios/Core/Functions/AnyFunctionDefinition.swift b/ios/Core/Functions/AnyFunctionDefinition.swift
index 7d636b7fc60413815f4e5baa4c3e9417e784598c..98b0b959c3e3631a9f755b37bf14fbbeaf2b5759 100644
--- a/ios/Core/Functions/AnyFunctionDefinition.swift
+++ b/ios/Core/Functions/AnyFunctionDefinition.swift
@@ -1,11 +1,7 @@
-/**
- An alias to `Result<Any, Exception>` which can be passed to the function callback.
- */
+/// An alias to `Result<Any, Exception>` which can be passed to the function callback.
 public typealias FunctionCallResult = Result<Any, Exception>
 
-/**
- A protocol for any type-erased function.
- */
+/// A protocol for any type-erased function.
 internal protocol AnyFunctionDefinition: AnyDefinition, JavaScriptObjectBuilder {
   /**
    Name of the function. JavaScript refers to the function by this name.
@@ -44,7 +40,9 @@ internal protocol AnyFunctionDefinition: AnyDefinition, JavaScriptObjectBuilder
       - appContext: An app context where the function is being executed.
       - callback: A callback that receives a result of the function execution.
    */
-  func call(by owner: AnyObject?, withArguments args: [Any], appContext: AppContext, callback: @escaping (FunctionCallResult) -> ())
+  func call(
+    by owner: AnyObject?, withArguments args: [Any], appContext: AppContext,
+    callback: @escaping (FunctionCallResult) -> Void)
 }
 
 extension AnyFunctionDefinition {
diff --git a/ios/Core/Functions/AsyncFunctionDefinition.swift b/ios/Core/Functions/AsyncFunctionDefinition.swift
index b537c72d92a696c20ed4f499602fdd2f37bbabbb..f8287239381bfa29a56cbdee35874bab8b73684d 100644
--- a/ios/Core/Functions/AsyncFunctionDefinition.swift
+++ b/ios/Core/Functions/AsyncFunctionDefinition.swift
@@ -2,9 +2,7 @@
 
 import Dispatch
 
-/**
- Type-erased protocol for asynchronous functions.
- */
+/// Type-erased protocol for asynchronous functions.
 internal protocol AnyAsyncFunctionDefinition: AnyFunctionDefinition {
   /**
    Specifies on which queue the function should run.
@@ -12,15 +10,14 @@ internal protocol AnyAsyncFunctionDefinition: AnyFunctionDefinition {
   func runOnQueue(_ queue: DispatchQueue?) -> Self
 }
 
-/**
- The default queue used for module's async function calls.
- */
-private let defaultQueue = DispatchQueue(label: "expo.modules.AsyncFunctionQueue", qos: .userInitiated)
+/// The default queue used for module's async function calls.
+private let defaultQueue = DispatchQueue(
+  label: "expo.modules.AsyncFunctionQueue", qos: .userInitiated)
 
-/**
- Represents a function that can only be called asynchronously, thus its JavaScript equivalent returns a Promise.
- */
-public final class AsyncFunctionDefinition<Args, FirstArgType, ReturnType>: AnyAsyncFunctionDefinition {
+/// Represents a function that can only be called asynchronously, thus its JavaScript equivalent returns a Promise.
+public final class AsyncFunctionDefinition<Args, FirstArgType, ReturnType>:
+  AnyAsyncFunctionDefinition
+{
   typealias ClosureType = (Args) throws -> ReturnType
 
   /**
@@ -62,7 +59,10 @@ public final class AsyncFunctionDefinition<Args, FirstArgType, ReturnType>: AnyA
 
   var takesOwner: Bool = false
 
-  func call(by owner: AnyObject?, withArguments args: [Any], appContext: AppContext, callback: @escaping (FunctionCallResult) -> ()) {
+  func call(
+    by owner: AnyObject?, withArguments args: [Any], appContext: AppContext,
+    callback: @escaping (FunctionCallResult) -> Void
+  ) {
     let promise = Promise { value in
       callback(.success(Conversions.convertFunctionResult(value, appContext: appContext)))
     } rejecter: { exception in
@@ -121,7 +121,8 @@ public final class AsyncFunctionDefinition<Args, FirstArgType, ReturnType>: AnyA
     // It seems to be safe to capture a strong reference to `self` here. This is needed for detached functions, that are not part of the module definition.
     // Module definitions are held in memory anyway, but detached definitions (returned by other functions) are not, so we need to capture them here.
     // It will be deallocated when that JS host function is garbage-collected by the JS VM.
-    return try appContext.runtime.createAsyncFunction(name, argsCount: argumentsCount) { [self] this, args, resolve, reject in
+    return try appContext.runtime.createAsyncFunction(name, argsCount: argumentsCount) {
+      [self] this, args, resolve, reject in
       self.call(by: this, withArguments: args, appContext: appContext) { result in
         switch result {
         case .failure(let error):
diff --git a/ios/Core/Functions/ConcurrentFunctionDefinition.swift b/ios/Core/Functions/ConcurrentFunctionDefinition.swift
index 074971de46b0ac970c26a180751a660df1f866b4..4a958d9c375d0878f76ce45fbaa912e72a3a976c 100644
--- a/ios/Core/Functions/ConcurrentFunctionDefinition.swift
+++ b/ios/Core/Functions/ConcurrentFunctionDefinition.swift
@@ -1,10 +1,10 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- Represents a concurrent function that can only be called asynchronously, thus its JavaScript equivalent returns a Promise.
- As opposed to `AsyncFunctionDefinition`, it can leverage the new Swift's concurrency model and take the async/await closure.
- */
-public final class ConcurrentFunctionDefinition<Args, FirstArgType, ReturnType>: AnyFunctionDefinition {
+/// Represents a concurrent function that can only be called asynchronously, thus its JavaScript equivalent returns a Promise.
+/// As opposed to `AsyncFunctionDefinition`, it can leverage the new Swift's concurrency model and take the async/await closure.
+public final class ConcurrentFunctionDefinition<Args, FirstArgType, ReturnType>:
+  AnyFunctionDefinition
+{
   typealias ClosureType = (Args) async throws -> ReturnType
 
   let body: ClosureType
@@ -32,7 +32,10 @@ public final class ConcurrentFunctionDefinition<Args, FirstArgType, ReturnType>:
 
   var takesOwner: Bool = false
 
-  func call(by owner: AnyObject?, withArguments args: [Any], appContext: AppContext, callback: @escaping (FunctionCallResult) -> Void) {
+  func call(
+    by owner: AnyObject?, withArguments args: [Any], appContext: AppContext,
+    callback: @escaping (FunctionCallResult) -> Void
+  ) {
     var arguments: [Any]
 
     do {
@@ -62,7 +65,8 @@ public final class ConcurrentFunctionDefinition<Args, FirstArgType, ReturnType>:
 
       do {
         // Convert arguments to the types desired by the function.
-        let finalArguments = try cast(arguments: arguments, forFunction: self, appContext: appContext)
+        let finalArguments = try cast(
+          arguments: arguments, forFunction: self, appContext: appContext)
 
         // TODO: Right now we force cast the tuple in all types of functions, but we should throw another exception here.
         // swiftlint:disable force_cast
@@ -103,7 +107,8 @@ public final class ConcurrentFunctionDefinition<Args, FirstArgType, ReturnType>:
           reject(error.code, error.description, nil)
         case .success(let value):
           // Convert some results to primitive types (e.g. records) or JS values (e.g. shared objects)
-          let convertedResult = Conversions.convertFunctionResult(value, appContext: appContext, dynamicType: ~ReturnType.self)
+          let convertedResult = Conversions.convertFunctionResult(
+            value, appContext: appContext, dynamicType: ~ReturnType.self)
           resolve(convertedResult)
         }
       }
diff --git a/ios/Core/Functions/SyncFunctionDefinition.swift b/ios/Core/Functions/SyncFunctionDefinition.swift
index a9970f7b0fe6619d6fd179afc10b214cc40ab8e5..a1c326589c4b446419bc0a70664e419dacba9f77 100644
--- a/ios/Core/Functions/SyncFunctionDefinition.swift
+++ b/ios/Core/Functions/SyncFunctionDefinition.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- Type-erased protocol for synchronous functions.
- */
+/// Type-erased protocol for synchronous functions.
 internal protocol AnySyncFunctionDefinition: AnyFunctionDefinition {
   /**
    Calls the function synchronously with given arguments.
@@ -20,13 +18,13 @@ internal protocol AnySyncFunctionDefinition: AnyFunctionDefinition {
    It **must** be run on the thread used by the JavaScript runtime.
    */
   @discardableResult
-  func call(_ appContext: AppContext, withThis this: JavaScriptValue?, arguments: [JavaScriptValue]) throws -> JavaScriptValue
+  func call(_ appContext: AppContext, withThis this: JavaScriptValue?, arguments: [JavaScriptValue])
+    throws -> JavaScriptValue
 }
 
-/**
- Represents a function that can only be called synchronously.
- */
-public final class SyncFunctionDefinition<Args, FirstArgType, ReturnType>: AnySyncFunctionDefinition {
+/// Represents a function that can only be called synchronously.
+public final class SyncFunctionDefinition<Args, FirstArgType, ReturnType>: AnySyncFunctionDefinition
+{
   typealias ClosureType = (Args) throws -> ReturnType
 
   /**
@@ -61,10 +59,16 @@ public final class SyncFunctionDefinition<Args, FirstArgType, ReturnType>: AnySy
 
   var takesOwner: Bool = false
 
-  func call(by owner: AnyObject?, withArguments args: [Any], appContext: AppContext, callback: @escaping (FunctionCallResult) -> ()) {
+  func call(
+    by owner: AnyObject?, withArguments args: [Any], appContext: AppContext,
+    callback: @escaping (FunctionCallResult) -> Void
+  ) {
     do {
       let result = try call(by: owner, withArguments: args, appContext: appContext)
-      callback(.success(Conversions.convertFunctionResult(result, appContext: appContext, dynamicType: ~ReturnType.self)))
+      callback(
+        .success(
+          Conversions.convertFunctionResult(
+            result, appContext: appContext, dynamicType: ~ReturnType.self)))
     } catch let error as Exception {
       callback(.failure(error))
     } catch {
@@ -104,7 +108,9 @@ public final class SyncFunctionDefinition<Args, FirstArgType, ReturnType>: AnySy
     }
   }
 
-  func call(_ appContext: AppContext, withThis this: JavaScriptValue?, arguments: [JavaScriptValue]) throws -> JavaScriptValue {
+  func call(_ appContext: AppContext, withThis this: JavaScriptValue?, arguments: [JavaScriptValue])
+    throws -> JavaScriptValue
+  {
     do {
       try validateArgumentsNumber(function: self, received: arguments.count)
 
@@ -118,13 +124,15 @@ public final class SyncFunctionDefinition<Args, FirstArgType, ReturnType>: AnySy
       }
 
       // Convert JS values to non-JS native types desired by the function.
-      let nativeArguments = try appContext.converter.toNative(arguments, Array(dynamicArgumentTypes.dropFirst(allNativeArguments.count)))
+      let nativeArguments = try appContext.converter.toNative(
+        arguments, Array(dynamicArgumentTypes.dropFirst(allNativeArguments.count)))
 
       allNativeArguments.append(contentsOf: nativeArguments)
 
       // Fill in with nils in place of missing optional arguments.
       if arguments.count < argumentsCount {
-        allNativeArguments.append(contentsOf: Array(repeating: Any?.none as Any, count: argumentsCount - arguments.count))
+        allNativeArguments.append(
+          contentsOf: Array(repeating: Any?.none as Any, count: argumentsCount - arguments.count))
       }
 
       guard let argumentsTuple = try Conversions.toTuple(allNativeArguments) as? Args else {
@@ -147,7 +155,8 @@ public final class SyncFunctionDefinition<Args, FirstArgType, ReturnType>: AnySy
     // immediately lose the reference to the definition and thus the underlying native function.
     // It may potentially cause memory leaks, but at the time of writing this comment,
     // the native definition instance deallocates correctly when the JS VM triggers the garbage collector.
-    return try appContext.runtime.createSyncFunction(name, argsCount: argumentsCount) { [weak appContext, self] this, arguments in
+    return try appContext.runtime.createSyncFunction(name, argsCount: argumentsCount) {
+      [weak appContext, self] this, arguments in
       guard let appContext else {
         throw Exceptions.AppContextLost()
       }
diff --git a/ios/Core/JavaScriptFunction.swift b/ios/Core/JavaScriptFunction.swift
index 63358625099c97e72cefa26976d6a7e7b5481042..77fa486e71c79994013b7d25324e484b6f8ed28c 100644
--- a/ios/Core/JavaScriptFunction.swift
+++ b/ios/Core/JavaScriptFunction.swift
@@ -1,8 +1,6 @@
 // Copyright 2023-present 650 Industries. All rights reserved.
 
-/**
- Represents a JavaScript function that can be called by the native code and that must return the given generic `ReturnType`.
- */
+/// Represents a JavaScript function that can be called by the native code and that must return the given generic `ReturnType`.
 public final class JavaScriptFunction<ReturnType>: AnyArgument, AnyJavaScriptValue {
   /**
    Raw representation of the JavaScript function that doesn't impose any restrictions on the returned type.
@@ -24,7 +22,9 @@ public final class JavaScriptFunction<ReturnType>: AnyArgument, AnyJavaScriptVal
   /**
    Calls the function with the given `this` object and arguments.
    */
-  public func call(_ arguments: Any..., usingThis this: JavaScriptObject? = nil) throws -> ReturnType {
+  public func call(_ arguments: Any..., usingThis this: JavaScriptObject? = nil) throws
+    -> ReturnType
+  {
     return try call(withArguments: arguments, asConstructor: false, usingThis: this)
   }
 
@@ -38,7 +38,10 @@ public final class JavaScriptFunction<ReturnType>: AnyArgument, AnyJavaScriptVal
   /**
    Universal function that calls the function with given arguments, this object and whether to call it as a constructor.
    */
-  private func call(withArguments arguments: [Any] = [], asConstructor: Bool = false, usingThis this: JavaScriptObject? = nil) throws -> ReturnType {
+  private func call(
+    withArguments arguments: [Any] = [], asConstructor: Bool = false,
+    usingThis this: JavaScriptObject? = nil
+  ) throws -> ReturnType {
     guard let appContext else {
       throw Exceptions.AppContextLost()
     }
diff --git a/ios/Core/JavaScriptUtils.swift b/ios/Core/JavaScriptUtils.swift
index fb65c1dad936a4f2e34e9985bd0669da8c16518b..75e89dfe15680c14bef62032c7450d91ca908df8 100644
--- a/ios/Core/JavaScriptUtils.swift
+++ b/ios/Core/JavaScriptUtils.swift
@@ -2,16 +2,16 @@
 
 // MARK: - Arguments
 
-/**
- Tries to cast a given value to the type that is wrapped by the dynamic type.
- - Parameters:
-  - value: A value to be cast. If it's a ``JavaScriptValue``, it's first unpacked to the raw value.
-  - type: Something that implements ``AnyDynamicType`` and knows how to cast the argument.
- - Returns: A new value converted according to the dynamic type.
- - Throws: Rethrows various exceptions that could be thrown by the dynamic types.
- */
-internal func cast(_ value: Any, toType type: AnyDynamicType, appContext: AppContext) throws -> Any {
-  if let dynamicJSType = type as? DynamicJavaScriptType, dynamicJSType.equals(~JavaScriptValue.self)  {
+/// Tries to cast a given value to the type that is wrapped by the dynamic type.
+/// - Parameters:
+///  - value: A value to be cast. If it's a ``JavaScriptValue``, it's first unpacked to the raw value.
+///  - type: Something that implements ``AnyDynamicType`` and knows how to cast the argument.
+/// - Returns: A new value converted according to the dynamic type.
+/// - Throws: Rethrows various exceptions that could be thrown by the dynamic types.
+internal func cast(_ value: Any, toType type: AnyDynamicType, appContext: AppContext) throws -> Any
+{
+  if let dynamicJSType = type as? DynamicJavaScriptType, dynamicJSType.equals(~JavaScriptValue.self)
+  {
     return value
   }
   if !(type is DynamicTypedArrayType), let value = value as? JavaScriptValue {
@@ -20,17 +20,17 @@ internal func cast(_ value: Any, toType type: AnyDynamicType, appContext: AppCon
   return try type.cast(value, appContext: appContext)
 }
 
-/**
- Tries to cast the given arguments to the types expected by the function.
- - Parameters:
-   - arguments: An array of arguments to be cast.
-   - function: A function for which to cast the arguments.
-   - appContext: A context of the app.
- - Returns: An array of arguments after casting. Its size is the same as the input arrays.
- - Throws: `InvalidArgsNumberException` when the number of arguments is not equal to the actual number
- of function's arguments (without an owner and promise). Rethrows exceptions thrown by `cast(_:toType:)`.
- */
-internal func cast(arguments: [Any], forFunction function: AnyFunctionDefinition, appContext: AppContext) throws -> [Any] {
+/// Tries to cast the given arguments to the types expected by the function.
+/// - Parameters:
+///   - arguments: An array of arguments to be cast.
+///   - function: A function for which to cast the arguments.
+///   - appContext: A context of the app.
+/// - Returns: An array of arguments after casting. Its size is the same as the input arrays.
+/// - Throws: `InvalidArgsNumberException` when the number of arguments is not equal to the actual number
+/// of function's arguments (without an owner and promise). Rethrows exceptions thrown by `cast(_:toType:)`.
+internal func cast(
+  arguments: [Any], forFunction function: AnyFunctionDefinition, appContext: AppContext
+) throws -> [Any] {
   return try arguments.enumerated().map { index, argument in
     let argumentType = function.dynamicArgumentTypes[index]
 
@@ -42,10 +42,10 @@ internal func cast(arguments: [Any], forFunction function: AnyFunctionDefinition
   }
 }
 
-/**
- Casts an array of JavaScript values to non-JavaScript types.
- */
-internal func cast(jsValues: [Any], forFunction function: AnyFunctionDefinition, appContext: AppContext) throws -> [Any] {
+/// Casts an array of JavaScript values to non-JavaScript types.
+internal func cast(
+  jsValues: [Any], forFunction function: AnyFunctionDefinition, appContext: AppContext
+) throws -> [Any] {
   // TODO: Replace `[Any]` with `[JavaScriptValue]` once we make sure only JS values are passed here
   return try jsValues.enumerated().map { index, jsValue in
     let type = function.dynamicArgumentTypes[index]
@@ -63,28 +63,25 @@ internal func cast(jsValues: [Any], forFunction function: AnyFunctionDefinition,
   }
 }
 
-/**
- Validates whether the number of received arguments is enough to call the given function.
- Throws `InvalidArgsNumberException` otherwise.
- */
+/// Validates whether the number of received arguments is enough to call the given function.
+/// Throws `InvalidArgsNumberException` otherwise.
 internal func validateArgumentsNumber(function: AnyFunctionDefinition, received: Int) throws {
   let argumentsCount = function.argumentsCount
   let requiredArgumentsCount = function.requiredArgumentsCount
 
   if received < requiredArgumentsCount || received > argumentsCount {
-    throw InvalidArgsNumberException((
-      received: received,
-      expected: argumentsCount,
-      required: requiredArgumentsCount
-    ))
+    throw InvalidArgsNumberException(
+      (
+        received: received,
+        expected: argumentsCount,
+        required: requiredArgumentsCount
+      ))
   }
 }
 
-/**
- Ensures the provided array of arguments matches the number of arguments expected by the function.
- - If the function takes the owner, it's added to the beginning.
- - If the array is still too small, missing arguments are very likely to be optional so it puts `nil` in their place.
- */
+/// Ensures the provided array of arguments matches the number of arguments expected by the function.
+/// - If the function takes the owner, it's added to the beginning.
+/// - If the array is still too small, missing arguments are very likely to be optional so it puts `nil` in their place.
 internal func concat(
   arguments: [Any],
   withOwner owner: AnyObject?,
@@ -109,10 +106,14 @@ internal func concat(
 
 // MARK: - Exceptions
 
-internal class InvalidArgsNumberException: GenericException<(received: Int, expected: Int, required: Int)> {
+internal class InvalidArgsNumberException: GenericException<
+  (received: Int, expected: Int, required: Int)
+>
+{
   override var reason: String {
     if param.required < param.expected {
-      return "Received \(param.received) arguments, but \(param.expected) was expected and at least \(param.required) is required"
+      return
+        "Received \(param.received) arguments, but \(param.expected) was expected and at least \(param.required) is required"
     } else {
       return "Received \(param.received) arguments, but \(param.expected) was expected"
     }
diff --git a/ios/Core/Logging/LogHandlers.swift b/ios/Core/Logging/LogHandlers.swift
index 867e8f346b19083dd33dbb8b260163f02d142944..84fe9a847fb58e22701c310c815836f4631a30ac 100644
--- a/ios/Core/Logging/LogHandlers.swift
+++ b/ios/Core/Logging/LogHandlers.swift
@@ -13,16 +13,12 @@ public func createPersistentFileLogHandler(category: String) -> LogHandler {
   return PersistentFileLogHandler(category: category)
 }
 
-/**
- The protocol that needs to be implemented by log handlers.
- */
+/// The protocol that needs to be implemented by log handlers.
 public protocol LogHandler {
   func log(type: LogType, _ message: String)
 }
 
-/**
- The log handler that uses the new `os.Logger` API.
- */
+/// The log handler that uses the new `os.Logger` API.
 @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
 internal class OSLogHandler: LogHandler {
   private let osLogger: os.Logger
@@ -36,18 +32,14 @@ internal class OSLogHandler: LogHandler {
   }
 }
 
-/**
- Simple log handler that forwards all logs to `print` function.
- */
+/// Simple log handler that forwards all logs to `print` function.
 internal class PrintLogHandler: LogHandler {
   func log(type: LogType, _ message: String) {
     print(message)
   }
 }
 
-/**
- Log handler that writes all logs to a file using PersistentFileLog
- */
+/// Log handler that writes all logs to a file using PersistentFileLog
 internal class PersistentFileLogHandler: LogHandler {
   private let persistentLog: PersistentFileLog
 
diff --git a/ios/Core/Logging/LogType.swift b/ios/Core/Logging/LogType.swift
index e6bf4627938e9b74e4e8690f83c802182a6592d9..ee0631d6cda7c50a7209678b1502e35897730c4f 100644
--- a/ios/Core/Logging/LogType.swift
+++ b/ios/Core/Logging/LogType.swift
@@ -2,9 +2,7 @@
 
 import os.log
 
-/**
- An enum with available log types.
- */
+/// An enum with available log types.
 public enum LogType: Int {
   case trace = 0
   case timer = 1
diff --git a/ios/Core/Logging/Logger.swift b/ios/Core/Logging/Logger.swift
index 54bc137978c99b3debeea8bbad892bdfddd78ba4..2fd13e1d925d43fe95355ee001dd5ed26b8fba42 100644
--- a/ios/Core/Logging/Logger.swift
+++ b/ios/Core/Logging/Logger.swift
@@ -6,18 +6,16 @@ public let log = Logger(logHandlers: [createOSLogHandler(category: Logger.EXPO_L
 
 public typealias LoggerTimerFormatterBlock = (_ duration: Double) -> String
 
-/**
- Native iOS logging class for Expo, with options to direct logs
- to different destinations.
- */
+/// Native iOS logging class for Expo, with options to direct logs
+/// to different destinations.
 public class Logger {
   public static let EXPO_MODULES_LOG_SUBSYSTEM = "dev.expo.modules"
   public static let EXPO_LOG_CATEGORY = "expo"
 
   #if DEBUG || EXPO_CONFIGURATION_DEBUG
-  private var minLevel: LogType = .trace
+    private var minLevel: LogType = .trace
   #else
-  private var minLevel: LogType = .info
+    private var minLevel: LogType = .info
   #endif
 
   private let logHandlers: [LogHandler]
@@ -123,7 +121,8 @@ public class Logger {
     guard type.rawValue >= minLevel.rawValue else {
       return
     }
-    let messages = items
+    let messages =
+      items
       .map { describe(value: $0) }
       .joined(separator: " ")
       .split(whereSeparator: \.isNewline)
diff --git a/ios/Core/Logging/LoggerTimer.swift b/ios/Core/Logging/LoggerTimer.swift
index 9ce7ca539dca704b796f113216dcedb109d0ebad..96e18ec3d7657ce94b01a54996c44851061f5547 100644
--- a/ios/Core/Logging/LoggerTimer.swift
+++ b/ios/Core/Logging/LoggerTimer.swift
@@ -4,9 +4,7 @@ import Foundation
 
 typealias LoggerTimerStopBlock = () -> Double
 
-/**
- An instance of a timer.
- */
+/// An instance of a timer.
 public class LoggerTimer {
   private let stopBlock: LoggerTimerStopBlock
 
diff --git a/ios/Core/Logging/PersistentFileLog.swift b/ios/Core/Logging/PersistentFileLog.swift
index 2863e1aa542bd1c5cd9b4b39efd7a1eab070e473..dc0c7b0a1c8ac15b012d5109bb086718612f39d0 100644
--- a/ios/Core/Logging/PersistentFileLog.swift
+++ b/ios/Core/Logging/PersistentFileLog.swift
@@ -5,26 +5,23 @@ import Foundation
 public typealias PersistentFileLogFilter = (String) -> Bool
 public typealias PersistentFileLogCompletionHandler = (Error?) -> Void
 
-/**
- * A thread-safe class for reading and writing line-separated strings to a flat file.
- * The main use case is for logging specific errors or events, and ensuring that the
- * logs persist across application crashes and restarts (for example, OSLogReader can
- * only read system logs for the current process, and cannot access anything logged
- * before the current process started).
- *
- * All write access to the file goes through asynchronous public methods managed by a
- * serial dispatch queue.
- *
- * The dispatch queue is global, to ensure that multiple instances accessing the same
- * file will have thread-safe access.
- *
- * The only operations supported are
- * - Read the file (synchronous)
- * - Append one or more entries to the file
- * - Filter the file (only retain entries that pass the filter check)
- * - Clear the file (remove all entries)
- *
- */
+/// A thread-safe class for reading and writing line-separated strings to a flat file.
+/// The main use case is for logging specific errors or events, and ensuring that the
+/// logs persist across application crashes and restarts (for example, OSLogReader can
+/// only read system logs for the current process, and cannot access anything logged
+/// before the current process started).
+///
+/// All write access to the file goes through asynchronous public methods managed by a
+/// serial dispatch queue.
+///
+/// The dispatch queue is global, to ensure that multiple instances accessing the same
+/// file will have thread-safe access.
+///
+/// The only operations supported are
+/// - Read the file (synchronous)
+/// - Append one or more entries to the file
+/// - Filter the file (only retain entries that pass the filter check)
+/// - Clear the file (remove all entries)
 public class PersistentFileLog {
   private static let EXPO_MODULES_CORE_LOG_QUEUE_LABEL = "dev.expo.modules.core.logging"
   private static let serialQueue = DispatchQueue(label: EXPO_MODULES_CORE_LOG_QUEUE_LABEL)
@@ -36,7 +33,9 @@ public class PersistentFileLog {
     self.category = category
     let fileName = "\(PersistentFileLog.EXPO_MODULES_CORE_LOG_QUEUE_LABEL).\(category).txt"
     // Execution aborts if no application support directory
-    self.filePath = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!.appendingPathComponent(fileName).path
+    self.filePath =
+      FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
+      .appendingPathComponent(fileName).path
   }
   /**
    Read entries from log file
@@ -53,7 +52,9 @@ public class PersistentFileLog {
    Since logging may not require a result handler, the handler parameter is optional
    If no error handler provided, print error to the console
    */
-  public func appendEntry(entry: String, _ completionHandler: PersistentFileLogCompletionHandler? = nil) {
+  public func appendEntry(
+    entry: String, _ completionHandler: PersistentFileLogCompletionHandler? = nil
+  ) {
     PersistentFileLog.serialQueue.async {
       self.ensureFileExists()
       do {
@@ -68,7 +69,10 @@ public class PersistentFileLog {
   /**
    Filter existing entries and remove ones where filter(entry) == false
    */
-  public func purgeEntriesNotMatchingFilter(filter: @escaping PersistentFileLogFilter, _ completionHandler: @escaping PersistentFileLogCompletionHandler) {
+  public func purgeEntriesNotMatchingFilter(
+    filter: @escaping PersistentFileLogFilter,
+    _ completionHandler: @escaping PersistentFileLogCompletionHandler
+  ) {
     PersistentFileLog.serialQueue.async {
       self.ensureFileExists()
       do {
@@ -107,7 +111,8 @@ public class PersistentFileLog {
   private func getFileSize() -> Int {
     // Gets the file size, or returns 0 if the file does not exist
     do {
-      let attrs: [FileAttributeKey: Any?] = try FileManager.default.attributesOfItem(atPath: filePath)
+      let attrs: [FileAttributeKey: Any?] = try FileManager.default.attributesOfItem(
+        atPath: filePath)
       return attrs[FileAttributeKey.size] as? Int ?? 0
     } catch {
       return 0
@@ -147,9 +152,10 @@ public class PersistentFileLog {
     guard let contents = contents, !contents.isEmpty else {
       return []
     }
-    return contents
+    return
+      contents
       .components(separatedBy: "\n")
-      .filter {entryString in
+      .filter { entryString in
         !entryString.isEmpty
       }
   }
diff --git a/ios/Core/MainValueConverter.swift b/ios/Core/MainValueConverter.swift
index 3122718457f3db62bf34901dcce7b2ce62f2d9e0..70b71085ba407e7fde7dee514d45796e7ddfee44 100644
--- a/ios/Core/MainValueConverter.swift
+++ b/ios/Core/MainValueConverter.swift
@@ -1,8 +1,6 @@
 // Copyright 2024-present 650 Industries. All rights reserved.
 
-/**
- A converter associated with the specific app context that delegates value conversions to the dynamic type converters.
- */
+/// A converter associated with the specific app context that delegates value conversions to the dynamic type converters.
 public struct MainValueConverter {
   /**
    It holds a strong reference as the AppContext is the only owner of the converter.
@@ -45,7 +43,8 @@ public struct MainValueConverter {
   /**
    Converts the given value to the type compatible with JavaScript.
    */
-  public func toJS<ValueType>(_ value: ValueType, _ type: AnyDynamicType) throws -> JavaScriptValue {
+  public func toJS<ValueType>(_ value: ValueType, _ type: AnyDynamicType) throws -> JavaScriptValue
+  {
     let result = Conversions.convertFunctionResult(value, appContext: appContext, dynamicType: type)
     return try type.castToJS(result, appContext: appContext)
   }
diff --git a/ios/Core/ModuleHolder.swift b/ios/Core/ModuleHolder.swift
index bfd578e9278399ae1019007965ca0f9cbb940239..e46c1f1508ca5a1eb13e1e666535889adfb07be5 100644
--- a/ios/Core/ModuleHolder.swift
+++ b/ios/Core/ModuleHolder.swift
@@ -1,8 +1,6 @@
 import Dispatch
 
-/**
- Holds a reference to the module instance and caches its definition.
- */
+/// Holds a reference to the module instance and caches its definition.
 public final class ModuleHolder {
   /**
    Instance of the module.
@@ -54,13 +52,17 @@ public final class ModuleHolder {
 
   // MARK: Calling functions
 
-  func call(function functionName: String, args: [Any], _ callback: @escaping (FunctionCallResult) -> () = { _ in }) {
+  func call(
+    function functionName: String, args: [Any],
+    _ callback: @escaping (FunctionCallResult) -> Void = { _ in }
+  ) {
     guard let appContext else {
       callback(.failure(Exceptions.AppContextLost()))
       return
     }
     guard let function = definition.functions[functionName] else {
-      callback(.failure(FunctionNotFoundException((functionName: functionName, moduleName: self.name))))
+      callback(
+        .failure(FunctionNotFoundException((functionName: functionName, moduleName: self.name))))
       return
     }
     function.call(by: self, withArguments: args, appContext: appContext, callback: callback)
@@ -68,7 +70,9 @@ public final class ModuleHolder {
 
   @discardableResult
   func callSync(function functionName: String, args: [Any]) -> Any? {
-    guard let appContext, let function = definition.functions[functionName] as? AnySyncFunctionDefinition else {
+    guard let appContext,
+      let function = definition.functions[functionName] as? AnySyncFunctionDefinition
+    else {
       return nil
     }
     do {
@@ -76,7 +80,8 @@ public final class ModuleHolder {
       let result = try function.call(by: self, withArguments: arguments, appContext: appContext)
 
       if let result = result as? SharedObject {
-        return appContext.sharedObjectRegistry.ensureSharedJavaScriptObject(runtime: try appContext.runtime, nativeObject: result)
+        return appContext.sharedObjectRegistry.ensureSharedJavaScriptObject(
+          runtime: try appContext.runtime, nativeObject: result)
       }
       return result
     } catch {
@@ -157,7 +162,10 @@ public final class ModuleHolder {
     }
   }
 
-  internal class FunctionNotFoundException: GenericException<(functionName: String, moduleName: String)> {
+  internal class FunctionNotFoundException: GenericException<
+    (functionName: String, moduleName: String)
+  >
+  {
     override var reason: String {
       "Function '\(param.functionName)' not found in module '\(param.moduleName)'"
     }
diff --git a/ios/Core/ModuleRegistry.swift b/ios/Core/ModuleRegistry.swift
index 4b53796fb229f7550beba0404e7dcbc3341d2058..9dc80938582d1bf189f985bd03a0544fbfa3e6c5 100644
--- a/ios/Core/ModuleRegistry.swift
+++ b/ios/Core/ModuleRegistry.swift
@@ -18,7 +18,9 @@ public final class ModuleRegistry: Sequence {
 
     // if overriding is disallowed for this module and the module already registered, don't re-register
     if overrideDisallowModules.contains(holder.name) && registry[holder.name] != nil {
-      log.info("Not re-registering module '\(holder.name)' since a previous registration specified preventModuleOverriding: true")
+      log.info(
+        "Not re-registering module '\(holder.name)' since a previous registration specified preventModuleOverriding: true"
+      )
       return
     }
 
@@ -36,7 +38,9 @@ public final class ModuleRegistry: Sequence {
       log.error("Unable to register a module '\(module)', the app context is unavailable")
       return
     }
-    register(holder: ModuleHolder(appContext: appContext, module: module), preventModuleOverriding: preventModuleOverriding)
+    register(
+      holder: ModuleHolder(appContext: appContext, module: module),
+      preventModuleOverriding: preventModuleOverriding)
   }
 
   /**
@@ -47,7 +51,9 @@ public final class ModuleRegistry: Sequence {
       log.error("Unable to register a module '\(moduleType)', the app context is unavailable")
       return
     }
-    register(module: moduleType.init(appContext: appContext), preventModuleOverriding: preventModuleOverriding)
+    register(
+      module: moduleType.init(appContext: appContext),
+      preventModuleOverriding: preventModuleOverriding)
   }
 
   /**
diff --git a/ios/Core/Modules/CoreModule.swift b/ios/Core/Modules/CoreModule.swift
index 776669601871a15741100f5bf107299034d5b1c9..1758b96a19b9efae589e165babbb7a57a750cfb3 100644
--- a/ios/Core/Modules/CoreModule.swift
+++ b/ios/Core/Modules/CoreModule.swift
@@ -21,7 +21,8 @@ internal final class CoreModule: Module {
     Function("getViewConfig") { (viewName: String) -> [String: Any]? in
       var validAttributes: [String: Any] = [:]
       var directEventTypes: [String: Any] = [:]
-      let moduleHolder = appContext?.moduleRegistry.get(moduleHolderForName: getHolderName(viewName))
+      let moduleHolder = appContext?.moduleRegistry.get(
+        moduleHolderForName: getHolderName(viewName))
 
       guard let viewDefinition = moduleHolder?.definition.view else {
         return nil
@@ -40,7 +41,7 @@ internal final class CoreModule: Module {
 
       return [
         "validAttributes": validAttributes,
-        "directEventTypes": directEventTypes
+        "directEventTypes": directEventTypes,
       ]
     }
 
diff --git a/ios/Core/Modules/Module.swift b/ios/Core/Modules/Module.swift
index b92e43a423f5ddb24401418f4025c082084968e2..0173ee5cc9f8eed4bc88bd9fcb6e52e8cc54f971 100644
--- a/ios/Core/Modules/Module.swift
+++ b/ios/Core/Modules/Module.swift
@@ -1,14 +1,16 @@
 // Copyright 2021-present 650 Industries. All rights reserved.
 
-/**
- `BaseModule` is just a stub class that fulfils `AnyModule` protocol requirement of public default initializer,
- but doesn't implement that protocol explicitly, though — it would have to provide a definition which would require
- other modules to use `override` keyword in the function returning the definition.
- */
+/// `BaseModule` is just a stub class that fulfils `AnyModule` protocol requirement of public default initializer,
+/// but doesn't implement that protocol explicitly, though — it would have to provide a definition which would require
+/// other modules to use `override` keyword in the function returning the definition.
 open class BaseModule {
   public private(set) weak var appContext: AppContext?
 
-  @available(*, unavailable, message: "Module's initializer cannot be overriden, use \"onCreate\" definition component instead.")
+  @available(
+    *, unavailable,
+    message:
+      "Module's initializer cannot be overriden, use \"onCreate\" definition component instead."
+  )
   public init() {}
 
   required public init(appContext: AppContext) {
@@ -23,7 +25,5 @@ open class BaseModule {
   }
 }
 
-/**
- An alias for `AnyModule` extended by the `BaseModule` class that provides public default initializer.
- */
+/// An alias for `AnyModule` extended by the `BaseModule` class that provides public default initializer.
 public typealias Module = AnyModule & BaseModule
diff --git a/ios/Core/Modules/ModuleDefinition.swift b/ios/Core/Modules/ModuleDefinition.swift
index d0287ac32bec909797b60281a63c32c797c43436..6367b5d002e4d9ff3fd39a816899f61f6fd96fc9 100644
--- a/ios/Core/Modules/ModuleDefinition.swift
+++ b/ios/Core/Modules/ModuleDefinition.swift
@@ -1,8 +1,6 @@
-/**
- The definition of the module. It is used to define some parameters
- of the module and what it exports to the JavaScript world.
- See `ModuleDefinitionBuilder` for more details on how to create it.
- */
+/// The definition of the module. It is used to define some parameters
+/// of the module and what it exports to the JavaScript world.
+/// See `ModuleDefinitionBuilder` for more details on how to create it.
 public final class ModuleDefinition: ObjectDefinition {
   /**
    The module's type associated with the definition. It's used to create the module instance.
@@ -29,14 +27,16 @@ public final class ModuleDefinition: ObjectDefinition {
    Initializer that is called by the `ModuleDefinitionBuilder` results builder.
    */
   override init(definitions: [AnyDefinition]) {
-    self.name = definitions
+    self.name =
+      definitions
       .compactMap { $0 as? ModuleNameDefinition }
       .last?
       .name ?? ""
 
     self.eventListeners = definitions.compactMap { $0 as? EventListener }
 
-    self.view = definitions
+    self.view =
+      definitions
       .compactMap { $0 as? AnyViewDefinition }
       .last
 
@@ -46,7 +46,8 @@ public final class ModuleDefinition: ObjectDefinition {
         .joined()
     )
 
-    self.eventObservers = definitions
+    self.eventObservers =
+      definitions
       .compactMap { $0 as? AnyEventObservingDefinition }
 
     super.init(definitions: definitions)
@@ -73,7 +74,8 @@ public final class ModuleDefinition: ObjectDefinition {
     try super.decorate(object: object, appContext: appContext)
 
     if let viewDefinition = view {
-      let reactComponentPrototype = try viewDefinition.createReactComponentPrototype(appContext: appContext)
+      let reactComponentPrototype = try viewDefinition.createReactComponentPrototype(
+        appContext: appContext)
       object.setProperty("ViewPrototype", value: reactComponentPrototype)
     }
 
@@ -89,23 +91,17 @@ public final class ModuleDefinition: ObjectDefinition {
   }
 }
 
-/**
- Module's name definition. Returned by `name()` in module's definition.
- */
+/// Module's name definition. Returned by `name()` in module's definition.
 internal struct ModuleNameDefinition: AnyDefinition {
   let name: String
 }
 
-/**
- A definition for module's constants. Returned by `constants(() -> SomeType)` in module's definition.
- */
+/// A definition for module's constants. Returned by `constants(() -> SomeType)` in module's definition.
 internal struct ConstantsDefinition: AnyDefinition {
   let body: () -> [String: Any?]
 }
 
-/**
- A definition for module's events that can be sent to JavaScript.
- */
+/// A definition for module's events that can be sent to JavaScript.
 public struct EventsDefinition: AnyDefinition {
   let names: [String]
 }
diff --git a/ios/Core/Modules/ModuleDefinitionBuilder.swift b/ios/Core/Modules/ModuleDefinitionBuilder.swift
index e08562945cbd25944661a917a1523e8fa855cbaa..4fb42bbe8232945ad2fac3c7b140fe5b9b216ab6 100644
--- a/ios/Core/Modules/ModuleDefinitionBuilder.swift
+++ b/ios/Core/Modules/ModuleDefinitionBuilder.swift
@@ -1,7 +1,5 @@
-/**
- A function builder that provides DSL-like syntax. Thanks to this, the function doesn't need to explicitly return an array,
- but can just return multiple definitions one after another. This works similarly to SwiftUI's `body` block.
- */
+/// A function builder that provides DSL-like syntax. Thanks to this, the function doesn't need to explicitly return an array,
+/// but can just return multiple definitions one after another. This works similarly to SwiftUI's `body` block.
 @resultBuilder
 public struct ModuleDefinitionBuilder {
   public static func buildBlock(_ definitions: AnyDefinition...) -> ModuleDefinition {
diff --git a/ios/Core/ModulesProvider.swift b/ios/Core/ModulesProvider.swift
index fa3e48a41557e2d3d25f359f19595c8409648d00..2b37722dfa85f03e764b3bfe2d2251d51f498414 100644
--- a/ios/Core/ModulesProvider.swift
+++ b/ios/Core/ModulesProvider.swift
@@ -1,8 +1,6 @@
 import Foundation
 
-/**
- Swift protocol defining the requirements for modules providers.
- */
+/// Swift protocol defining the requirements for modules providers.
 public protocol ModulesProviderProtocol {
   func getModuleClasses() -> [AnyModule.Type]
 
@@ -11,7 +9,9 @@ public protocol ModulesProviderProtocol {
    */
   func getAppDelegateSubscribers() -> [ExpoAppDelegateSubscriber.Type]
 
-  typealias ExpoReactDelegateHandlerTupleType = (packageName: String, handler: ExpoReactDelegateHandler.Type)
+  typealias ExpoReactDelegateHandlerTupleType = (
+    packageName: String, handler: ExpoReactDelegateHandler.Type
+  )
   /**
    Returns an array of `ExpoReactDelegateHandlerTupleType` for `ReactDelegate` to hook React instance creation.
    */
@@ -20,10 +20,8 @@ public protocol ModulesProviderProtocol {
   func getAppCodeSignEntitlements() -> AppCodeSignEntitlements
 }
 
-/**
- The default implementation for modules provider.
- The proper implementation is generated by autolinking as part of `pod install` command.
- */
+/// The default implementation for modules provider.
+/// The proper implementation is generated by autolinking as part of `pod install` command.
 @objc
 open class ModulesProvider: NSObject, ModulesProviderProtocol {
   public override required init() {}
diff --git a/ios/Core/Objects/JavaScriptObjectBuilder.swift b/ios/Core/Objects/JavaScriptObjectBuilder.swift
index 0e5d53c650a02aed089d32687d4447b6cb0f9295..67c8e6272676c965cda8cdd3e7431b63df03d2c7 100644
--- a/ios/Core/Objects/JavaScriptObjectBuilder.swift
+++ b/ios/Core/Objects/JavaScriptObjectBuilder.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- A type that can decorate a `JavaScriptObject` with some properties.
- */
+/// A type that can decorate a `JavaScriptObject` with some properties.
 internal protocol JavaScriptObjectDecorator {
   /**
    Decorates an existing `JavaScriptObject`.
@@ -10,9 +8,7 @@ internal protocol JavaScriptObjectDecorator {
   func decorate(object: JavaScriptObject, appContext: AppContext) throws
 }
 
-/**
- A type that can build and decorate a `JavaScriptObject` based on its attributes.
- */
+/// A type that can build and decorate a `JavaScriptObject` based on its attributes.
 internal protocol JavaScriptObjectBuilder: JavaScriptObjectDecorator {
   /**
    Creates a decorated `JavaScriptObject` in the given app context.
@@ -20,10 +16,8 @@ internal protocol JavaScriptObjectBuilder: JavaScriptObjectDecorator {
   func build(appContext: AppContext) throws -> JavaScriptObject
 }
 
-/**
- Provides the default behavior of `JavaScriptObjectBuilder`.
- The `build(appContext:)` creates a plain object and uses `decorate(object:appContext:)` for decoration.
- */
+/// Provides the default behavior of `JavaScriptObjectBuilder`.
+/// The `build(appContext:)` creates a plain object and uses `decorate(object:appContext:)` for decoration.
 extension JavaScriptObjectBuilder {
   func build(appContext: AppContext) throws -> JavaScriptObject {
     let object = try appContext.runtime.createObject()
diff --git a/ios/Core/Objects/ObjectDefinition.swift b/ios/Core/Objects/ObjectDefinition.swift
index a66e13581935b43e62172c9eda7228e910a7bc16..2cc9ebb3985507334107a28506213fcec4f5a366 100644
--- a/ios/Core/Objects/ObjectDefinition.swift
+++ b/ios/Core/Objects/ObjectDefinition.swift
@@ -1,8 +1,6 @@
 // Copyright 2021-present 650 Industries. All rights reserved.
 
-/**
- Base class for other definitions representing an object, such as `ModuleDefinition`.
- */
+/// Base class for other definitions representing an object, such as `ModuleDefinition`.
 public class ObjectDefinition: AnyDefinition, JavaScriptObjectBuilder {
   /**
    A dictionary of functions defined by the object.
@@ -28,22 +26,26 @@ public class ObjectDefinition: AnyDefinition, JavaScriptObjectBuilder {
    Default initializer receiving children definitions from the result builder.
    */
   init(definitions: [AnyDefinition]) {
-    self.functions = definitions
+    self.functions =
+      definitions
       .compactMap { $0 as? AnyFunctionDefinition }
       .reduce(into: [String: AnyFunctionDefinition]()) { dict, function in
         dict[function.name] = function
       }
 
-    self.constants = definitions
+    self.constants =
+      definitions
       .compactMap { $0 as? ConstantsDefinition }
 
-    self.properties = definitions
+    self.properties =
+      definitions
       .compactMap { $0 as? AnyPropertyDefinition }
       .reduce(into: [String: AnyPropertyDefinition]()) { dict, property in
         dict[property.name] = property
       }
 
-    self.classes = definitions
+    self.classes =
+      definitions
       .compactMap { $0 as? ClassDefinition }
       .reduce(into: [String: ClassDefinition]()) { dict, klass in
         dict[klass.name] = klass
diff --git a/ios/Core/Objects/PropertyDefinition.swift b/ios/Core/Objects/PropertyDefinition.swift
index 048570105a3752eb5ab1b5c7e7aba7d16504d82d..07a9a56786b5285ff3890ddbdcba5348048990e9 100644
--- a/ios/Core/Objects/PropertyDefinition.swift
+++ b/ios/Core/Objects/PropertyDefinition.swift
@@ -109,7 +109,9 @@ public final class PropertyDefinition<OwnerType>: AnyDefinition, AnyPropertyDefi
    The owner is an object on which the function is called, like `this` in JavaScript.
    */
   @discardableResult
-  public func set<ValueType>(_ setter: @escaping (_ this: OwnerType, _ newValue: ValueType) -> Void) -> Self {
+  public func set<ValueType>(_ setter: @escaping (_ this: OwnerType, _ newValue: ValueType) -> Void)
+    -> Self
+  {
     self.setter = SyncFunctionDefinition(
       "set",
       firstArgType: OwnerType.self,
@@ -123,7 +125,9 @@ public final class PropertyDefinition<OwnerType>: AnyDefinition, AnyPropertyDefi
 
   // MARK: - Internals
 
-  internal func getValue<ValueType>(owner: OwnerType? = nil, appContext: AppContext) throws -> ValueType? {
+  internal func getValue<ValueType>(owner: OwnerType? = nil, appContext: AppContext) throws
+    -> ValueType?
+  {
     let owner = owner as? AnyObject
     let value = try getter?.call(by: owner, withArguments: [], appContext: appContext)
     return value as? ValueType
@@ -138,7 +142,8 @@ public final class PropertyDefinition<OwnerType>: AnyDefinition, AnyPropertyDefi
    Creates the JavaScript function that will be used as a getter of the property.
    */
   internal func buildGetter(appContext: AppContext) throws -> JavaScriptObject {
-    return try appContext.runtime.createSyncFunction(name, argsCount: 0) { [weak appContext, weak self, name] this, arguments in
+    return try appContext.runtime.createSyncFunction(name, argsCount: 0) {
+      [weak appContext, weak self, name] this, arguments in
       guard let appContext else {
         throw Exceptions.AppContextLost()
       }
@@ -156,7 +161,8 @@ public final class PropertyDefinition<OwnerType>: AnyDefinition, AnyPropertyDefi
    Creates the JavaScript function that will be used as a setter of the property.
    */
   internal func buildSetter(appContext: AppContext) throws -> JavaScriptObject {
-    return try appContext.runtime.createSyncFunction(name, argsCount: 1) { [weak appContext, weak self, name] this, arguments in
+    return try appContext.runtime.createSyncFunction(name, argsCount: 1) {
+      [weak appContext, weak self, name] this, arguments in
       guard let appContext else {
         throw Exceptions.AppContextLost()
       }
diff --git a/ios/Core/Promise.swift b/ios/Core/Promise.swift
index bf05ffea2edef0d627904dc3072fcaaec763cb4b..9c13410021223dff948863f7439bb43f17a9d18e 100644
--- a/ios/Core/Promise.swift
+++ b/ios/Core/Promise.swift
@@ -37,7 +37,9 @@ public struct Promise: AnyArgument {
     rejecter(Exception(name: code, description: description, code: code))
   }
 
-  public func settle<ValueType, ExceptionType: Exception>(with result: Result<ValueType, ExceptionType>) {
+  public func settle<ValueType, ExceptionType: Exception>(
+    with result: Result<ValueType, ExceptionType>
+  ) {
     switch result {
     case .success(let value):
       resolve(value)
diff --git a/ios/Core/Protocols/AnyDefinition.swift b/ios/Core/Protocols/AnyDefinition.swift
index fedbfa0c67db1d4fd3e47737d41d37b0352e5f69..544157c8ebe1ad853752b09326713191c07cecc3 100644
--- a/ios/Core/Protocols/AnyDefinition.swift
+++ b/ios/Core/Protocols/AnyDefinition.swift
@@ -1,4 +1,2 @@
-/**
- A protocol that must be implemented to be a part of module's definition and the module definition itself.
- */
+/// A protocol that must be implemented to be a part of module's definition and the module definition itself.
 public protocol AnyDefinition {}
diff --git a/ios/Core/Protocols/AnyModule.swift b/ios/Core/Protocols/AnyModule.swift
index c096986badd90be8bcdd1760f5d10bb2098c862b..07c4b4827a542c22867001c29b875eec1aca8867 100644
--- a/ios/Core/Protocols/AnyModule.swift
+++ b/ios/Core/Protocols/AnyModule.swift
@@ -1,6 +1,4 @@
-/**
- A protocol for any type-erased module that provides functions used by the core.
- */
+/// A protocol for any type-erased module that provides functions used by the core.
 public protocol AnyModule: AnyObject, AnyArgument {
   /**
    The default initializer. Must be public, but the module class does *not* need to
diff --git a/ios/Core/Protocols/AnyViewDefinition.swift b/ios/Core/Protocols/AnyViewDefinition.swift
index b15473020bf633456275c22f40b0703179018a59..de8e54c69851e365abce5fcad0f6b2c624342438 100644
--- a/ios/Core/Protocols/AnyViewDefinition.swift
+++ b/ios/Core/Protocols/AnyViewDefinition.swift
@@ -1,6 +1,4 @@
-/**
- A protocol for any type-erased view definition.
- */
+/// A protocol for any type-erased view definition.
 public protocol AnyViewDefinition {
   /**
    An array of view props supported by the view.
diff --git a/ios/Core/Records/AnyField.swift b/ios/Core/Records/AnyField.swift
index 99e32731abf42b41e351619a31ce8b041ad94676..428e6053de3fb2f8fdd1c80397851cb9468e93ba 100644
--- a/ios/Core/Records/AnyField.swift
+++ b/ios/Core/Records/AnyField.swift
@@ -1,13 +1,9 @@
-/**
- Protocol for type-erased record fields.
- */
+/// Protocol for type-erased record fields.
 public protocol AnyField {
   func get() -> Any
 }
 
-/**
- Internal-only additions to `AnyField` protocol.
- */
+/// Internal-only additions to `AnyField` protocol.
 internal protocol AnyFieldInternal: AnyField {
   var key: String? { get }
   var options: Set<FieldOption> { get set }
diff --git a/ios/Core/Records/Field.swift b/ios/Core/Records/Field.swift
index 7253301c23ea81e88e740a52f3768417bdd157c2..0a6a117b2ae95cd776788310497dcda7dc40e224 100644
--- a/ios/Core/Records/Field.swift
+++ b/ios/Core/Records/Field.swift
@@ -1,7 +1,5 @@
-/**
- Property wrapper for `Record`'s data members that takes part in the process of serialization to and deserialization from the dictionary.
- For supported field types, see https://docs.expo.dev/modules/module-api/#argument-types
- */
+/// Property wrapper for `Record`'s data members that takes part in the process of serialization to and deserialization from the dictionary.
+/// For supported field types, see https://docs.expo.dev/modules/module-api/#argument-types
 @propertyWrapper
 public final class Field<Type: AnyArgument>: AnyFieldInternal {
   /**
@@ -60,7 +58,8 @@ public final class Field<Type: AnyArgument>: AnyFieldInternal {
     self.wrappedValue = wrappedValue
   }
 
-  public init(wrappedValue: Type = nil, _ options: FieldOption...) where Type: ExpressibleByNilLiteral {
+  public init(wrappedValue: Type = nil, _ options: FieldOption...)
+  where Type: ExpressibleByNilLiteral {
     self.wrappedValue = wrappedValue
     self.options = Set(options)
   }
@@ -84,7 +83,8 @@ public final class Field<Type: AnyArgument>: AnyFieldInternal {
         wrappedValue = value
       }
     } catch {
-      throw FieldInvalidTypeException((fieldKey: key!, value: newValue, desiredType: Type.self)).causedBy(error)
+      throw FieldInvalidTypeException((fieldKey: key!, value: newValue, desiredType: Type.self))
+        .causedBy(error)
     }
   }
 }
@@ -95,7 +95,10 @@ internal class FieldRequiredException: GenericException<String> {
   }
 }
 
-internal class FieldInvalidTypeException: GenericException<(fieldKey: String, value: Any?, desiredType: Any.Type)> {
+internal class FieldInvalidTypeException: GenericException<
+  (fieldKey: String, value: Any?, desiredType: Any.Type)
+>
+{
   override var reason: String {
     let value = String(describing: param.value ?? "null")
     let desiredType = String(describing: param.desiredType)
diff --git a/ios/Core/Records/FieldExtensions.swift b/ios/Core/Records/FieldExtensions.swift
index 7ec7c49b2bde53cd62e45f4ba2309736690874e6..f98e90995c2e530910d58d59af4e8bf6567863ce 100644
--- a/ios/Core/Records/FieldExtensions.swift
+++ b/ios/Core/Records/FieldExtensions.swift
@@ -1,90 +1,76 @@
-/**
- Allows declaring non-optional `Int` field without assigning an initial value.
- */
-public extension Field where Type == Int {
-  convenience init(wrappedValue: Type = 0) {
+/// Allows declaring non-optional `Int` field without assigning an initial value.
+extension Field where Type == Int {
+  public convenience init(wrappedValue: Type = 0) {
     self.init(wrappedValue: wrappedValue, [])
   }
 
-  convenience init(wrappedValue: Type = 0, _ options: FieldOption...) {
+  public convenience init(wrappedValue: Type = 0, _ options: FieldOption...) {
     self.init(wrappedValue: wrappedValue, options)
   }
 }
 
-/**
- Allows declaring non-optional `Double` field without assigning an initial value.
- */
-public extension Field where Type == Double {
-  convenience init(wrappedValue: Type = 0.0) {
+/// Allows declaring non-optional `Double` field without assigning an initial value.
+extension Field where Type == Double {
+  public convenience init(wrappedValue: Type = 0.0) {
     self.init(wrappedValue: wrappedValue, [])
   }
 
-  convenience init(wrappedValue: Type = 0.0, _ options: FieldOption...) {
+  public convenience init(wrappedValue: Type = 0.0, _ options: FieldOption...) {
     self.init(wrappedValue: wrappedValue, options)
   }
 }
 
-/**
- Allows declaring non-optional `Bool` field without assigning an initial value.
- */
-public extension Field where Type == Bool {
-  convenience init(wrappedValue: Type = false) {
+/// Allows declaring non-optional `Bool` field without assigning an initial value.
+extension Field where Type == Bool {
+  public convenience init(wrappedValue: Type = false) {
     self.init(wrappedValue: wrappedValue, [])
   }
 
-  convenience init(wrappedValue: Type = false, _ options: FieldOption...) {
+  public convenience init(wrappedValue: Type = false, _ options: FieldOption...) {
     self.init(wrappedValue: wrappedValue, options)
   }
 }
 
-/**
- Allows declaring non-optional `String` field without assigning an initial value.
- */
-public extension Field where Type == String {
-  convenience init(wrappedValue: Type = "") {
+/// Allows declaring non-optional `String` field without assigning an initial value.
+extension Field where Type == String {
+  public convenience init(wrappedValue: Type = "") {
     self.init(wrappedValue: wrappedValue, [])
   }
 
-  convenience init(wrappedValue: Type = "", _ options: FieldOption...) {
+  public convenience init(wrappedValue: Type = "", _ options: FieldOption...) {
     self.init(wrappedValue: wrappedValue, options)
   }
 }
 
-/**
- Allows declaring non-optional array field without assigning an initial value.
- */
-public extension Field where Type: ExpressibleByArrayLiteral {
-  convenience init(wrappedValue: Type = []) {
+/// Allows declaring non-optional array field without assigning an initial value.
+extension Field where Type: ExpressibleByArrayLiteral {
+  public convenience init(wrappedValue: Type = []) {
     self.init(wrappedValue: wrappedValue, [])
   }
 
-  convenience init(wrappedValue: Type = [], _ options: FieldOption...) {
+  public convenience init(wrappedValue: Type = [], _ options: FieldOption...) {
     self.init(wrappedValue: wrappedValue, options)
   }
 }
 
-/**
- Allows declaring non-optional dictionary field without assigning an initial value.
- */
-public extension Field where Type: ExpressibleByDictionaryLiteral {
-  convenience init(wrappedValue: Type = [:]) {
+/// Allows declaring non-optional dictionary field without assigning an initial value.
+extension Field where Type: ExpressibleByDictionaryLiteral {
+  public convenience init(wrappedValue: Type = [:]) {
     self.init(wrappedValue: wrappedValue, [])
   }
 
-  convenience init(wrappedValue: Type = [:], _ options: FieldOption...) {
+  public convenience init(wrappedValue: Type = [:], _ options: FieldOption...) {
     self.init(wrappedValue: wrappedValue, options)
   }
 }
 
-/**
- Allows declaring non-optional record field without assigning an initial value.
- */
-public extension Field where Type: Record {
-  convenience init(wrappedValue: Type = Type.init()) {
+/// Allows declaring non-optional record field without assigning an initial value.
+extension Field where Type: Record {
+  public convenience init(wrappedValue: Type = Type.init()) {
     self.init(wrappedValue: wrappedValue, [])
   }
 
-  convenience init(wrappedValue: Type = Type.init(), _ options: FieldOption...) {
+  public convenience init(wrappedValue: Type = Type.init(), _ options: FieldOption...) {
     self.init(wrappedValue: wrappedValue, options)
   }
 }
diff --git a/ios/Core/Records/FieldOption.swift b/ios/Core/Records/FieldOption.swift
index 3b96da5d49df26a2380c5efaed30c28bbdd37180..6577a69a11fca6a04a036dca64c6410c41fdd631 100644
--- a/ios/Core/Records/FieldOption.swift
+++ b/ios/Core/Records/FieldOption.swift
@@ -1,8 +1,8 @@
-/**
- Enum-like struct representing field options that for example can specify if the field
- is required and so it must be provided by the dictionary from which the field is created.
- */
-public struct FieldOption: Equatable, Hashable, ExpressibleByIntegerLiteral, ExpressibleByStringLiteral {
+/// Enum-like struct representing field options that for example can specify if the field
+/// is required and so it must be provided by the dictionary from which the field is created.
+public struct FieldOption: Equatable, Hashable, ExpressibleByIntegerLiteral,
+  ExpressibleByStringLiteral
+{
   public let rawValue: Int
   public var key: String?
 
@@ -48,15 +48,15 @@ public struct FieldOption: Equatable, Hashable, ExpressibleByIntegerLiteral, Exp
   }
 }
 
-public extension FieldOption {
+extension FieldOption {
   /**
    Field option setting its key to given string. Raw value equals to `0`.
    This option can also be initialized with string literal.
    */
-  static func keyed(_ key: String) -> FieldOption { FieldOption(stringLiteral: key) }
+  public static func keyed(_ key: String) -> FieldOption { FieldOption(stringLiteral: key) }
 
   /**
    The field must be explicitly provided by the dictionary. Raw value equals to `1`.
    */
-  static let required: FieldOption = 1
+  public static let required: FieldOption = 1
 }
diff --git a/ios/Core/Records/Record.swift b/ios/Core/Records/Record.swift
index 6a5dd17778c8c02f931108b4b3f3223d3cd8e973..668c3a85b235f3e8536fbf744d28a1dfd032e0a4 100644
--- a/ios/Core/Records/Record.swift
+++ b/ios/Core/Records/Record.swift
@@ -1,7 +1,5 @@
-/**
- A protocol that allows initializing the object with a dictionary.
- For supported field types, see https://docs.expo.dev/modules/module-api/#argument-types
- */
+/// A protocol that allows initializing the object with a dictionary.
+/// For supported field types, see https://docs.expo.dev/modules/module-api/#argument-types
 public protocol Record: Convertible {
   /**
    The dictionary type that the record can be created from or converted back.
@@ -24,11 +22,9 @@ public protocol Record: Convertible {
   func toDictionary(appContext: AppContext?) -> Dict
 }
 
-/**
- Provides the default implementation of `Record` protocol.
- */
-public extension Record {
-  static func convert(from value: Any?, appContext: AppContext) throws -> Self {
+/// Provides the default implementation of `Record` protocol.
+extension Record {
+  public static func convert(from value: Any?, appContext: AppContext) throws -> Self {
     if let value = value as? Dict {
       return try Self(from: value, appContext: appContext)
     }
@@ -40,12 +36,12 @@ public extension Record {
     throw Conversions.ConvertingException<Self>(value)
   }
 
-  init(from dict: Dict, appContext: AppContext) throws {
+  public init(from dict: Dict, appContext: AppContext) throws {
     self.init()
     try update(withDict: dict, appContext: appContext)
   }
 
-  func update(withDict dict: Dict, appContext: AppContext) throws {
+  public func update(withDict dict: Dict, appContext: AppContext) throws {
     let dictKeys = dict.keys
 
     try fieldsOf(self).forEach { field in
@@ -59,7 +55,7 @@ public extension Record {
     }
   }
 
-  func toDictionary(appContext: AppContext? = nil) -> Dict {
+  public func toDictionary(appContext: AppContext? = nil) -> Dict {
     return fieldsOf(self).reduce(into: Dict()) { result, field in
       if let key = field.key {
         result[key] = Conversions.convertFunctionResult(field.get(), appContext: appContext)
@@ -68,13 +64,12 @@ public extension Record {
   }
 }
 
-/**
- Returns an array of fields found in record's mirror. If the field is missing the `key`,
- it gets assigned to the property label, so after all it's safe to enforce unwrapping it (using `key!`).
- */
+/// Returns an array of fields found in record's mirror. If the field is missing the `key`,
+/// it gets assigned to the property label, so after all it's safe to enforce unwrapping it (using `key!`).
 internal func fieldsOf(_ record: Record) -> [AnyFieldInternal] {
   return Mirror(reflecting: record).children.compactMap { (label: String?, value: Any) in
-    guard var field = value as? AnyFieldInternal, let key = field.key ?? convertLabelToKey(label) else {
+    guard var field = value as? AnyFieldInternal, let key = field.key ?? convertLabelToKey(label)
+    else {
       return nil
     }
     field.options.insert(.keyed(key))
@@ -82,9 +77,7 @@ internal func fieldsOf(_ record: Record) -> [AnyFieldInternal] {
   }
 }
 
-/**
- Converts mirror's label to field's key by dropping the "_" prefix from wrapped property label.
- */
+/// Converts mirror's label to field's key by dropping the "_" prefix from wrapped property label.
 private func convertLabelToKey(_ label: String?) -> String? {
   return (label != nil && label!.starts(with: "_")) ? String(label!.dropFirst()) : label
 }
diff --git a/ios/Core/SharedObjects/SharedObject.swift b/ios/Core/SharedObjects/SharedObject.swift
index 7595fe99739a90db8a36ce0167e3217bf6356bfc..5a09735816d4a8dd0c27594d250c26b01fb20528 100644
--- a/ios/Core/SharedObjects/SharedObject.swift
+++ b/ios/Core/SharedObjects/SharedObject.swift
@@ -6,7 +6,7 @@ public protocol AnySharedObject: AnyArgument, AnyObject {
 
 extension AnySharedObject {
   public static func getDynamicType() -> AnyDynamicType {
-    return DynamicSharedObjectType(innerType: Self.self)
+	return DynamicSharedObjectType(innerType: Self.self)
   }
 }
 
@@ -44,18 +44,18 @@ open class SharedObject: AnySharedObject {
    and may be used to guide decisions about when to run garbage collection.
    */
   open func getAdditionalMemoryPressure() -> Int {
-    // The memory pressure is `0` by default. We can potentially use `class_getInstanceSize`,
-    // but it only returns a size of the type which is usually relatively small
-    // as it does not include virtual allocations such as binary data and images.
-    // Thus, it makes more sense to just skip setting the pressure and make it opt-in.
-    return 0
+	// The memory pressure is `0` by default. We can potentially use `class_getInstanceSize`,
+	// but it only returns a size of the type which is usually relatively small
+	// as it does not include virtual allocations such as binary data and images.
+	// Thus, it makes more sense to just skip setting the pressure and make it opt-in.
+	return 0
   }
 
   /**
    Returns the JavaScript shared object associated with the native shared object.
    */
   public func getJavaScriptObject() -> JavaScriptObject? {
-    return appContext?.sharedObjectRegistry.toJavaScriptObject(self)
+	return appContext?.sharedObjectRegistry.toJavaScriptObject(self)
   }
 }
 
@@ -70,35 +70,35 @@ public extension SharedObject { // swiftlint:disable:this no_grouping_extension
   /**
    Schedules an event with the given name and arguments to be emitted to the associated JavaScript object.
    */
-  func emit<each A: AnyArgument>(event: String, arguments: repeat each A) {
-    guard let appContext, let runtime = try? appContext.runtime else {
-      log.warn("Trying to send event '\(event)' to \(type(of: self)), but the JS runtime has been lost")
-      return
-    }
+  public func emit<each A: AnyArgument>(event: String, arguments: repeat each A) {
+	guard let appContext, let runtime = try? appContext.runtime else {
+	  log.warn("Trying to send event '\(event)' to \(type(of: self)), but the JS runtime has been lost")
+	  return
+	}
 
-    // Collect arguments and their dynamic types from parameter pack
-    var argumentPairs: [(AnyArgument, AnyDynamicType)] = []
-    repeat argumentPairs.append((each arguments, ~(each A).self))
+	// Collect arguments and their dynamic types from parameter pack
+	var argumentPairs: [(AnyArgument, AnyDynamicType)] = []
+	repeat argumentPairs.append((each arguments, ~(each A).self))
 
-    // Schedule the event to be asynchronously emitted from the runtime's thread
-    runtime.schedule { [weak self, weak appContext] in
-      guard let appContext, let runtime = try? appContext.runtime, let jsObject = self?.getJavaScriptObject() else {
-        log.warn("Trying to send event '\(event)' to \(type(of: self)), but the JS object is no longer associated with the native instance")
-        return
-      }
+	// Schedule the event to be asynchronously emitted from the runtime's thread
+	runtime.schedule { [weak self, weak appContext] in
+	  guard let appContext, let runtime = try? appContext.runtime, let jsObject = self?.getJavaScriptObject() else {
+		log.warn("Trying to send event '\(event)' to \(type(of: self)), but the JS object is no longer associated with the native instance")
+		return
+	  }
 
-      // Convert native arguments to JS, just like function results
-      let arguments = argumentPairs.map { argument, dynamicType in
-        return Conversions.convertFunctionResult(argument, appContext: appContext, dynamicType: dynamicType)
-      }
+	  // Convert native arguments to JS, just like function results
+	  let arguments = argumentPairs.map { argument, dynamicType in
+		return Conversions.convertFunctionResult(argument, appContext: appContext, dynamicType: dynamicType)
+	  }
 
-      JSIUtils.emitEvent(event, to: jsObject, withArguments: arguments, in: runtime)
-    }
+	  JSIUtils.emitEvent(event, to: jsObject, withArguments: arguments, in: runtime)
+	}
   }
   #else // swift(>=5.9)
   @available(*, unavailable, message: "Unavailable in Xcode <15.0")
   public func emit(event: String, arguments: AnyArgument...) {
-    fatalError("Emitting events to JS requires at least Xcode 15.0")
+	fatalError("Emitting events to JS requires at least Xcode 15.0")
   }
   #endif // swift(<5.9)
 }
diff --git a/ios/Core/SharedObjects/SharedObjectRegistry.swift b/ios/Core/SharedObjects/SharedObjectRegistry.swift
index ac042469463a94e7e507259daa1ad679b7cf6e65..9b3fa00eaab50292a28b05bec8baefeac75f5d22 100644
--- a/ios/Core/SharedObjects/SharedObjectRegistry.swift
+++ b/ios/Core/SharedObjects/SharedObjectRegistry.swift
@@ -1,24 +1,16 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- Type of the IDs of shared objects.
- */
+/// Type of the IDs of shared objects.
 public typealias SharedObjectId = Int
 
-/**
- A tuple containing a pair of matching native and JS objects.
- */
+/// A tuple containing a pair of matching native and JS objects.
 internal typealias SharedObjectPair = (native: SharedObject, javaScript: JavaScriptWeakObject)
 
-/**
- Property name of the JS object where the shared object ID is stored.
- */
+/// Property name of the JS object where the shared object ID is stored.
 let sharedObjectIdPropertyName = "__expo_shared_object_id__"
 
-/**
- The registry of all shared objects used in the entire app.
- It's been made static for simplicity.
- */
+/// The registry of all shared objects used in the entire app.
+/// It's been made static for simplicity.
 public final class SharedObjectRegistry {
   /**
    Weak reference to the app context for the registry.
@@ -89,7 +81,9 @@ public final class SharedObjectRegistry {
    Adds a pair of native and JS shared object to the registry. Assigns a new shared object ID to these objects.
    */
   @discardableResult
-  internal func add(native nativeObject: SharedObject, javaScript jsObject: JavaScriptObject) -> SharedObjectId {
+  internal func add(native nativeObject: SharedObject, javaScript jsObject: JavaScriptObject)
+    -> SharedObjectId
+  {
     let id = pullNextId()
 
     // Assign the ID and the app context to the object.
@@ -107,7 +101,8 @@ public final class SharedObjectRegistry {
 
     // Set the native state and memory footprint in the JS object.
     if let runtime = try? appContext?.runtime {
-      SharedObjectUtils.setNativeState(jsObject, runtime: runtime, objectId: id, releaser: objectReleaser)
+      SharedObjectUtils.setNativeState(
+        jsObject, runtime: runtime, objectId: id, releaser: objectReleaser)
 
       let memoryPressure = nativeObject.getAdditionalMemoryPressure()
       if memoryPressure > 0 {
@@ -166,7 +161,9 @@ public final class SharedObjectRegistry {
   /**
    Creates a plain JS object and pairs it with a given native object.
    */
-  internal func createSharedJavaScriptObject(runtime: JavaScriptRuntime, nativeObject: SharedObject) -> JavaScriptObject {
+  internal func createSharedJavaScriptObject(runtime: JavaScriptRuntime, nativeObject: SharedObject)
+    -> JavaScriptObject
+  {
     let object = runtime.createObject()
     add(native: nativeObject, javaScript: object)
     return object
@@ -175,7 +172,9 @@ public final class SharedObjectRegistry {
   /**
    Ensures that there is a JS object paired with a given native object. If not, a plain JS object is created.
    */
-  internal func ensureSharedJavaScriptObject(runtime: JavaScriptRuntime, nativeObject: SharedObject) -> JavaScriptObject {
+  internal func ensureSharedJavaScriptObject(runtime: JavaScriptRuntime, nativeObject: SharedObject)
+    -> JavaScriptObject
+  {
     if let jsObject = toJavaScriptObject(nativeObject) {
       // JS object for this native object already exists in the registry, just return it.
       return jsObject
diff --git a/ios/Core/SharedObjects/SharedRef.swift b/ios/Core/SharedObjects/SharedRef.swift
index 99dca742f781a1ccefa444c1afd930d0e4024321..0803e96eba612d7be2a9ed6054032d3becc4ffe4 100644
--- a/ios/Core/SharedObjects/SharedRef.swift
+++ b/ios/Core/SharedObjects/SharedRef.swift
@@ -5,10 +5,8 @@ public protocol AnySharedRef {
   var nativeRefType: String { get }
 }
 
-/**
- Shared object that holds a reference to any native object. Allows passing references
- to native instances among different independent libraries.
- */
+/// Shared object that holds a reference to any native object. Allows passing references
+/// to native instances among different independent libraries.
 open class SharedRef<RefType>: SharedObject, AnySharedRef {
   public var ref: RefType
 
diff --git a/ios/Core/TypedArrays/AnyTypedArray.swift b/ios/Core/TypedArrays/AnyTypedArray.swift
index 23e51384bf5f1fc38c3239ad880279ad582881cc..459cee666e8b7bf37ab8aed97c3119795783e9d4 100644
--- a/ios/Core/TypedArrays/AnyTypedArray.swift
+++ b/ios/Core/TypedArrays/AnyTypedArray.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- A protocol for all typed arrays.
- */
+/// A protocol for all typed arrays.
 internal protocol AnyTypedArray: AnyArgument {
   /**
    Initializes a typed array from the given JavaScript representation.
diff --git a/ios/Core/TypedArrays/ConcreteTypedArrays.swift b/ios/Core/TypedArrays/ConcreteTypedArrays.swift
index 90e1ea1559e9f588f91624b5ac2fba17a9448231..de59102c6ed0f1258c6e81bfe35532fd313c61e2 100644
--- a/ios/Core/TypedArrays/ConcreteTypedArrays.swift
+++ b/ios/Core/TypedArrays/ConcreteTypedArrays.swift
@@ -1,56 +1,34 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- Native equivalent of `Int8Array` in JavaScript, an array of two's-complement 8-bit signed integers.
- */
+/// Native equivalent of `Int8Array` in JavaScript, an array of two's-complement 8-bit signed integers.
 public final class Int8Array: GenericTypedArray<Int8> {}
 
-/**
- Native equivalent of `Int16Array` in JavaScript, an array of two's-complement 16-bit signed integers.
- */
+/// Native equivalent of `Int16Array` in JavaScript, an array of two's-complement 16-bit signed integers.
 public final class Int16Array: GenericTypedArray<Int16> {}
 
-/**
- Native equivalent of `Int32Array` in JavaScript, an array of two's-complement 32-bit signed integers.
- */
+/// Native equivalent of `Int32Array` in JavaScript, an array of two's-complement 32-bit signed integers.
 public final class Int32Array: GenericTypedArray<Int32> {}
 
-/**
- Native equivalent of `Uint8Array` in JavaScript, an array of 8-bit unsigned integers.
- */
+/// Native equivalent of `Uint8Array` in JavaScript, an array of 8-bit unsigned integers.
 public final class Uint8Array: GenericTypedArray<UInt8> {}
 
-/**
- Native equivalent of `Uint8ClampedArray` in JavaScript, an array of 8-bit unsigned integers clamped to 0-255.
- */
+/// Native equivalent of `Uint8ClampedArray` in JavaScript, an array of 8-bit unsigned integers clamped to 0-255.
 public final class Uint8ClampedArray: GenericTypedArray<UInt8> {}
 
-/**
- Native equivalent of `Uint16Array` in JavaScript, an array of 16-bit unsigned integers.
- */
+/// Native equivalent of `Uint16Array` in JavaScript, an array of 16-bit unsigned integers.
 public final class Uint16Array: GenericTypedArray<UInt16> {}
 
-/**
- Native equivalent of `Uint32Array` in JavaScript, an array of 32-bit unsigned integers.
- */
+/// Native equivalent of `Uint32Array` in JavaScript, an array of 32-bit unsigned integers.
 public final class Uint32Array: GenericTypedArray<UInt32> {}
 
-/**
- Native equivalent of `Float32Array` in JavaScript, an array of 32-bit floating point numbers.
- */
+/// Native equivalent of `Float32Array` in JavaScript, an array of 32-bit floating point numbers.
 public final class Float32Array: GenericTypedArray<Float32> {}
 
-/**
- Native equivalent of `Float64Array` in JavaScript, an array of 64-bit floating point numbers.
- */
+/// Native equivalent of `Float64Array` in JavaScript, an array of 64-bit floating point numbers.
 public final class Float64Array: GenericTypedArray<Float64> {}
 
-/**
- Native equivalent of `BigInt64Array` in JavaScript, an array of 64-bit signed integers.
- */
+/// Native equivalent of `BigInt64Array` in JavaScript, an array of 64-bit signed integers.
 public final class BigInt64Array: GenericTypedArray<Int64> {}
 
-/**
- Native equivalent of `BigUint64Array` in JavaScript, an array of 64-bit unsigned integers.
- */
+/// Native equivalent of `BigUint64Array` in JavaScript, an array of 64-bit unsigned integers.
 public final class BigUint64Array: GenericTypedArray<UInt64> {}
diff --git a/ios/Core/TypedArrays/GenericTypedArray.swift b/ios/Core/TypedArrays/GenericTypedArray.swift
index 000fc0f5d9038051835624ebc9f1bd6a77d9462c..0f57bd8a14942db98048022ba51c505d866c02f1 100644
--- a/ios/Core/TypedArrays/GenericTypedArray.swift
+++ b/ios/Core/TypedArrays/GenericTypedArray.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- Generic TypedArray with an associated numeric ContentType (e.g. UInt8, Int16, Double).
- */
+/// Generic TypedArray with an associated numeric ContentType (e.g. UInt8, Int16, Double).
 public class GenericTypedArray<ContentType: Numeric>: TypedArray {
   /**
    The unsafe mutable typed buffer that shares the same memory as the underlying JavaScript `ArrayBuffer`.
diff --git a/ios/Core/TypedArrays/TypedArray.swift b/ios/Core/TypedArrays/TypedArray.swift
index e6a7cd1ecee3038c3d56d068b637a5cde994e2a4..b9ff8b4e2985889b0f3e01fea527b9438b100e18 100644
--- a/ios/Core/TypedArrays/TypedArray.swift
+++ b/ios/Core/TypedArrays/TypedArray.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- The base class for any type of the typed array.
- */
+/// The base class for any type of the typed array.
 public class TypedArray: AnyTypedArray {
   /**
    Creates a concrete TypedArray from the given JavaScriptTypedArray
diff --git a/ios/Core/Views/AnyViewProp.swift b/ios/Core/Views/AnyViewProp.swift
index fb66ae37304c4cc5d50eeefd782c78ec1c2c9e71..a648646d3d060c0f4c2be99224ad67e00823a06b 100644
--- a/ios/Core/Views/AnyViewProp.swift
+++ b/ios/Core/Views/AnyViewProp.swift
@@ -1,6 +1,4 @@
-/**
- Type-erased protocol for view props classes.
- */
+/// Type-erased protocol for view props classes.
 public protocol AnyViewProp: AnyViewDefinitionElement {
   /**
    Name of the view prop that JavaScript refers to.
diff --git a/ios/Core/Views/ComponentData.swift b/ios/Core/Views/ComponentData.swift
index 95332daa7f266dec2e7591c3007c627f3b722cea..5862ffb055fc2a1a36e8f32afdc98fc3eaa38968 100644
--- a/ios/Core/Views/ComponentData.swift
+++ b/ios/Core/Views/ComponentData.swift
@@ -2,10 +2,8 @@
 
 import React
 
-/**
- Custom component data extending `RCTComponentData`. Its main purpose is to handle event-based props (callbacks),
- but it also simplifies capturing the view config so we can omit some reflections that React Native executes.
- */
+/// Custom component data extending `RCTComponentData`. Its main purpose is to handle event-based props (callbacks),
+/// but it also simplifies capturing the view config so we can omit some reflections that React Native executes.
 @objc(EXComponentData)
 public final class ComponentData: RCTComponentDataSwiftAdapter {
   /**
@@ -17,9 +15,12 @@ public final class ComponentData: RCTComponentDataSwiftAdapter {
    Initializer that additionally takes the original view module to have access to its definition.
    */
   @objc
-  public init(viewModule: ViewModuleWrapper, managerClass: ViewModuleWrapper.Type, bridge: RCTBridge) {
+  public init(
+    viewModule: ViewModuleWrapper, managerClass: ViewModuleWrapper.Type, bridge: RCTBridge
+  ) {
     self.moduleHolder = viewModule.wrappedModuleHolder
-    super.init(managerClass: managerClass, bridge: bridge, eventDispatcher: bridge.eventDispatcher())
+    super.init(
+      managerClass: managerClass, bridge: bridge, eventDispatcher: bridge.eventDispatcher())
   }
 
   // MARK: RCTComponentData
@@ -28,7 +29,8 @@ public final class ComponentData: RCTComponentDataSwiftAdapter {
    Creates a setter for the specific prop. For non-event props we just let React Native do its job.
    Events are handled differently to conveniently use them in Swift.
    */
-  public override func createPropBlock(_ propName: String, isShadowView: Bool) -> RCTPropBlockAlias {
+  public override func createPropBlock(_ propName: String, isShadowView: Bool) -> RCTPropBlockAlias
+  {
     // Expo Modules Core doesn't support shadow views yet, so fall back to the default implementation.
     if isShadowView {
       return super.createPropBlock(propName, isShadowView: isShadowView)
@@ -113,19 +115,19 @@ public final class ComponentData: RCTComponentDataSwiftAdapter {
       "propTypes": propTypes,
       "directEvents": directEvents,
       "bubblingEvents": [String](),
-      "baseModuleName": superClass?.moduleName() as Any
+      "baseModuleName": superClass?.moduleName() as Any,
     ]
   }
 }
 
-/**
- Creates a setter for the event prop. Used only by Paper.
- */
+/// Creates a setter for the event prop. Used only by Paper.
 private func createEventSetter(eventName: String, bridge: RCTBridge?) -> RCTPropBlockAlias {
   return { [weak bridge] (target: RCTComponent, value: Any) in
-    installEventDispatcher(forEvent: eventName, onView: target) { [weak target] (body: [String: Any]) in
+    installEventDispatcher(forEvent: eventName, onView: target) {
+      [weak target] (body: [String: Any]) in
       if let target = target {
-        let componentEvent = RCTComponentEvent(name: eventName, viewTag: target.reactTag, body: body)
+        let componentEvent = RCTComponentEvent(
+          name: eventName, viewTag: target.reactTag, body: body)
         bridge?.eventDispatcher()?.send(componentEvent)
       }
     }
diff --git a/ios/Core/Views/ConcreteViewProp.swift b/ios/Core/Views/ConcreteViewProp.swift
index 58896e307b3b17735acd6dab9a569c896decbf25..38061c9a42b092044d2ff3fc1af5dec84b1e6960 100644
--- a/ios/Core/Views/ConcreteViewProp.swift
+++ b/ios/Core/Views/ConcreteViewProp.swift
@@ -1,8 +1,6 @@
 // Copyright 2021-present 650 Industries. All rights reserved.
 
-/**
- Specialized class for the view prop. Specifies the prop name and its setter.
- */
+/// Specialized class for the view prop. Specifies the prop name and its setter.
 public final class ConcreteViewProp<ViewType: UIView, PropType: AnyArgument>: AnyViewProp {
   public typealias SetterType = (ViewType, PropType) -> Void
 
@@ -43,10 +41,11 @@ public final class ConcreteViewProp<ViewType: UIView, PropType: AnyArgument>: An
   }
 }
 
-/**
- An exception that is thrown when the view passed to prop's setter doesn't match the type in setter's definition.
- */
-internal class IncompatibleViewException: GenericException<(propName: String, viewType: UIView.Type)> {
+/// An exception that is thrown when the view passed to prop's setter doesn't match the type in setter's definition.
+internal class IncompatibleViewException: GenericException<
+  (propName: String, viewType: UIView.Type)
+>
+{
   override var reason: String {
     "Tried to set prop '\(param.propName)' on the view that isn't \(param.viewType)"
   }
diff --git a/ios/Core/Views/ExpoView.swift b/ios/Core/Views/ExpoView.swift
index dda145104b6e6058db0379ce779865159b04d8bc..cf06371fe1e990127beb89500922f71403e4218f 100644
--- a/ios/Core/Views/ExpoView.swift
+++ b/ios/Core/Views/ExpoView.swift
@@ -3,42 +3,40 @@
 import React
 
 #if RCT_NEW_ARCH_ENABLED
-public typealias ExpoView = ExpoFabricView
+  public typealias ExpoView = ExpoFabricView
 #else
-/**
- The view that extends `RCTView` which handles some styles (e.g. borders) and accessibility.
- Inherit from `ExpoView` to keep this behavior and let your view use the associated `AppContext`.
- */
-open class ExpoClassicView: RCTView, AnyExpoView {
-  /**
-   A weak pointer to the associated `AppContext`.
-   */
-  public private(set) weak var appContext: AppContext?
+  /// The view that extends `RCTView` which handles some styles (e.g. borders) and accessibility.
+  /// Inherit from `ExpoView` to keep this behavior and let your view use the associated `AppContext`.
+  open class ExpoClassicView: RCTView, AnyExpoView {
+    /**
+     A weak pointer to the associated `AppContext`.
+     */
+    public private(set) weak var appContext: AppContext?
 
-  /**
-   The required initializer that receives an instance of `AppContext`.
-   Override it if the subclassing view needs to do something during initialization.
-   */
-  required public init(appContext: AppContext? = nil) {
-    self.appContext = appContext
-    super.init(frame: .zero)
-  }
+    /**
+     The required initializer that receives an instance of `AppContext`.
+     Override it if the subclassing view needs to do something during initialization.
+     */
+    required public init(appContext: AppContext? = nil) {
+      self.appContext = appContext
+      super.init(frame: .zero)
+    }
 
-  // Mark the required init as unavailable so that subclasses can avoid overriding it.
-  @available(*, unavailable)
-  required public init?(coder: NSCoder) {
-    fatalError("init(coder:) has not been implemented")
-  }
+    // Mark the required init as unavailable so that subclasses can avoid overriding it.
+    @available(*, unavailable)
+    required public init?(coder: NSCoder) {
+      fatalError("init(coder:) has not been implemented")
+    }
 
-  public func updateProps(_ rawProps: [String: Any]) {
-    // Stub function – it's not used on the old architecture and non-SwiftUI views
-  }
+    public func updateProps(_ rawProps: [String: Any]) {
+      // Stub function – it's not used on the old architecture and non-SwiftUI views
+    }
 
-  public func supportsProp(withName name: String) -> Bool {
-    // Stub function – it's not used on the old architecture and non-SwiftUI views
-    return false
+    public func supportsProp(withName name: String) -> Bool {
+      // Stub function – it's not used on the old architecture and non-SwiftUI views
+      return false
+    }
   }
-}
 
-public typealias ExpoView = ExpoClassicView
+  public typealias ExpoView = ExpoClassicView
 #endif
diff --git a/ios/Core/Views/SwiftUI/ExpoSwiftUI.swift b/ios/Core/Views/SwiftUI/ExpoSwiftUI.swift
index 8a68fb21c5d8cce40ac1dfaa43e19fe3e34d4446..1cb8fbbadb5da99e3f2635b08e399dadd5fe9d8a 100644
--- a/ios/Core/Views/SwiftUI/ExpoSwiftUI.swift
+++ b/ios/Core/Views/SwiftUI/ExpoSwiftUI.swift
@@ -1,6 +1,4 @@
 // Copyright 2024-present 650 Industries. All rights reserved.
 
-/**
- A namespace for Expo APIs that deal with SwiftUI.
- */
+/// A namespace for Expo APIs that deal with SwiftUI.
 public struct ExpoSwiftUI {}
diff --git a/ios/Core/Views/SwiftUI/SwiftUIChild.swift b/ios/Core/Views/SwiftUI/SwiftUIChild.swift
index 05f2d8aa3fc9f47b9b41a5b2b08e0eeb771ec320..b7c9a87a4bec52b50c9ef9612791c012bced13dd 100644
--- a/ios/Core/Views/SwiftUI/SwiftUIChild.swift
+++ b/ios/Core/Views/SwiftUI/SwiftUIChild.swift
@@ -5,7 +5,7 @@ import SwiftUI
 extension ExpoSwiftUI {
   /**
    View that renders an UIKit-based React child view and manages its layout by synchronizing `UIView.frame` with the SwiftUI system.
-
+  
    React Native sets `center` and `bounds` properties during the layout, but as per Apple docs, this is not recommended and may result
    in undefined behavior (read more in ``UIViewRepresentable`` docs). To fix it, we're observing for changes in `bounds` and then
    pass the new frame to SwiftUI so it can update its layout metrics and then set UIView's origin to zero (so it doesn't affect SwiftUI's layout in any way).
diff --git a/ios/Core/Views/SwiftUI/SwiftUIHostingView.swift b/ios/Core/Views/SwiftUI/SwiftUIHostingView.swift
index 76e82804290b99dd42d60db89a3634901da4c11b..264006eb245f794c0f45584766f46e28678f2b40 100644
--- a/ios/Core/Views/SwiftUI/SwiftUIHostingView.swift
+++ b/ios/Core/Views/SwiftUI/SwiftUIHostingView.swift
@@ -2,9 +2,7 @@
 
 import SwiftUI
 
-/**
- A type-erased protocol that hosting views must conform to.
- */
+/// A type-erased protocol that hosting views must conform to.
 internal protocol AnyExpoSwiftUIHostingView {
   func updateProps(_ rawProps: [String: Any])
   func getContentView() -> any ExpoSwiftUI.View
@@ -16,7 +14,9 @@ extension ExpoSwiftUI {
   /**
    A hosting view that renders a SwiftUI view inside the UIKit view hierarchy.
    */
-  public final class HostingView<Props: ViewProps, ContentView: View<Props>>: ExpoView, AnyExpoSwiftUIHostingView {
+  public final class HostingView<Props: ViewProps, ContentView: View<Props>>: ExpoView,
+    AnyExpoSwiftUIHostingView
+  {
     /**
      Props object that stores all the props for this particular view.
      It's an environment object that is observed by the content view.
@@ -41,9 +41,9 @@ extension ExpoSwiftUI {
       super.init(appContext: appContext)
 
       #if os(iOS) || os(tvOS)
-      // Hosting controller has white background by default,
-      // but we always want it to be transparent.
-      hostingController.view.backgroundColor = .clear
+        // Hosting controller has white background by default,
+        // but we always want it to be transparent.
+        hostingController.view.backgroundColor = .clear
       #endif
     }
 
@@ -59,13 +59,15 @@ extension ExpoSwiftUI {
      */
     public override func updateProps(_ rawProps: [String: Any]) {
       guard let appContext else {
-        log.error("AppContext is not available, view props cannot be updated for \(ContentView.self)")
+        log.error(
+          "AppContext is not available, view props cannot be updated for \(ContentView.self)")
         return
       }
       do {
         try props.updateRawProps(rawProps, appContext: appContext)
       } catch let error {
-        log.error("Updating props for \(ContentView.self) has failed: \(error.localizedDescription)")
+        log.error(
+          "Updating props for \(ContentView.self) has failed: \(error.localizedDescription)")
       }
     }
 
@@ -86,65 +88,65 @@ extension ExpoSwiftUI {
       return true
     }
 
-#if os(iOS) || os(tvOS)
-#if RCT_NEW_ARCH_ENABLED
-    /**
-     Fabric calls this function when mounting (attaching) a child component view.
-     */
-    public override func mountChildComponentView(_ childComponentView: UIView, index: Int) {
-      var children = props.children ?? []
-      let child = Child(view: childComponentView)
-
-      children.insert(child, at: index)
-
-      props.children = children
-    }
-
-    /**
-     Fabric calls this function when unmounting (detaching) a child component view.
-     */
-    public override func unmountChildComponentView(_ childComponentView: UIView, index: Int) {
-      // Make sure the view has no superview, React Native asserts against this.
-      childComponentView.removeFromSuperview()
-
-      if let children = props.children {
-        props.children = children.filter({ $0.view != childComponentView })
+    #if os(iOS) || os(tvOS)
+      #if RCT_NEW_ARCH_ENABLED
+        /**
+         Fabric calls this function when mounting (attaching) a child component view.
+         */
+        public override func mountChildComponentView(_ childComponentView: UIView, index: Int) {
+          var children = props.children ?? []
+          let child = Child(view: childComponentView)
+
+          children.insert(child, at: index)
+
+          props.children = children
+        }
+
+        /**
+         Fabric calls this function when unmounting (detaching) a child component view.
+         */
+        public override func unmountChildComponentView(_ childComponentView: UIView, index: Int) {
+          // Make sure the view has no superview, React Native asserts against this.
+          childComponentView.removeFromSuperview()
+
+          if let children = props.children {
+            props.children = children.filter({ $0.view != childComponentView })
+          }
+        }
+      #endif  // RCT_NEW_ARCH_ENABLED
+
+      /**
+       Setups layout constraints of the hosting controller view to match the layout set by React.
+       */
+      private func setupHostingViewConstraints() {
+        guard let view = hostingController.view else {
+          return
+        }
+        view.translatesAutoresizingMaskIntoConstraints = false
+
+        NSLayoutConstraint.activate([
+          view.topAnchor.constraint(equalTo: topAnchor),
+          view.bottomAnchor.constraint(equalTo: bottomAnchor),
+          view.leftAnchor.constraint(equalTo: leftAnchor),
+          view.rightAnchor.constraint(equalTo: rightAnchor),
+        ])
       }
-    }
-#endif // RCT_NEW_ARCH_ENABLED
-
-    /**
-     Setups layout constraints of the hosting controller view to match the layout set by React.
-     */
-    private func setupHostingViewConstraints() {
-      guard let view = hostingController.view else {
-        return
-      }
-      view.translatesAutoresizingMaskIntoConstraints = false
-
-      NSLayoutConstraint.activate([
-        view.topAnchor.constraint(equalTo: topAnchor),
-        view.bottomAnchor.constraint(equalTo: bottomAnchor),
-        view.leftAnchor.constraint(equalTo: leftAnchor),
-        view.rightAnchor.constraint(equalTo: rightAnchor)
-      ])
-    }
 
-    // MARK: - UIView lifecycle
+      // MARK: - UIView lifecycle
 
-    public override func didMoveToWindow() {
-      super.didMoveToWindow()
+      public override func didMoveToWindow() {
+        super.didMoveToWindow()
 
-      if window != nil, let parentController = reactViewController() {
-        parentController.addChild(hostingController)
-        addSubview(hostingController.view)
-        hostingController.didMove(toParent: parentController)
-        setupHostingViewConstraints()
-      } else {
-        hostingController.view.removeFromSuperview()
-        hostingController.removeFromParent()
+        if window != nil, let parentController = reactViewController() {
+          parentController.addChild(hostingController)
+          addSubview(hostingController.view)
+          hostingController.didMove(toParent: parentController)
+          setupHostingViewConstraints()
+        } else {
+          hostingController.view.removeFromSuperview()
+          hostingController.removeFromParent()
+        }
       }
-    }
-#endif
+    #endif
   }
 }
diff --git a/ios/Core/Views/SwiftUI/SwiftUIViewDefinition.swift b/ios/Core/Views/SwiftUI/SwiftUIViewDefinition.swift
index f602f1f6e0fa60d526afa947e72b6b20dd85111f..1af5a8594fe1e2e017a76f2ea4f5002c1f0d332c 100644
--- a/ios/Core/Views/SwiftUI/SwiftUIViewDefinition.swift
+++ b/ios/Core/Views/SwiftUI/SwiftUIViewDefinition.swift
@@ -1,11 +1,9 @@
 // Copyright 2024-present 650 Industries. All rights reserved.
 
-import SwiftUI
 import Combine
+import SwiftUI
 
-/**
- A protocol for SwiftUI views that need to access props.
- */
+/// A protocol for SwiftUI views that need to access props.
 public protocol ExpoSwiftUIView<Props>: SwiftUI.View, AnyArgument {
   associatedtype Props: ExpoSwiftUI.ViewProps
 
@@ -15,17 +13,17 @@ public protocol ExpoSwiftUIView<Props>: SwiftUI.View, AnyArgument {
   init()
 }
 
-public extension ExpoSwiftUIView {
+extension ExpoSwiftUIView {
   /**
    Returns React's children as SwiftUI views.
    */
-  func Children() -> some View { // swiftlint:disable:this identifier_name
+  public func Children() -> some View {  // swiftlint:disable:this identifier_name
     ZStack(alignment: .topLeading) {
       ForEach(props.children ?? []) { $0 }
     }
   }
 
-  static func getDynamicType() -> AnyDynamicType {
+  public static func getDynamicType() -> AnyDynamicType {
     return DynamicSwiftUIViewType(innerType: Self.self)
   }
 }
@@ -36,7 +34,9 @@ extension ExpoSwiftUI {
   /**
    A definition representing the native SwiftUI view to export to React.
    */
-  public final class ViewDefinition<Props: ViewProps, ViewType: View<Props>>: ExpoModulesCore.ViewDefinition<HostingView<Props, ViewType>> {
+  public final class ViewDefinition<Props: ViewProps, ViewType: View<Props>>: ExpoModulesCore
+      .ViewDefinition<HostingView<Props, ViewType>>
+  {
     init(_ viewType: ViewType.Type) {
       super.init(HostingView<Props, ViewType>.self, elements: [])
     }
diff --git a/ios/Core/Views/SwiftUI/SwiftUIViewDefinitionBuilder.swift b/ios/Core/Views/SwiftUI/SwiftUIViewDefinitionBuilder.swift
index e8f81e32127a4696424c3b39c486234136d96069..76c770254c760e5f20536f14181f80f18a1db368 100644
--- a/ios/Core/Views/SwiftUI/SwiftUIViewDefinitionBuilder.swift
+++ b/ios/Core/Views/SwiftUI/SwiftUIViewDefinitionBuilder.swift
@@ -6,7 +6,9 @@ extension ExpoSwiftUI {
    */
   @resultBuilder
   public struct ViewDefinitionBuilder<ViewType: ExpoSwiftUI.View> {
-    public static func buildBlock(_ elements: AnyViewDefinitionElement...) -> [AnyViewDefinitionElement] {
+    public static func buildBlock(_ elements: AnyViewDefinitionElement...)
+      -> [AnyViewDefinitionElement]
+    {
       return elements
     }
 
diff --git a/ios/Core/Views/SwiftUI/SwiftUIViewHost.swift b/ios/Core/Views/SwiftUI/SwiftUIViewHost.swift
index 10cdf814d30623e69279e9999b53fe7f9bdccc1b..e5e45c718900f83a7c45030afe2b63c9453a7312 100644
--- a/ios/Core/Views/SwiftUI/SwiftUIViewHost.swift
+++ b/ios/Core/Views/SwiftUI/SwiftUIViewHost.swift
@@ -10,13 +10,13 @@ extension ExpoSwiftUI {
     let view: UIView
 
     #if os(macOS)
-    func makeNSView(context: Context) -> NSView {
-      return view
-    }
+      func makeNSView(context: Context) -> NSView {
+        return view
+      }
 
-    func updateNSView(_ nsView: NSView, context: Context) {
+      func updateNSView(_ nsView: NSView, context: Context) {
         // Nothing to do here
-    }
+      }
     #endif
 
     func makeUIView(context: Context) -> UIView {
diff --git a/ios/Core/Views/ViewDefinition.swift b/ios/Core/Views/ViewDefinition.swift
index 36f93bc476acfcde0dff23f56860ccf9815e8f1f..fd949dca47e4c575c9f540212e207954a0b94ca5 100644
--- a/ios/Core/Views/ViewDefinition.swift
+++ b/ios/Core/Views/ViewDefinition.swift
@@ -1,8 +1,6 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- A definition representing the native view to export to React.
- */
+/// A definition representing the native view to export to React.
 public class ViewDefinition<ViewType: UIView>: ObjectDefinition, AnyViewDefinition {
   /**
    An array of view props definitions.
@@ -23,7 +21,8 @@ public class ViewDefinition<ViewType: UIView>: ObjectDefinition, AnyViewDefiniti
    Default initializer receiving children definitions from the result builder.
    */
   init(_ viewType: ViewType.Type, elements: [AnyViewDefinitionElement]) {
-    self.props = elements
+    self.props =
+      elements
       .compactMap { $0 as? AnyViewProp }
 
     self.eventNames = Array(
@@ -32,7 +31,8 @@ public class ViewDefinition<ViewType: UIView>: ObjectDefinition, AnyViewDefiniti
         .joined()
     )
 
-    self.lifecycleMethods = elements
+    self.lifecycleMethods =
+      elements
       .compactMap { $0 as? AnyViewLifecycleMethod }
 
     super.init(definitions: elements)
@@ -42,11 +42,12 @@ public class ViewDefinition<ViewType: UIView>: ObjectDefinition, AnyViewDefiniti
 
   public func createView(appContext: AppContext) -> UIView? {
     if let expoViewType = ViewType.self as? AnyExpoView.Type {
-#if RCT_NEW_ARCH_ENABLED
-      if let fabricViewType = ViewType.self as? ExpoFabricView.Type {
-        return ExpoFabricView.create(viewType: fabricViewType, viewDefinition: self, appContext: appContext)
-      }
-#endif
+      #if RCT_NEW_ARCH_ENABLED
+        if let fabricViewType = ViewType.self as? ExpoFabricView.Type {
+          return ExpoFabricView.create(
+            viewType: fabricViewType, viewDefinition: self, appContext: appContext)
+        }
+      #endif
       return expoViewType.init(appContext: appContext)
     }
     if let legacyViewType = ViewType.self as? EXLegacyExpoViewProtocol.Type {
diff --git a/ios/Core/Views/ViewLifecycleMethod.swift b/ios/Core/Views/ViewLifecycleMethod.swift
index bdbece424f2dff81f5e0e9e062a3519f6ce09e4a..97bf1df7982bcbbcdcd7a664dcede0695b40144a 100644
--- a/ios/Core/Views/ViewLifecycleMethod.swift
+++ b/ios/Core/Views/ViewLifecycleMethod.swift
@@ -1,15 +1,11 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- An enum that identifies lifecycle method types.
- */
+/// An enum that identifies lifecycle method types.
 public enum ViewLifecycleMethodType {
   case didUpdateProps
 }
 
-/**
- Type-erased protocol for all view lifecycle methods.
- */
+/// Type-erased protocol for all view lifecycle methods.
 internal protocol AnyViewLifecycleMethod: AnyDefinition {
   /**
    Type of the lifecycle method.
@@ -22,9 +18,7 @@ internal protocol AnyViewLifecycleMethod: AnyDefinition {
   func callAsFunction(_ view: UIView)
 }
 
-/**
- Element of the view definition that represents a lifecycle method, such as `OnViewDidUpdateProps`.
- */
+/// Element of the view definition that represents a lifecycle method, such as `OnViewDidUpdateProps`.
 public final class ViewLifecycleMethod<ViewType: UIView>: AnyViewLifecycleMethod {
   /**
    The actual closure that gets called when the view signals an event in view's lifecycle.
@@ -40,7 +34,8 @@ public final class ViewLifecycleMethod<ViewType: UIView>: AnyViewLifecycleMethod
 
   func callAsFunction(_ view: UIView) {
     guard let view = view as? ViewType else {
-      log.warn("Cannot call lifecycle method '\(type)', given view is not of type '\(ViewType.self)'")
+      log.warn(
+        "Cannot call lifecycle method '\(type)', given view is not of type '\(ViewType.self)'")
       return
     }
     closure(view)
diff --git a/ios/Core/Views/ViewModuleWrapper.swift b/ios/Core/Views/ViewModuleWrapper.swift
index c01fbd8417b68d254e8bcfca85bd93cf362c7010..08051d3477a9caebf3de13b7ed180554b3354842 100644
--- a/ios/Core/Views/ViewModuleWrapper.swift
+++ b/ios/Core/Views/ViewModuleWrapper.swift
@@ -1,19 +1,15 @@
 import ObjectiveC
 
-/**
- A protocol that helps in identifying whether the instance of `ViewModuleWrapper` is of a dynamically created class.
- */
+/// A protocol that helps in identifying whether the instance of `ViewModuleWrapper` is of a dynamically created class.
 @objc
 protocol DynamicModuleWrapperProtocol {
   @objc
   optional func wrappedModule() -> ViewModuleWrapper
 }
 
-/**
- Each module that has a view manager definition needs to be wrapped by `RCTViewManager`.
- Unfortunately, we can't use just one class because React Native checks for duplicated classes.
- We're generating its subclasses in runtime as a workaround.
- */
+/// Each module that has a view manager definition needs to be wrapped by `RCTViewManager`.
+/// Unfortunately, we can't use just one class because React Native checks for duplicated classes.
+/// We're generating its subclasses in runtime as a workaround.
 @objc
 public final class ViewModuleWrapper: RCTViewManager, DynamicModuleWrapperProtocol {
   /**
@@ -98,13 +94,16 @@ public final class ViewModuleWrapper: RCTViewManager, DynamicModuleWrapperProtoc
    Creates a subclass of `ViewModuleWrapper` in runtime. The new class overrides `moduleName` stub.
    */
   @objc
-  public static func createViewModuleWrapperClass(module: ViewModuleWrapper, appId: String?) -> ViewModuleWrapper.Type? {
+  public static func createViewModuleWrapperClass(module: ViewModuleWrapper, appId: String?)
+    -> ViewModuleWrapper.Type?
+  {
     // We're namespacing the view name so we know it uses our architecture.
-    let prefixedViewName = if let appId = appId {
-      "\(viewManagerAdapterPrefix)\(module.name())_\((appId))"
-    } else {
-      "\(viewManagerAdapterPrefix)\(module.name())"
-    }
+    let prefixedViewName =
+      if let appId = appId {
+        "\(viewManagerAdapterPrefix)\(module.name())_\((appId))"
+      } else {
+        "\(viewManagerAdapterPrefix)\(module.name())"
+      }
 
     return prefixedViewName.withCString { viewNamePtr in
       // Create a new class that inherits from `ViewModuleWrapper`. The class name passed here, doesn't work for Swift classes,
@@ -116,7 +115,9 @@ public final class ViewModuleWrapper: RCTViewManager, DynamicModuleWrapperProtoc
       // so there is no other way to pass it to the instances.
       let wrappedModuleBlock: @convention(block) () -> ViewModuleWrapper = { module }
       let wrappedModuleImp: IMP = imp_implementationWithBlock(wrappedModuleBlock)
-      class_addMethod(wrapperClass, #selector(DynamicModuleWrapperProtocol.wrappedModule), wrappedModuleImp, "@@:")
+      class_addMethod(
+        wrapperClass, #selector(DynamicModuleWrapperProtocol.wrappedModule), wrappedModuleImp, "@@:"
+      )
 
       return wrapperClass as? ViewModuleWrapper.Type
     }
@@ -124,4 +125,5 @@ public final class ViewModuleWrapper: RCTViewManager, DynamicModuleWrapperProtoc
 }
 
 // The direct event implementation can be cached and lazy-loaded (global and static variables are lazy by default in Swift).
-let directEventBlockImplementation = imp_implementationWithBlock({ ["RCTDirectEventBlock"] } as @convention(block) () -> [String])
+let directEventBlockImplementation = imp_implementationWithBlock(
+  { ["RCTDirectEventBlock"] } as @convention(block) () -> [String])
diff --git a/ios/DevTools/CdpNetworkTypes.swift b/ios/DevTools/CdpNetworkTypes.swift
index e770efa5307fbdcf68cda8d16874286022554eaf..51efd15b3b0a30143617dc1a19d710f22c12e695 100644
--- a/ios/DevTools/CdpNetworkTypes.swift
+++ b/ios/DevTools/CdpNetworkTypes.swift
@@ -94,7 +94,10 @@ struct CdpNetwork {
     var referrerPolicy = "no-referrer"
     let type: ResourceType
 
-    init(now: TimeInterval, requestId: RequestId, request: URLRequest, encodedDataLength: Int64, redirectResponse: HTTPURLResponse?) {
+    init(
+      now: TimeInterval, requestId: RequestId, request: URLRequest, encodedDataLength: Int64,
+      redirectResponse: HTTPURLResponse?
+    ) {
       self.requestId = requestId
       self.request = Request(request)
       self.timestamp = now
@@ -129,7 +132,10 @@ struct CdpNetwork {
     let response: Response
     var hasExtraInfo = false
 
-    init(now: TimeInterval, requestId: RequestId, request: URLRequest, response: HTTPURLResponse, encodedDataLength: Int64) {
+    init(
+      now: TimeInterval, requestId: RequestId, request: URLRequest, response: HTTPURLResponse,
+      encodedDataLength: Int64
+    ) {
       self.requestId = requestId
       self.timestamp = now
       self.response = Response(response, encodedDataLength: encodedDataLength)
@@ -156,7 +162,8 @@ struct CdpNetwork {
 
     init(now: TimeInterval, requestId: RequestId, responseBody: Data, isText: Bool) {
       self.requestId = requestId
-      let bodyString = isText ? String(data: responseBody, encoding: .utf8) : responseBody.base64EncodedString()
+      let bodyString =
+        isText ? String(data: responseBody, encoding: .utf8) : responseBody.base64EncodedString()
       if let bodyString = bodyString {
         self.body = bodyString
         self.base64Encoded = !isText
diff --git a/ios/DevTools/ExpoRequestCdpInterceptor.swift b/ios/DevTools/ExpoRequestCdpInterceptor.swift
index 0c7d73695385094a1ade327d554efcd1ff85e891..acb62d6ac226b3872942e219cd67d7933f1492eb 100644
--- a/ios/DevTools/ExpoRequestCdpInterceptor.swift
+++ b/ios/DevTools/ExpoRequestCdpInterceptor.swift
@@ -2,10 +2,8 @@
 
 import Foundation
 
-/**
- The `ExpoRequestInterceptorProtocolDelegate` implementation to
- dispatch CDP (Chrome DevTools Protocol: https://chromedevtools.github.io/devtools-protocol/) events.
- */
+/// The `ExpoRequestInterceptorProtocolDelegate` implementation to
+/// dispatch CDP (Chrome DevTools Protocol: https://chromedevtools.github.io/devtools-protocol/) events.
 @objc(EXRequestCdpInterceptor)
 public final class ExpoRequestCdpInterceptor: NSObject, ExpoRequestInterceptorProtocolDelegate {
   private weak var delegate: ExpoRequestCdpInterceptorDelegate?
@@ -26,7 +24,9 @@ public final class ExpoRequestCdpInterceptor: NSObject, ExpoRequestInterceptorPr
   private func dispatchEvent<T: CdpNetwork.EventParms>(_ event: CdpNetwork.Event<T>) {
     dispatchQueue.async {
       let encoder = JSONEncoder()
-      if let jsonData = try? encoder.encode(event), let payload = String(data: jsonData, encoding: .utf8) {
+      if let jsonData = try? encoder.encode(event),
+        let payload = String(data: jsonData, encoding: .utf8)
+      {
         self.delegate?.dispatch(payload)
       }
     }
@@ -34,7 +34,9 @@ public final class ExpoRequestCdpInterceptor: NSObject, ExpoRequestInterceptorPr
 
   // MARK: ExpoRequestInterceptorProtocolDelegate implementations
 
-  func willSendRequest(requestId: String, task: URLSessionTask, request: URLRequest, redirectResponse: HTTPURLResponse?) {
+  func willSendRequest(
+    requestId: String, task: URLSessionTask, request: URLRequest, redirectResponse: HTTPURLResponse?
+  ) {
     let now = Date().timeIntervalSince1970
 
     let params = CdpNetwork.RequestWillBeSentParams(
@@ -45,11 +47,15 @@ public final class ExpoRequestCdpInterceptor: NSObject, ExpoRequestInterceptorPr
       redirectResponse: redirectResponse)
     dispatchEvent(CdpNetwork.Event(method: "Network.requestWillBeSent", params: params))
 
-    let params2 = CdpNetwork.RequestWillBeSentExtraInfoParams(now: now, requestId: requestId, request: request)
+    let params2 = CdpNetwork.RequestWillBeSentExtraInfoParams(
+      now: now, requestId: requestId, request: request)
     dispatchEvent(CdpNetwork.Event(method: "Network.requestWillBeSentExtraInfo", params: params2))
   }
 
-  func didReceiveResponse(requestId: String, task: URLSessionTask, responseBody: Data, isText: Bool, responseBodyExceedsLimit: Bool) {
+  func didReceiveResponse(
+    requestId: String, task: URLSessionTask, responseBody: Data, isText: Bool,
+    responseBodyExceedsLimit: Bool
+  ) {
     guard let request = task.currentRequest, let response = task.response as? HTTPURLResponse else {
       return
     }
@@ -64,18 +70,18 @@ public final class ExpoRequestCdpInterceptor: NSObject, ExpoRequestInterceptorPr
     dispatchEvent(CdpNetwork.Event(method: "Network.responseReceived", params: params))
 
     if !responseBodyExceedsLimit {
-      let params2 = CdpNetwork.ExpoReceivedResponseBodyParams(now: now, requestId: requestId, responseBody: responseBody, isText: isText)
+      let params2 = CdpNetwork.ExpoReceivedResponseBodyParams(
+        now: now, requestId: requestId, responseBody: responseBody, isText: isText)
       dispatchEvent(CdpNetwork.Event(method: "Expo(Network.receivedResponseBody)", params: params2))
     }
 
-    let params3 = CdpNetwork.LoadingFinishedParams(now: now, requestId: requestId, encodedDataLength: task.countOfBytesReceived)
+    let params3 = CdpNetwork.LoadingFinishedParams(
+      now: now, requestId: requestId, encodedDataLength: task.countOfBytesReceived)
     dispatchEvent(CdpNetwork.Event(method: "Network.loadingFinished", params: params3))
   }
 }
 
-/**
- The delegate to dispatch CDP events for ExpoRequestCdpInterceptor
- */
+/// The delegate to dispatch CDP events for ExpoRequestCdpInterceptor
 @objc(EXRequestCdpInterceptorDelegate)
 public protocol ExpoRequestCdpInterceptorDelegate {
   @objc
diff --git a/ios/DevTools/ExpoRequestInterceptorProtocol.swift b/ios/DevTools/ExpoRequestInterceptorProtocol.swift
index c0369f41459b0c4af73e00a77bc97c064edbfb08..896f374306637531bdef0abb5df395dc9651b0ef 100644
--- a/ios/DevTools/ExpoRequestInterceptorProtocol.swift
+++ b/ios/DevTools/ExpoRequestInterceptorProtocol.swift
@@ -2,14 +2,12 @@
 
 import Foundation
 
-/**
- A `URLSession` interceptor which passes network events to its delegate
- */
+/// A `URLSession` interceptor which passes network events to its delegate
 @objc(EXRequestInterceptorProtocol)
 public final class ExpoRequestInterceptorProtocol: URLProtocol, URLSessionDataDelegate {
   private static var requestIdProvider = RequestIdProvider()
-  private static let sessionDelegate
-    = URLSessionSessionDelegateProxy(dispatchQueue: ExpoRequestCdpInterceptor.shared.dispatchQueue)
+  private static let sessionDelegate = URLSessionSessionDelegateProxy(
+    dispatchQueue: ExpoRequestCdpInterceptor.shared.dispatchQueue)
   private static let urlSession = URLSession(
     configuration: URLSessionConfiguration.default,
     delegate: sessionDelegate,
@@ -100,11 +98,14 @@ public final class ExpoRequestInterceptorProtocol: URLProtocol, URLSessionDataDe
       client?.urlProtocol(self, didFailWithError: error)
     } else {
       if let response = task.response as? HTTPURLResponse,
-        let requestId {
+        let requestId
+      {
         let contentType = response.value(forHTTPHeaderField: "Content-Type")
-        let isText = (contentType?.starts(with: "text/") ?? false) || contentType == "application/json"
+        let isText =
+          (contentType?.starts(with: "text/") ?? false) || contentType == "application/json"
         Self.delegate.didReceiveResponse(
-          requestId: requestId, task: task, responseBody: responseBody as Data, isText: isText, responseBodyExceedsLimit: responseBodyExceedsLimit)
+          requestId: requestId, task: task, responseBody: responseBody as Data, isText: isText,
+          responseBodyExceedsLimit: responseBodyExceedsLimit)
       }
       client?.urlProtocolDidFinishLoading(self)
     }
@@ -145,7 +146,8 @@ public final class ExpoRequestInterceptorProtocol: URLProtocol, URLSessionDataDe
     completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void
   ) {
     let sender = URLAuthenticationChallengeForwardSender(completionHandler: completionHandler)
-    let challengeWithSender = URLAuthenticationChallenge(authenticationChallenge: challenge, sender: sender)
+    let challengeWithSender = URLAuthenticationChallenge(
+      authenticationChallenge: challenge, sender: sender)
     client?.urlProtocol(self, didReceive: challengeWithSender)
   }
 
@@ -158,21 +160,21 @@ public final class ExpoRequestInterceptorProtocol: URLProtocol, URLSessionDataDe
   }
 }
 
-/**
- The delegate to dispatch network request events
- */
+/// The delegate to dispatch network request events
 @objc(EXRequestInterceptorProtocolDelegate)
 protocol ExpoRequestInterceptorProtocolDelegate {
   @objc
-  func willSendRequest(requestId: String, task: URLSessionTask, request: URLRequest, redirectResponse: HTTPURLResponse?)
+  func willSendRequest(
+    requestId: String, task: URLSessionTask, request: URLRequest, redirectResponse: HTTPURLResponse?
+  )
 
   @objc
-  func didReceiveResponse(requestId: String, task: URLSessionTask, responseBody: Data, isText: Bool, responseBodyExceedsLimit: Bool)
+  func didReceiveResponse(
+    requestId: String, task: URLSessionTask, responseBody: Data, isText: Bool,
+    responseBodyExceedsLimit: Bool)
 }
 
-/**
- A helper class to create a unique request ID
- */
+/// A helper class to create a unique request ID
 private struct RequestIdProvider {
   private var value: UInt64 = 0
 
diff --git a/ios/DevTools/URLAuthenticationChallengeForwardSender.swift b/ios/DevTools/URLAuthenticationChallengeForwardSender.swift
index 8c3efcbec2cc7fa26963ea0fe63a4919317c69d8..ccf0d09d5100d657b81a4646188686bf1ab3d6c9 100644
--- a/ios/DevTools/URLAuthenticationChallengeForwardSender.swift
+++ b/ios/DevTools/URLAuthenticationChallengeForwardSender.swift
@@ -1,9 +1,9 @@
 // Copyright 2015-present 650 Industries. All rights reserved.
 
-/**
- A helper class to forward URLAuthenticationChallenge completion handler to URLAuthenticationChallengeSender
- */
-internal final class URLAuthenticationChallengeForwardSender: NSObject, URLAuthenticationChallengeSender {
+/// A helper class to forward URLAuthenticationChallenge completion handler to URLAuthenticationChallengeSender
+internal final class URLAuthenticationChallengeForwardSender: NSObject,
+  URLAuthenticationChallengeSender
+{
   let completionHandler: (URLSession.AuthChallengeDisposition, URLCredential?) -> Void
 
   init(completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
diff --git a/ios/DevTools/URLRequest+httpBodyData.swift b/ios/DevTools/URLRequest+httpBodyData.swift
index 5b960315201dc40e0ae9bbaa86b9d548a5cdbc40..7f1b4dfb7b238ebd6e7209cfba93458d5d260e1f 100644
--- a/ios/DevTools/URLRequest+httpBodyData.swift
+++ b/ios/DevTools/URLRequest+httpBodyData.swift
@@ -2,9 +2,7 @@
 
 import Foundation
 
-/**
- `URLRequest.httpBodyData()` extension to read the underlying `httpBodyStream` as Data.
- */
+/// `URLRequest.httpBodyData()` extension to read the underlying `httpBodyStream` as Data.
 extension URLRequest {
   func httpBodyData(limit: Int = ExpoRequestInterceptorProtocol.MAX_BODY_SIZE) -> Data? {
     if let httpBody = self.httpBody {
@@ -13,7 +11,8 @@ extension URLRequest {
 
     if let contentLength = self.allHTTPHeaderFields?["Content-Length"],
       let contentLengthInt = Int(contentLength),
-      contentLengthInt > limit {
+      contentLengthInt > limit
+    {
       return nil
     }
     guard let stream = self.httpBodyStream else {
diff --git a/ios/DevTools/URLSessionSessionDelegateProxy.swift b/ios/DevTools/URLSessionSessionDelegateProxy.swift
index ffdbb88addc68a9a25f091d33e5fdc4bff1d3665..ebc113c042602743f36d1c2c77a34f7ae65098e9 100644
--- a/ios/DevTools/URLSessionSessionDelegateProxy.swift
+++ b/ios/DevTools/URLSessionSessionDelegateProxy.swift
@@ -1,8 +1,6 @@
 // Copyright 2015-present 650 Industries. All rights reserved.
 
-/**
- Shared URLSessionDelegate instance and delete calls back to ExpoRequestInterceptorProtocol instances.
- */
+/// Shared URLSessionDelegate instance and delete calls back to ExpoRequestInterceptorProtocol instances.
 public final class URLSessionSessionDelegateProxy: NSObject, URLSessionDataDelegate {
   private let dispatchQueue: DispatchQueue
   private var delegateMap: [AnyHashable: URLSessionDataDelegate] = [:]
@@ -41,7 +39,8 @@ public final class URLSessionSessionDelegateProxy: NSObject, URLSessionDataDeleg
     }
   }
 
-  public func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError: Error?) {
+  public func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError: Error?)
+  {
     if let delegate = getDelegate(task: task) {
       delegate.urlSession?(
         session,
@@ -90,7 +89,9 @@ public final class URLSessionSessionDelegateProxy: NSObject, URLSessionDataDeleg
     completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void
   ) {
     if let delegate = getDelegate(task: task),
-      delegate.responds(to: #selector(URLSessionTaskDelegate.urlSession(_:task:didReceive:completionHandler:))) {
+      delegate.responds(
+        to: #selector(URLSessionTaskDelegate.urlSession(_:task:didReceive:completionHandler:)))
+    {
       delegate.urlSession?(
         session,
         task: task,
diff --git a/ios/Fabric/ExpoFabricView.swift b/ios/Fabric/ExpoFabricView.swift
index 424cdec2dde755e2585e26990e4033b1060d1331..cfdd82259ca06cd038e099cec86a7c9c12b0d93d 100644
--- a/ios/Fabric/ExpoFabricView.swift
+++ b/ios/Fabric/ExpoFabricView.swift
@@ -2,190 +2,201 @@
 
 #if RCT_NEW_ARCH_ENABLED
 
-@objc(ExpoFabricView)
-open class ExpoFabricView: ExpoFabricViewObjC, AnyExpoView {
-  /**
-   A weak reference to the app context associated with this view.
-   The app context is injected into the class after the context is initialized.
-   see the `makeClass` static function.
-   */
-  public weak var appContext: AppContext?
-
-  /**
-   The view definition that setup from `ExpoFabricView.create()`.
-   */
-  private var viewDefinition: AnyViewDefinition?
-
-  /**
-   A dictionary of prop objects that contain prop setters.
-   */
-  lazy var viewManagerPropDict: [String: AnyViewProp]? = viewDefinition?.propsDict()
-
-  // MARK: - Initializers
-
-  // swiftlint:disable unavailable_function
-  @objc
-  public init() {
-    // For derived views, their initializer should be replaced by the 'class_replaceMethod'.
-    fatalError("Unsupported direct init() call for ExpoFabricView.")
-  }
-  // swiftlint:enable unavailable_function
+  @objc(ExpoFabricView)
+  open class ExpoFabricView: ExpoFabricViewObjC, AnyExpoView {
+    /**
+     A weak reference to the app context associated with this view.
+     The app context is injected into the class after the context is initialized.
+     see the `makeClass` static function.
+     */
+    public weak var appContext: AppContext?
+
+    /**
+     The view definition that setup from `ExpoFabricView.create()`.
+     */
+    private var viewDefinition: AnyViewDefinition?
+
+    /**
+     A dictionary of prop objects that contain prop setters.
+     */
+    lazy var viewManagerPropDict: [String: AnyViewProp]? = viewDefinition?.propsDict()
+
+    // MARK: - Initializers
+
+    // swiftlint:disable unavailable_function
+    @objc
+    public init() {
+      // For derived views, their initializer should be replaced by the 'class_replaceMethod'.
+      fatalError("Unsupported direct init() call for ExpoFabricView.")
+    }
+    // swiftlint:enable unavailable_function
 
-  @objc
-  public override init(frame: CGRect) {
-    super.init(frame: frame)
-  }
+    @objc
+    public override init(frame: CGRect) {
+      super.init(frame: frame)
+    }
 
-  required public init(appContext: AppContext? = nil) {
-    self.appContext = appContext
-    super.init(frame: .zero)
-  }
+    required public init(appContext: AppContext? = nil) {
+      self.appContext = appContext
+      super.init(frame: .zero)
+    }
 
-  /**
-   The view creator expected to be called for derived ExpoFabricView, the `viewDefinition` and event dispatchers will be setup from here.
-
-   NOTE: We swizzle the initializers, e.g. `ViewManagerAdapter_ExpoImage.new()` to `ImageView.init(appContext:)`
-   and we also need viewDefintion (or moduleName) for the `installEventDispatchers()`.
-   Swizzling ExpoFabricView doesn't give us chance to inject iMethod or iVar of ImageView and pass the moduleName.
-   Alternatively, we try to add a dedicated `ExpoFabricView.create()` and passing viewDefinition into the class.
-   That's not a perfect implementation but turns out to be the only way to get the viewDefinition (or moduleName).
-   The example call flow would be:
-   `ViewManagerAdapter_ExpoImage.new()` -> `ViewDefinition.createView()` -> `ExpoFabricView.create()` ->
-   `ImageView.init(appContext:)` -> `ExpoFabricView.init(appContext:)` -> `view.viewDefinition = viewDefinition` here
-   */
-  internal static func create(viewType: ExpoFabricView.Type, viewDefinition: AnyViewDefinition, appContext: AppContext) -> ExpoFabricView {
-    let view = viewType.init(appContext: appContext)
-    view.viewDefinition = viewDefinition
-    assert(appContext == view.appContext)
-    view.installEventDispatchers()
-    return view
-  }
+    /**
+     The view creator expected to be called for derived ExpoFabricView, the `viewDefinition` and event dispatchers will be setup from here.
+    
+     NOTE: We swizzle the initializers, e.g. `ViewManagerAdapter_ExpoImage.new()` to `ImageView.init(appContext:)`
+     and we also need viewDefintion (or moduleName) for the `installEventDispatchers()`.
+     Swizzling ExpoFabricView doesn't give us chance to inject iMethod or iVar of ImageView and pass the moduleName.
+     Alternatively, we try to add a dedicated `ExpoFabricView.create()` and passing viewDefinition into the class.
+     That's not a perfect implementation but turns out to be the only way to get the viewDefinition (or moduleName).
+     The example call flow would be:
+     `ViewManagerAdapter_ExpoImage.new()` -> `ViewDefinition.createView()` -> `ExpoFabricView.create()` ->
+     `ImageView.init(appContext:)` -> `ExpoFabricView.init(appContext:)` -> `view.viewDefinition = viewDefinition` here
+     */
+    internal static func create(
+      viewType: ExpoFabricView.Type, viewDefinition: AnyViewDefinition, appContext: AppContext
+    ) -> ExpoFabricView {
+      let view = viewType.init(appContext: appContext)
+      view.viewDefinition = viewDefinition
+      assert(appContext == view.appContext)
+      view.installEventDispatchers()
+      return view
+    }
 
-  // Mark the required init as unavailable so that subclasses can avoid overriding it.
-  @available(*, unavailable)
-  public required init?(coder: NSCoder) {
-    fatalError("init(coder:) has not been implemented")
-  }
+    // Mark the required init as unavailable so that subclasses can avoid overriding it.
+    @available(*, unavailable)
+    public required init?(coder: NSCoder) {
+      fatalError("init(coder:) has not been implemented")
+    }
 
-  // MARK: - ExpoFabricViewInterface
+    // MARK: - ExpoFabricViewInterface
 
-  public override func updateProps(_ props: [String: Any]) {
-    guard let context = appContext, let propsDict = viewManagerPropDict else {
-      return
-    }
-    for (key, prop) in propsDict {
-      let newValue = props[key] as Any
+    public override func updateProps(_ props: [String: Any]) {
+      guard let context = appContext, let propsDict = viewManagerPropDict else {
+        return
+      }
+      for (key, prop) in propsDict {
+        let newValue = props[key] as Any
 
-      // TODO: @tsapeta: Figure out better way to rethrow errors from here.
-      // Adding `throws` keyword to the function results in different
-      // method signature in Objective-C. Maybe just call `RCTLogError`?
-      try? prop.set(value: Conversions.fromNSObject(newValue), onView: self, appContext: context)
+        // TODO: @tsapeta: Figure out better way to rethrow errors from here.
+        // Adding `throws` keyword to the function results in different
+        // method signature in Objective-C. Maybe just call `RCTLogError`?
+        try? prop.set(value: Conversions.fromNSObject(newValue), onView: self, appContext: context)
+      }
     }
-  }
 
-  /**
-   Calls lifecycle methods registered by `OnViewDidUpdateProps` definition component.
-   */
-  public override func viewDidUpdateProps() {
-    guard let viewDefinition else {
-      return
+    /**
+     Calls lifecycle methods registered by `OnViewDidUpdateProps` definition component.
+     */
+    public override func viewDidUpdateProps() {
+      guard let viewDefinition else {
+        return
+      }
+      viewDefinition.callLifecycleMethods(withType: .didUpdateProps, forView: self)
     }
-    viewDefinition.callLifecycleMethods(withType: .didUpdateProps, forView: self)
-  }
 
-  /**
-   Returns a bool value whether the view supports prop with the given name.
-   */
-  public override func supportsProp(withName name: String) -> Bool {
-    return viewManagerPropDict?.index(forKey: name) != nil
-  }
+    /**
+     Returns a bool value whether the view supports prop with the given name.
+     */
+    public override func supportsProp(withName name: String) -> Bool {
+      return viewManagerPropDict?.index(forKey: name) != nil
+    }
 
-  // MARK: - Privates
-
-  /**
-   Installs convenient event dispatchers for declared events, so the view can just invoke the block to dispatch the proper event.
-   */
-  private func installEventDispatchers() {
-    viewDefinition?.eventNames.forEach { eventName in
-      installEventDispatcher(forEvent: eventName, onView: self) { [weak self] (body: [String: Any]) in
-        if let self = self {
-          self.dispatchEvent(eventName, payload: body)
-        } else {
-          log.error("Cannot dispatch an event while the managing ExpoFabricView is deallocated")
+    // MARK: - Privates
+
+    /**
+     Installs convenient event dispatchers for declared events, so the view can just invoke the block to dispatch the proper event.
+     */
+    private func installEventDispatchers() {
+      viewDefinition?.eventNames.forEach { eventName in
+        installEventDispatcher(forEvent: eventName, onView: self) {
+          [weak self] (body: [String: Any]) in
+          if let self = self {
+            self.dispatchEvent(eventName, payload: body)
+          } else {
+            log.error("Cannot dispatch an event while the managing ExpoFabricView is deallocated")
+          }
         }
       }
     }
-  }
 
-  // MARK: - Statics
+    // MARK: - Statics
 
-  /**
-   Called by React Native to check if the view supports recycling.
-   */
-  @objc
-  public static func shouldBeRecycled() -> Bool {
-    // Turn off recycling for Expo views. We don't think there is any benefit of recycling – it may lead to more bugs than gains.
-    // TODO: Make it possible to override this behavior for particular views
-    return false
-  }
+    /**
+     Called by React Native to check if the view supports recycling.
+     */
+    @objc
+    public static func shouldBeRecycled() -> Bool {
+      // Turn off recycling for Expo views. We don't think there is any benefit of recycling – it may lead to more bugs than gains.
+      // TODO: Make it possible to override this behavior for particular views
+      return false
+    }
 
-  internal static var viewClassesRegistry = [String: AnyClass]()
-
-  /**
-   Dynamically creates a subclass of the `ExpoFabricView` class with injected app context and name of the associated module.
-   The new subclass is saved in the registry, so when asked for the next time, it's returned from cache with the updated app context.
-   - Note: Apple's documentation says that classes created with `objc_allocateClassPair` should then be registered using `objc_registerClassPair`,
-   but we can't do that as there might be more than one class with the same name (Expo Go) and allocating another one would return `nil`.
-   */
-  @objc
-  public static func makeViewClass(forAppContext appContext: AppContext, moduleName: String, className: String) -> AnyClass? {
-    if let viewClass = viewClassesRegistry[className] {
+    internal static var viewClassesRegistry = [String: AnyClass]()
+
+    /**
+     Dynamically creates a subclass of the `ExpoFabricView` class with injected app context and name of the associated module.
+     The new subclass is saved in the registry, so when asked for the next time, it's returned from cache with the updated app context.
+     - Note: Apple's documentation says that classes created with `objc_allocateClassPair` should then be registered using `objc_registerClassPair`,
+     but we can't do that as there might be more than one class with the same name (Expo Go) and allocating another one would return `nil`.
+     */
+    @objc
+    public static func makeViewClass(
+      forAppContext appContext: AppContext, moduleName: String, className: String
+    ) -> AnyClass? {
+      if let viewClass = viewClassesRegistry[className] {
+        inject(appContext: appContext)
+        injectInitializer(appContext: appContext, moduleName: moduleName, toViewClass: viewClass)
+        return viewClass
+      }
+      guard let viewClass = objc_allocateClassPair(ExpoFabricView.self, className, 0) else {
+        fatalError("Cannot allocate a Fabric view class for '\(className)'")
+      }
       inject(appContext: appContext)
       injectInitializer(appContext: appContext, moduleName: moduleName, toViewClass: viewClass)
-      return viewClass
-    }
-    guard let viewClass = objc_allocateClassPair(ExpoFabricView.self, className, 0) else {
-      fatalError("Cannot allocate a Fabric view class for '\(className)'")
-    }
-    inject(appContext: appContext)
-    injectInitializer(appContext: appContext, moduleName: moduleName, toViewClass: viewClass)
 
-    // Save the allocated view class in the registry for the later use (e.g. when the app is reloaded).
-    viewClassesRegistry[className] = viewClass
+      // Save the allocated view class in the registry for the later use (e.g. when the app is reloaded).
+      viewClassesRegistry[className] = viewClass
 
-    return viewClass
-  }
+      return viewClass
+    }
 
-  internal static func inject(appContext: AppContext) {
-    // Keep it weak so we don't leak the app context.
-    weak var weakAppContext = appContext
-    let appContextBlock: @convention(block) () -> AppContext? = { weakAppContext }
-    let appContextBlockImp: IMP = imp_implementationWithBlock(appContextBlock)
-    class_replaceMethod(object_getClass(ExpoFabricView.self), #selector(appContextFromClass), appContextBlockImp, "@@:")
-  }
+    internal static func inject(appContext: AppContext) {
+      // Keep it weak so we don't leak the app context.
+      weak var weakAppContext = appContext
+      let appContextBlock: @convention(block) () -> AppContext? = { weakAppContext }
+      let appContextBlockImp: IMP = imp_implementationWithBlock(appContextBlock)
+      class_replaceMethod(
+        object_getClass(ExpoFabricView.self), #selector(appContextFromClass), appContextBlockImp,
+        "@@:")
+    }
 
-  internal static func injectInitializer(appContext: AppContext, moduleName: String, toViewClass viewClass: AnyClass) {
-    // The default initializer for native views. It will be called by Fabric.
-    let newBlock: @convention(block) () -> Any = {[weak appContext] in
-      guard let appContext, let moduleHolder = appContext.moduleRegistry.get(moduleHolderForName: moduleName) else {
-        fatalError(Exceptions.AppContextLost().reason)
-      }
-      guard let view = moduleHolder.definition.view?.createView(appContext: appContext) else {
-        fatalError("Cannot create a view from module '\(moduleName)'")
+    internal static func injectInitializer(
+      appContext: AppContext, moduleName: String, toViewClass viewClass: AnyClass
+    ) {
+      // The default initializer for native views. It will be called by Fabric.
+      let newBlock: @convention(block) () -> Any = { [weak appContext] in
+        guard let appContext,
+          let moduleHolder = appContext.moduleRegistry.get(moduleHolderForName: moduleName)
+        else {
+          fatalError(Exceptions.AppContextLost().reason)
+        }
+        guard let view = moduleHolder.definition.view?.createView(appContext: appContext) else {
+          fatalError("Cannot create a view from module '\(moduleName)'")
+        }
+        _ = Unmanaged.passRetained(view)  // retain the view given this is an initializer
+        return view
       }
-      _ = Unmanaged.passRetained(view) // retain the view given this is an initializer
-      return view
+      let newBlockImp: IMP = imp_implementationWithBlock(newBlock)
+      class_replaceMethod(object_getClass(viewClass), Selector("new"), newBlockImp, "@@:")
     }
-    let newBlockImp: IMP = imp_implementationWithBlock(newBlock)
-    class_replaceMethod(object_getClass(viewClass), Selector("new"), newBlockImp, "@@:")
-  }
 
-  // swiftlint:disable unavailable_function
-  @objc
-  private dynamic static func appContextFromClass() -> AppContext? {
-    fatalError("The AppContext must be injected in the 'ExpoFabricView' class")
+    // swiftlint:disable unavailable_function
+    @objc
+    private dynamic static func appContextFromClass() -> AppContext? {
+      fatalError("The AppContext must be injected in the 'ExpoFabricView' class")
+    }
+    // swiftlint:enable unavailable_function
   }
-  // swiftlint:enable unavailable_function
-}
 
-#endif // RCT_NEW_ARCH_ENABLED
+#endif  // RCT_NEW_ARCH_ENABLED
diff --git a/ios/FileSystemUtilities/FileSystemLegacyUtilities.swift b/ios/FileSystemUtilities/FileSystemLegacyUtilities.swift
index 340b03b02a9773c0e9f0ab9ebba203868806e97a..27170bb9db014cc8f3705aba44d53e84227186df 100644
--- a/ios/FileSystemUtilities/FileSystemLegacyUtilities.swift
+++ b/ios/FileSystemUtilities/FileSystemLegacyUtilities.swift
@@ -3,7 +3,9 @@
 import Foundation
 
 @objc(EXFileSystemLegacyUtilities)
-public class FileSystemLegacyUtilities: NSObject, EXInternalModule, EXFileSystemInterface, EXFilePermissionModuleInterface {
+public class FileSystemLegacyUtilities: NSObject, EXInternalModule, EXFileSystemInterface,
+  EXFilePermissionModuleInterface
+{
   @objc
   public var documentDirectory: String
 
@@ -18,7 +20,9 @@ public class FileSystemLegacyUtilities: NSObject, EXInternalModule, EXFileSystem
   var isScoped: Bool = false
 
   @objc
-  public init(documentDirectory: String, cachesDirectory: String, applicationSupportDirectory: String) {
+  public init(
+    documentDirectory: String, cachesDirectory: String, applicationSupportDirectory: String
+  ) {
     self.documentDirectory = documentDirectory
     self.cachesDirectory = cachesDirectory
     self.applicationSupportDirectory = applicationSupportDirectory
@@ -31,14 +35,15 @@ public class FileSystemLegacyUtilities: NSObject, EXInternalModule, EXFileSystem
   }
 
   required public override init() {
-    let documentPaths = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)
+    let documentPaths = NSSearchPathForDirectoriesInDomains(
+      .documentDirectory, .userDomainMask, true)
     self.documentDirectory = documentPaths[0]
 
     let cachesPaths = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true)
     self.cachesDirectory = cachesPaths[0]
 
     let applicationSupportDirectoryPaths =
-    NSSearchPathForDirectoriesInDomains(.applicationSupportDirectory, .userDomainMask, true)
+      NSSearchPathForDirectoriesInDomains(.applicationSupportDirectory, .userDomainMask, true)
     self.applicationSupportDirectory = applicationSupportDirectoryPaths[0]
 
     super.init()
@@ -57,7 +62,7 @@ public class FileSystemLegacyUtilities: NSObject, EXInternalModule, EXFileSystem
       "assets-library",
       "http",
       "https",
-      "ph"
+      "ph",
     ]
 
     if validSchemas.contains(uri.scheme ?? "") {
@@ -98,7 +103,8 @@ public class FileSystemLegacyUtilities: NSObject, EXInternalModule, EXFileSystem
   @objc
   public func getInternalPathPermissions(_ url: URL) -> EXFileSystemPermissionFlags {
     let appGroupSharedDirectories: [String] = self.appGroupSharedDirectories ?? []
-    let scopedDirs: [String] = [cachesDirectory, documentDirectory, applicationSupportDirectory] + appGroupSharedDirectories
+    let scopedDirs: [String] =
+      [cachesDirectory, documentDirectory, applicationSupportDirectory] + appGroupSharedDirectories
     let standardizedPath = url.standardized.path
     for scopedDirectory in scopedDirs {
       if standardizedPath.hasPrefix(scopedDirectory + "/") || standardizedPath == scopedDirectory {
diff --git a/ios/FileSystemUtilities/FileSystemUtilities.swift b/ios/FileSystemUtilities/FileSystemUtilities.swift
index 7a1c66bc324beb928bbb14de90b2be23f3ad10d1..30f9736e8bae2d3db068f7670785be80b19d8560 100644
--- a/ios/FileSystemUtilities/FileSystemUtilities.swift
+++ b/ios/FileSystemUtilities/FileSystemUtilities.swift
@@ -25,8 +25,12 @@ public struct FileSystemUtilities {
     return true
   }
 
-  public static func generatePathInCache(_ appContext: AppContext?, in directory: String, extension: String) -> String {
-    guard let appContext, let dirPath = appContext.config.cacheDirectory?.appendingPathComponent(directory) else {
+  public static func generatePathInCache(
+    _ appContext: AppContext?, in directory: String, extension: String
+  ) -> String {
+    guard let appContext,
+      let dirPath = appContext.config.cacheDirectory?.appendingPathComponent(directory)
+    else {
       return ""
     }
     let fileName = UUID().uuidString.appending(`extension`)
@@ -34,7 +38,9 @@ public struct FileSystemUtilities {
     return dirPath.appendingPathComponent(fileName).path
   }
 
-  public static func permissions(_ appContext: AppContext?, for uri: URL) -> [FileSystemPermissionFlags] {
+  public static func permissions(_ appContext: AppContext?, for uri: URL)
+    -> [FileSystemPermissionFlags]
+  {
     guard let scheme = uri.scheme else {
       return [.none]
     }
@@ -51,7 +57,9 @@ public struct FileSystemUtilities {
     return [.none]
   }
 
-  private static func getPathPermissions(_ appContext: AppContext?, for path: URL) -> [FileSystemPermissionFlags] {
+  private static func getPathPermissions(_ appContext: AppContext?, for path: URL)
+    -> [FileSystemPermissionFlags]
+  {
     let permissionForInternalDirs = getInternalPathPermissions(appContext, for: path)
     if !permissionForInternalDirs.contains(.none) {
       return permissionForInternalDirs
@@ -59,19 +67,25 @@ public struct FileSystemUtilities {
     return getExternalPathPermissions(path)
   }
 
-  private static func getInternalPathPermissions(_ appContext: AppContext?, for url: URL) -> [FileSystemPermissionFlags] {
+  private static func getInternalPathPermissions(_ appContext: AppContext?, for url: URL)
+    -> [FileSystemPermissionFlags]
+  {
     guard let appContext else {
       return [.none]
     }
 
-    let scopedDirs = [appContext.config.cacheDirectory, appContext.config.documentDirectory] + appContext.config.appGroupSharedDirectories
+    let scopedDirs =
+      [appContext.config.cacheDirectory, appContext.config.documentDirectory]
+      + appContext.config.appGroupSharedDirectories
     let standardizedPath = url.standardized.path
 
     for dir in scopedDirs {
       guard let dir else {
         continue
       }
-      if standardizedPath.hasPrefix(dir.appendingPathComponent("/").absoluteString) || standardizedPath == dir.absoluteString {
+      if standardizedPath.hasPrefix(dir.appendingPathComponent("/").absoluteString)
+        || standardizedPath == dir.absoluteString
+      {
         return [.read, .write]
       }
     }
@@ -102,7 +116,9 @@ public struct FileSystemUtilities {
     let appGroups = appContext.appCodeSignEntitlements.appGroups ?? []
     var appGroupSharedDirectories: [String] = []
     for appGroup in appGroups {
-      if let directory = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: appGroup) {
+      if let directory = FileManager.default.containerURL(
+        forSecurityApplicationGroupIdentifier: appGroup)
+      {
         appGroupSharedDirectories.append(directory.standardized.path)
       }
     }
diff --git a/ios/JSI/JavaScriptRuntime.swift b/ios/JSI/JavaScriptRuntime.swift
index 32a330e5a44cf74ce1e9fa5f2262ff11dee2fac9..838041a9cb9bb2c578b6ada58671b5eab78fc566 100644
--- a/ios/JSI/JavaScriptRuntime.swift
+++ b/ios/JSI/JavaScriptRuntime.swift
@@ -1,14 +1,15 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-public extension JavaScriptRuntime {
+extension JavaScriptRuntime {
   /**
    A type of the closure that you pass to the `createSyncFunction` function.
    */
-  typealias SyncFunctionClosure = (_ this: JavaScriptValue, _ arguments: [JavaScriptValue]) throws -> JavaScriptValue
+  public typealias SyncFunctionClosure = (_ this: JavaScriptValue, _ arguments: [JavaScriptValue])
+    throws -> JavaScriptValue
 
   /**
    Evaluates JavaScript code represented as a string.
-
+  
    - Parameter source: A string representing a JavaScript expression, statement, or sequence of statements.
                        The expression can include variables and properties of existing objects.
    - Returns: The completion value of evaluating the given code represented as `JavaScriptValue`.
@@ -17,7 +18,7 @@ public extension JavaScriptRuntime {
    - Note: It wraps the original `evaluateScript` to better handle and rethrow exceptions.
    */
   @discardableResult
-  func eval(_ source: String) throws -> JavaScriptValue {
+  public func eval(_ source: String) throws -> JavaScriptValue {
     do {
       var result: JavaScriptValue?
       try EXUtilities.catchException {
@@ -35,7 +36,7 @@ public extension JavaScriptRuntime {
    See the other ``eval(_:)`` for more details.
    */
   @discardableResult
-  func eval(_ source: [String]) throws -> JavaScriptValue {
+  public func eval(_ source: [String]) throws -> JavaScriptValue {
     try eval(source.joined(separator: "\n"))
   }
 
@@ -45,7 +46,9 @@ public extension JavaScriptRuntime {
    - Returns: A JavaScript function represented as a `JavaScriptObject`.
    - Note: It refines the ObjC implementation from `EXJavaScriptRuntime` to properly catch Swift errors and rethrow them as ObjC `NSError`.
    */
-  func createSyncFunction(_ name: String, argsCount: Int = 0, closure: @escaping SyncFunctionClosure) -> JavaScriptObject {
+  public func createSyncFunction(
+    _ name: String, argsCount: Int = 0, closure: @escaping SyncFunctionClosure
+  ) -> JavaScriptObject {
     return __createSyncFunction(name, argsCount: argsCount) { this, args, errorPointer in
       do {
         return try runWithErrorPointer(errorPointer) {
@@ -64,7 +67,7 @@ public extension JavaScriptRuntime {
   /**
    Schedules a block to be executed with granted synchronized access to the JS runtime.
    */
-  func schedule(priority: SchedulerPriority = .normal, _ closure: @escaping () -> Void) {
+  public func schedule(priority: SchedulerPriority = .normal, _ closure: @escaping () -> Void) {
     __schedule(closure, priority: priority.rawValue)
   }
 }
diff --git a/ios/JSI/JavaScriptValue.swift b/ios/JSI/JavaScriptValue.swift
index 54185884366a233739f524a0d14e390b89b2799a..67981ecb04f0446e5271b4c9a3e12ec8fca7ab0c 100644
--- a/ios/JSI/JavaScriptValue.swift
+++ b/ios/JSI/JavaScriptValue.swift
@@ -1,9 +1,7 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- Enum with available kinds of values. It's almost the same as a result of "typeof"
- in JavaScript, however `null` has its own kind (typeof null == "object").
- */
+/// Enum with available kinds of values. It's almost the same as a result of "typeof"
+/// in JavaScript, however `null` has its own kind (typeof null == "object").
 public enum JavaScriptValueKind: String {
   case undefined
   case null
@@ -15,9 +13,7 @@ public enum JavaScriptValueKind: String {
   case object
 }
 
-/**
- A protocol that JavaScript values, objects and functions can conform to.
- */
+/// A protocol that JavaScript values, objects and functions can conform to.
 protocol AnyJavaScriptValue: AnyArgument {
   /**
    Tries to convert a raw JavaScript value to the conforming type.
@@ -123,11 +119,15 @@ extension JavaScriptValue: AnyJavaScriptValue, AnyArgument {
     if let value = value as? Self {
       return value
     }
-    throw JavaScriptValueConversionException((kind: value.kind, target: String(describing: Self.self)))
+    throw JavaScriptValueConversionException(
+      (kind: value.kind, target: String(describing: Self.self)))
   }
 }
 
-internal final class JavaScriptValueConversionException: GenericException<(kind: JavaScriptValueKind, target: String)> {
+internal final class JavaScriptValueConversionException: GenericException<
+  (kind: JavaScriptValueKind, target: String)
+>
+{
   override var reason: String {
     "Cannot represent a value of kind '\(param.kind)' as \(param.target)"
   }
diff --git a/ios/Legacy/NativeModulesProxy/NativeModulesProxyModule.swift b/ios/Legacy/NativeModulesProxy/NativeModulesProxyModule.swift
index 32e3c923d34ea2d6c62742b16177578466dbe77e..462d41e158884c8509e11ae2758232b8cc5deb17 100644
--- a/ios/Legacy/NativeModulesProxy/NativeModulesProxyModule.swift
+++ b/ios/Legacy/NativeModulesProxy/NativeModulesProxyModule.swift
@@ -14,23 +14,30 @@ public class NativeModulesProxyModule: Module {
       return config.toDictionary()
     }
 
-    AsyncFunction("callMethod") { (moduleName: String, methodName: String, arguments: [Any], promise: Promise) in
+    AsyncFunction("callMethod") {
+      (moduleName: String, methodName: String, arguments: [Any], promise: Promise) in
       guard let appContext = self.appContext else {
         return promise.reject(Exceptions.AppContextLost())
       }
 
       // Call a method on the new module if exists
       if appContext.hasModule(moduleName) {
-        appContext.callFunction(methodName, onModule: moduleName, withArgs: arguments, resolve: promise.resolver, reject: promise.legacyRejecter)
+        appContext.callFunction(
+          methodName, onModule: moduleName, withArgs: arguments, resolve: promise.resolver,
+          reject: promise.legacyRejecter)
         return
       }
 
       // Call a method on the legacy module
-      guard let legacyModule = appContext.legacyModuleRegistry?.getExportedModule(forName: moduleName) else {
+      guard
+        let legacyModule = appContext.legacyModuleRegistry?.getExportedModule(forName: moduleName)
+      else {
         return promise.reject(ModuleHolder.ModuleNotFoundException(moduleName))
       }
       legacyModule.methodQueue().async {
-        legacyModule.callExportedMethod(methodName, withArguments: arguments, resolver: promise.resolver, rejecter: promise.legacyRejecter)
+        legacyModule.callExportedMethod(
+          methodName, withArguments: arguments, resolver: promise.resolver,
+          rejecter: promise.legacyRejecter)
       }
     }
   }
diff --git a/ios/Platform.swift b/ios/Platform.swift
index c84b232482a3c58d6b12e01338bcdc10af516661..41d67124af59cd4a7ef55a42717bc73a8dabee33 100644
--- a/ios/Platform.swift
+++ b/ios/Platform.swift
@@ -1,15 +1,15 @@
 #if os(macOS)
 
-import AppKit
-import SwiftUI
+  import AppKit
+  import SwiftUI
 
-public typealias UIApplication = NSApplication
-public typealias UIView = NSView
-public typealias UIViewController = NSViewController
-public typealias UIResponder = NSResponder
-public typealias UIApplicationDelegate = NSApplicationDelegate
-public typealias UIWindow = NSWindow
-public typealias UIHostingController = NSHostingController
-public typealias UIViewRepresentable = NSViewRepresentable
+  public typealias UIApplication = NSApplication
+  public typealias UIView = NSView
+  public typealias UIViewController = NSViewController
+  public typealias UIResponder = NSResponder
+  public typealias UIApplicationDelegate = NSApplicationDelegate
+  public typealias UIWindow = NSWindow
+  public typealias UIHostingController = NSHostingController
+  public typealias UIViewRepresentable = NSViewRepresentable
 
-#endif // os(macOS)
+#endif  // os(macOS)
diff --git a/ios/ReactDelegates/ExpoReactDelegate.swift b/ios/ReactDelegates/ExpoReactDelegate.swift
index f2c4ac41f091d64e7b25fc4f88467d41b46c59ef..ced5d8e98a1f1fa262ee86c434ae606bcb6234ba 100644
--- a/ios/ReactDelegates/ExpoReactDelegate.swift
+++ b/ios/ReactDelegates/ExpoReactDelegate.swift
@@ -1,8 +1,6 @@
 // Copyright 2018-present 650 Industries. All rights reserved.
 
-/**
- An extensible react instance creation delegate. This class will loop through each `ExpoReactDelegateHandler` to determine the winner to create the instance.
- */
+/// An extensible react instance creation delegate. This class will loop through each `ExpoReactDelegateHandler` to determine the winner to create the instance.
 @objc(EXReactDelegate)
 public class ExpoReactDelegate: NSObject {
   private let handlers: [ExpoReactDelegateHandler]
@@ -12,36 +10,40 @@ public class ExpoReactDelegate: NSObject {
   }
 
   #if os(iOS) || os(tvOS)
-  @objc
-  public func createReactRootView(
-    moduleName: String,
-    initialProperties: [AnyHashable: Any]?,
-    launchOptions: [UIApplication.LaunchOptionsKey: Any]?
-  ) -> UIView {
-    return self.handlers.lazy
-      .compactMap { $0.createReactRootView(reactDelegate: self, moduleName: moduleName, initialProperties: initialProperties, launchOptions: launchOptions) }
-      .first(where: { _ in true })
-      ?? {
-        guard let rctAppDelegate = (UIApplication.shared.delegate as? RCTAppDelegate) else {
-          fatalError("The `UIApplication.shared.delegate` is not a `RCTAppDelegate` instance.")
+    @objc
+    public func createReactRootView(
+      moduleName: String,
+      initialProperties: [AnyHashable: Any]?,
+      launchOptions: [UIApplication.LaunchOptionsKey: Any]?
+    ) -> UIView {
+      return self.handlers.lazy
+        .compactMap {
+          $0.createReactRootView(
+            reactDelegate: self, moduleName: moduleName, initialProperties: initialProperties,
+            launchOptions: launchOptions)
         }
-        return rctAppDelegate.recreateRootView(
-          withBundleURL: nil,
-          moduleName: moduleName,
-          initialProps: initialProperties,
-          launchOptions: launchOptions
-        )
-      }()
-  }
+        .first(where: { _ in true })
+        ?? {
+          guard let rctAppDelegate = (UIApplication.shared.delegate as? RCTAppDelegate) else {
+            fatalError("The `UIApplication.shared.delegate` is not a `RCTAppDelegate` instance.")
+          }
+          return rctAppDelegate.recreateRootView(
+            withBundleURL: nil,
+            moduleName: moduleName,
+            initialProps: initialProperties,
+            launchOptions: launchOptions
+          )
+        }()
+    }
   #elseif os(macOS)
-  @objc
-  public func createReactRootView(
-    moduleName: String,
-    initialProperties: [AnyHashable: Any]?,
-    launchOptions: [AnyHashable: Any]?
-  ) -> UIView {
-    return UIView()
-  }
+    @objc
+    public func createReactRootView(
+      moduleName: String,
+      initialProperties: [AnyHashable: Any]?,
+      launchOptions: [AnyHashable: Any]?
+    ) -> UIView {
+      return UIView()
+    }
   #endif
 
   @objc
diff --git a/ios/ReactDelegates/ExpoReactDelegateHandler.swift b/ios/ReactDelegates/ExpoReactDelegateHandler.swift
index d498ab31af2a817ba35b562721e113ad233f16ed..2881d60876f65415d2938c5bd0a67aad2721628f 100644
--- a/ios/ReactDelegates/ExpoReactDelegateHandler.swift
+++ b/ios/ReactDelegates/ExpoReactDelegateHandler.swift
@@ -1,8 +1,6 @@
 // Copyright 2018-present 650 Industries. All rights reserved.
 
-/**
- The handler for `ExpoReactDelegate`. A module can implement a handler to process react instance creation.
- */
+/// The handler for `ExpoReactDelegate`. A module can implement a handler to process react instance creation.
 @objc(EXReactDelegateHandler)
 open class ExpoReactDelegateHandler: NSObject {
   public override required init() {}
@@ -12,15 +10,15 @@ open class ExpoReactDelegateHandler: NSObject {
    Otherwise return nil.
    */
   #if os(iOS) || os(tvOS)
-  @objc
-  open func createReactRootView(
-    reactDelegate: ExpoReactDelegate,
-    moduleName: String,
-    initialProperties: [AnyHashable: Any]?,
-    launchOptions: [UIApplication.LaunchOptionsKey: Any]?
-  ) -> UIView? {
-    return nil
-  }
+    @objc
+    open func createReactRootView(
+      reactDelegate: ExpoReactDelegate,
+      moduleName: String,
+      initialProperties: [AnyHashable: Any]?,
+      launchOptions: [UIApplication.LaunchOptionsKey: Any]?
+    ) -> UIView? {
+      return nil
+    }
   #endif
 
   /**
diff --git a/ios/ReactDelegates/ModulePriorities.swift b/ios/ReactDelegates/ModulePriorities.swift
index ff078ec046036921c04e653318e9fba8b493725d..8f07527db3cabe83625c8b3671b8dba64c6b6fb1 100644
--- a/ios/ReactDelegates/ModulePriorities.swift
+++ b/ios/ReactDelegates/ModulePriorities.swift
@@ -1,17 +1,15 @@
 // Copyright 2018-present 650 Industries. All rights reserved.
 
-/**
- This class determines the order of `ExpoReactDelegateHandler`.
-
- The priority is only for internal use and we maintain a pre-defined `SUPPORTED_MODULE` map.
- */
+/// This class determines the order of `ExpoReactDelegateHandler`.
+///
+/// The priority is only for internal use and we maintain a pre-defined `SUPPORTED_MODULE` map.
 internal struct ModulePriorities {
   static let SUPPORTED_MODULE = [
     // {key}: {value}
     // key: node package name
     // value: priority value, the higher value takes precedence
     "expo-screen-orientation": 10,
-    "expo-updates": 5
+    "expo-updates": 5,
   ]
 
   static func get(_ packageName: String) -> Int {
diff --git a/ios/Tests/BlobConvertiblesSpec.swift b/ios/Tests/BlobConvertiblesSpec.swift
index 4e1b37a98dbbe87ae4b2d81bad8fdd6d4301e4bf..9f408f850d9f09d500a3a5f933222893e14f8431 100644
--- a/ios/Tests/BlobConvertiblesSpec.swift
+++ b/ios/Tests/BlobConvertiblesSpec.swift
@@ -14,10 +14,11 @@ final class DataUint8ArrayConvertiblesSpec: ExpoSpec {
     }
 
     it("should support sync function") {
-      let isUint8Array = try runtime
+      let isUint8Array =
+        try runtime
         .eval([
           "result = expo.modules.BlobModule.echoSync(new Uint8Array([0x00, 0xff]))",
-          "result instanceof Uint8Array"
+          "result instanceof Uint8Array",
         ])
         .asBool()
       expect(isUint8Array) == true
@@ -28,10 +29,11 @@ final class DataUint8ArrayConvertiblesSpec: ExpoSpec {
     }
 
     it("should support sync function for dict") {
-      let isUint8Array = try runtime
+      let isUint8Array =
+        try runtime
         .eval([
           "result = expo.modules.BlobModule.echoMapSync({ key: new Uint8Array([0x00, 0xff]) })",
-          "result.key instanceof Uint8Array"
+          "result.key instanceof Uint8Array",
         ])
         .asBool()
       expect(isUint8Array) == true
@@ -46,7 +48,8 @@ final class DataUint8ArrayConvertiblesSpec: ExpoSpec {
         .eval(
           "expo.modules.BlobModule.echoAsync(new Uint8Array([0x00, 0xff])).then((result) => { globalThis.result = result; })"
         )
-      expect(try runtime.eval("globalThis.result instanceof Uint8Array").getBool()).toEventually(beTrue())
+      expect(try runtime.eval("globalThis.result instanceof Uint8Array").getBool()).toEventually(
+        beTrue())
       let array = try runtime.eval("Array.from(globalThis.result)").asArray()
       expect(array[0]?.getInt()) == 0x00
       expect(array[1]?.getInt()) == 0xff
@@ -57,7 +60,10 @@ final class DataUint8ArrayConvertiblesSpec: ExpoSpec {
         .eval(
           "expo.modules.BlobModule.echoMapAsync({ key: new Uint8Array([0x00, 0xff]) }).then((result) => { globalThis.result = result; })"
         )
-      expect(try runtime.eval("globalThis.result != null && globalThis.result.key instanceof Uint8Array").getBool()).toEventually(beTrue())
+      expect(
+        try runtime.eval("globalThis.result != null && globalThis.result.key instanceof Uint8Array")
+          .getBool()
+      ).toEventually(beTrue())
       let array = try runtime.eval("Array.from(globalThis.result.key)").asArray()
       expect(array[0]?.getInt()) == 0x00
       expect(array[1]?.getInt()) == 0xff
diff --git a/ios/Tests/ClassDefinitionSpec.swift b/ios/Tests/ClassDefinitionSpec.swift
index 50e47d019d000a85ac35170f20edc13053a163b5..8e1e3e0ad0e844711034745ba1c4b5044193baeb 100644
--- a/ios/Tests/ClassDefinitionSpec.swift
+++ b/ios/Tests/ClassDefinitionSpec.swift
@@ -82,9 +82,11 @@ class ClassDefinitionSpec: ExpoSpec {
       }
 
       it("has keys in prototype") {
-        let prototypeKeys = try runtime.eval("Object.keys(expo.modules.ClassTest.MyClass.prototype)")
-          .getArray()
-          .map { $0.getString() }
+        let prototypeKeys = try runtime.eval(
+          "Object.keys(expo.modules.ClassTest.MyClass.prototype)"
+        )
+        .getArray()
+        .map { $0.getString() }
 
         expect(prototypeKeys).to(contain("myFunction"))
         expect(prototypeKeys).notTo(contain("__native_constructor__"))
@@ -174,7 +176,7 @@ class ClassDefinitionSpec: ExpoSpec {
         let initialValue = Int.random(in: 1..<100)
         let value = try runtime.eval([
           "object = new expo.modules.TestModule.Counter(\(initialValue))",
-          "object.currentValue"
+          "object.currentValue",
         ])
 
         expect(value.kind) == .number
@@ -192,10 +194,8 @@ class ClassDefinitionSpec: ExpoSpec {
   }
 }
 
-/**
- A module that exposes a Counter class with an associated shared object class.
- */
-fileprivate final class ModuleWithCounterClass: Module {
+/// A module that exposes a Counter class with an associated shared object class.
+private final class ModuleWithCounterClass: Module {
   func definition() -> ModuleDefinition {
     Name("TestModule")
 
@@ -221,10 +221,8 @@ fileprivate final class ModuleWithCounterClass: Module {
   }
 }
 
-/**
- A shared object class that stores some native value and can be used as an associated type of the JS class.
- */
-fileprivate final class Counter: SharedObject {
+/// A shared object class that stores some native value and can be used as an associated type of the JS class.
+private final class Counter: SharedObject {
   var currentValue = 0
 
   init(initialValue: Int = 0) {
diff --git a/ios/Tests/ConvertiblesSpec.swift b/ios/Tests/ConvertiblesSpec.swift
index 77f72626834c9f02c07ee6ae356f624800b2115d..5d9dd1dafa84ff930715d627c14e89e8ebc7cc48 100644
--- a/ios/Tests/ConvertiblesSpec.swift
+++ b/ios/Tests/ConvertiblesSpec.swift
@@ -45,7 +45,7 @@ class ConvertiblesSpec: ExpoSpec {
         expect(url.absoluteString) == urlString
         expect(url.absoluteString.removingPercentEncoding) == "https://expo.dev/?param=🥓"
       }
-      
+
       it("converts from url with encoded query containg the anchor") {
         let query = "color=%230000ff"
         let urlString = "https://expo.dev/?\(query)#anchor"
@@ -53,12 +53,13 @@ class ConvertiblesSpec: ExpoSpec {
 
         expect(url.query) == query
         expect(url.absoluteString) == urlString
-        expect(url.absoluteString.removingPercentEncoding) == "https://expo.dev/?color=#0000ff#anchor"
+        expect(url.absoluteString.removingPercentEncoding)
+          == "https://expo.dev/?color=#0000ff#anchor"
         expect(url.fragment) == "anchor"
       }
 
       it("converts from url with encoded path") {
-        let path = "/expo/%2F%25%3F%5E%26/test" // -> /expo//%?^&/test
+        let path = "/expo/%2F%25%3F%5E%26/test"  // -> /expo//%?^&/test
         let urlString = "https://expo.dev\(path)"
         let url = try URL.convert(from: urlString, appContext: appContext)
 
@@ -146,7 +147,7 @@ class ConvertiblesSpec: ExpoSpec {
         expect(point.y) == y
       }
 
-      it("throws when array size is unexpected") { // different than two
+      it("throws when array size is unexpected") {  // different than two
         expect { try CGPoint.convert(from: [], appContext: appContext) }.to(
           throwError(errorType: Conversions.ConvertingException<CGPoint>.self)
         )
@@ -159,17 +160,21 @@ class ConvertiblesSpec: ExpoSpec {
       }
 
       it("throws when dict is missing some keys") {
-        expect { try CGPoint.convert(from: ["test": x], appContext: appContext) }.to(throwError {
-          expect($0).to(beAKindOf(Conversions.MissingKeysException<Double>.self))
-          expect(($0 as! CodedError).description) == Conversions.MissingKeysException<Double>(["x", "y"]).description
-        })
+        expect { try CGPoint.convert(from: ["test": x], appContext: appContext) }.to(
+          throwError {
+            expect($0).to(beAKindOf(Conversions.MissingKeysException<Double>.self))
+            expect(($0 as! CodedError).description)
+              == Conversions.MissingKeysException<Double>(["x", "y"]).description
+          })
       }
 
       it("throws when dict has uncastable keys") {
-        expect { try CGPoint.convert(from: ["x": x, "y": "string"], appContext: appContext) }.to(throwError {
-          expect($0).to(beAKindOf(Conversions.CastingValuesException<Double>.self))
-          expect(($0 as! CodedError).description) == Conversions.CastingValuesException<Double>(["y"]).description
-        })
+        expect { try CGPoint.convert(from: ["x": x, "y": "string"], appContext: appContext) }.to(
+          throwError {
+            expect($0).to(beAKindOf(Conversions.CastingValuesException<Double>.self))
+            expect(($0 as! CodedError).description)
+              == Conversions.CastingValuesException<Double>(["y"]).description
+          })
       }
     }
 
@@ -185,13 +190,14 @@ class ConvertiblesSpec: ExpoSpec {
       }
 
       it("converts from dict") {
-        let size = try CGSize.convert(from: ["width": width, "height": height], appContext: appContext)
+        let size = try CGSize.convert(
+          from: ["width": width, "height": height], appContext: appContext)
 
         expect(size.width) == width
         expect(size.height) == height
       }
 
-      it("throws when array size is unexpected") { // different than two
+      it("throws when array size is unexpected") {  // different than two
         expect { try CGSize.convert(from: [], appContext: appContext) }.to(
           throwError(errorType: Conversions.ConvertingException<CGSize>.self)
         )
@@ -204,17 +210,23 @@ class ConvertiblesSpec: ExpoSpec {
       }
 
       it("throws when dict is missing some keys") {
-        expect { try CGSize.convert(from: ["width": width], appContext: appContext) }.to(throwError {
-          expect($0).to(beAKindOf(Conversions.MissingKeysException<Double>.self))
-          expect(($0 as! CodedError).description) == Conversions.MissingKeysException<Double>(["height"]).description
-        })
+        expect { try CGSize.convert(from: ["width": width], appContext: appContext) }.to(
+          throwError {
+            expect($0).to(beAKindOf(Conversions.MissingKeysException<Double>.self))
+            expect(($0 as! CodedError).description)
+              == Conversions.MissingKeysException<Double>(["height"]).description
+          })
       }
 
       it("throws when dict has uncastable keys") {
-        expect { try CGSize.convert(from: ["width": "test", "height": height], appContext: appContext) }.to(throwError {
-          expect($0).to(beAKindOf(Conversions.CastingValuesException<Double>.self))
-          expect(($0 as! CodedError).description) == Conversions.CastingValuesException<Double>(["width"]).description
-        })
+        expect {
+          try CGSize.convert(from: ["width": "test", "height": height], appContext: appContext)
+        }.to(
+          throwError {
+            expect($0).to(beAKindOf(Conversions.CastingValuesException<Double>.self))
+            expect(($0 as! CodedError).description)
+              == Conversions.CastingValuesException<Double>(["width"]).description
+          })
       }
     }
 
@@ -236,7 +248,7 @@ class ConvertiblesSpec: ExpoSpec {
         expect(vector.dy) == dy
       }
 
-      it("throws when array size is unexpected") { // different than two
+      it("throws when array size is unexpected") {  // different than two
         expect { try CGVector.convert(from: [], appContext: appContext) }.to(
           throwError(errorType: Conversions.ConvertingException<CGVector>.self)
         )
@@ -249,17 +261,21 @@ class ConvertiblesSpec: ExpoSpec {
       }
 
       it("throws when dict is missing some keys") {
-        expect { try CGVector.convert(from: ["dx": dx], appContext: appContext) }.to(throwError {
-          expect($0).to(beAKindOf(Conversions.MissingKeysException<Double>.self))
-          expect(($0 as! CodedError).description) == Conversions.MissingKeysException<Double>(["dy"]).description
-        })
+        expect { try CGVector.convert(from: ["dx": dx], appContext: appContext) }.to(
+          throwError {
+            expect($0).to(beAKindOf(Conversions.MissingKeysException<Double>.self))
+            expect(($0 as! CodedError).description)
+              == Conversions.MissingKeysException<Double>(["dy"]).description
+          })
       }
 
       it("throws when dict has uncastable keys") {
-        expect { try CGVector.convert(from: ["dx": "dx", "dy": dy], appContext: appContext) }.to(throwError {
-          expect($0).to(beAKindOf(Conversions.CastingValuesException<Double>.self))
-          expect(($0 as! CodedError).description) == Conversions.CastingValuesException<Double>(["dx"]).description
-        })
+        expect { try CGVector.convert(from: ["dx": "dx", "dy": dy], appContext: appContext) }.to(
+          throwError {
+            expect($0).to(beAKindOf(Conversions.CastingValuesException<Double>.self))
+            expect(($0 as! CodedError).description)
+              == Conversions.CastingValuesException<Double>(["dx"]).description
+          })
       }
     }
 
@@ -279,7 +295,8 @@ class ConvertiblesSpec: ExpoSpec {
       }
 
       it("converts from dict") {
-        let rect = try CGRect.convert(from: ["x": x, "y": y, "width": width, "height": height], appContext: appContext)
+        let rect = try CGRect.convert(
+          from: ["x": x, "y": y, "width": width, "height": height], appContext: appContext)
 
         expect(rect.origin.x) == x
         expect(rect.origin.y) == y
@@ -287,7 +304,7 @@ class ConvertiblesSpec: ExpoSpec {
         expect(rect.height) == height
       }
 
-      it("throws when array size is unexpected") { // different than four
+      it("throws when array size is unexpected") {  // different than four
         expect { try CGRect.convert(from: [x], appContext: appContext) }.to(
           throwError(errorType: Conversions.ConvertingException<CGRect>.self)
         )
@@ -300,37 +317,48 @@ class ConvertiblesSpec: ExpoSpec {
       }
 
       it("throws when dict is missing some keys") {
-        expect { try CGRect.convert(from: ["x": x], appContext: appContext) }.to(throwError {
-          expect($0).to(beAKindOf(Conversions.MissingKeysException<Double>.self))
-          expect(($0 as! CodedError).description) == Conversions.MissingKeysException<Double>(["y", "width", "height"]).description
-        })
+        expect { try CGRect.convert(from: ["x": x], appContext: appContext) }.to(
+          throwError {
+            expect($0).to(beAKindOf(Conversions.MissingKeysException<Double>.self))
+            expect(($0 as! CodedError).description)
+              == Conversions.MissingKeysException<Double>(["y", "width", "height"]).description
+          })
       }
 
       it("throws when dict has uncastable keys") {
-        expect { try CGRect.convert(from: ["x": x, "y": nil, "width": width, "height": "\(height)"], appContext: appContext) }.to(throwError {
-          expect($0).to(beAKindOf(Conversions.CastingValuesException<Double>.self))
-          expect(($0 as! CodedError).description) == Conversions.CastingValuesException<Double>(["y", "height"]).description
-        })
+        expect {
+          try CGRect.convert(
+            from: ["x": x, "y": nil, "width": width, "height": "\(height)"], appContext: appContext)
+        }.to(
+          throwError {
+            expect($0).to(beAKindOf(Conversions.CastingValuesException<Double>.self))
+            expect(($0 as! CodedError).description)
+              == Conversions.CastingValuesException<Double>(["y", "height"]).description
+          })
       }
     }
 
     describe("UIColor/CGColor") {
-      func testColorComponents(_ color: CGColor, _ red: CGFloat, _ green: CGFloat, _ blue: CGFloat, _ alpha: CGFloat) {
-        expect(color.components?[0]) == red   / 255.0
+      func testColorComponents(
+        _ color: CGColor, _ red: CGFloat, _ green: CGFloat, _ blue: CGFloat, _ alpha: CGFloat
+      ) {
+        expect(color.components?[0]) == red / 255.0
         expect(color.components?[1]) == green / 255.0
-        expect(color.components?[2]) == blue  / 255.0
+        expect(color.components?[2]) == blue / 255.0
         expect(color.components?[3]) == alpha / 255.0
       }
       func testInvalidHexColor(_ hex: String) {
-        expect { try CGColor.convert(from: hex, appContext: appContext) }.to(throwError {
-          expect($0).to(beAKindOf(Conversions.InvalidHexColorException.self))
-          expect(($0 as! CodedError).description) == Conversions.InvalidHexColorException(hex).description
-        })
+        expect { try CGColor.convert(from: hex, appContext: appContext) }.to(
+          throwError {
+            expect($0).to(beAKindOf(Conversions.InvalidHexColorException.self))
+            expect(($0 as! CodedError).description)
+              == Conversions.InvalidHexColorException(hex).description
+          })
       }
 
       it("converts from ARGB int") {
         // NOTE: int representation has alpha channel at the beginning
-        let color = try CGColor.convert(from: 0x5147AC7F, appContext: appContext)
+        let color = try CGColor.convert(from: 0x5147_AC7F, appContext: appContext)
         testColorComponents(color, 0x47, 0xAC, 0x7F, 0x51)
       }
 
@@ -363,19 +391,24 @@ class ConvertiblesSpec: ExpoSpec {
         let transparent = try CGColor.convert(from: "transparent", appContext: appContext)
         expect(transparent.alpha) == .zero
       }
-      
+
       it("converts from PlatformColor") {
-        let color = try CGColor.convert(from: ["semantic": ["invalid_color", "systemRed", "systemBlue"]], appContext: appContext)
+        let color = try CGColor.convert(
+          from: ["semantic": ["invalid_color", "systemRed", "systemBlue"]], appContext: appContext)
         expect(color) == UIColor.systemRed.cgColor
       }
-      
+
       it("converts from DynamicColorIOS") {
-        let color = try CGColor.convert(from: ["dynamic": ["light": "#000", "dark": ["semantic": "systemGray"]]], appContext: appContext)
+        let color = try CGColor.convert(
+          from: ["dynamic": ["light": "#000", "dark": ["semantic": "systemGray"]]],
+          appContext: appContext)
         testColorComponents(color, 0x00, 0x00, 0x00, 0xFF)
       }
-      
+
       it("converts from DynamicColorIOS with traits") {
-        let color = try UIColor.convert(from: ["dynamic": ["light": "#000", "dark": ["semantic": "systemGray"]]], appContext: appContext)
+        let color = try UIColor.convert(
+          from: ["dynamic": ["light": "#000", "dark": ["semantic": "systemGray"]]],
+          appContext: appContext)
         let traits = UITraitCollection(userInterfaceStyle: .dark)
         expect(color.resolvedColor(with: traits)) == UIColor.systemGray.resolvedColor(with: traits)
       }
@@ -390,14 +423,16 @@ class ConvertiblesSpec: ExpoSpec {
       }
 
       it("throws when int overflows") {
-        let hex = 0xBBAA88FF2
-        expect { try CGColor.convert(from: hex, appContext: appContext) }.to(throwError {
-          expect($0).to(beAKindOf(Conversions.HexColorOverflowException.self))
-          expect(($0 as! CodedError).description) == Conversions.HexColorOverflowException(UInt64(hex)).description
-        })
+        let hex = 0xB_BAA8_8FF2
+        expect { try CGColor.convert(from: hex, appContext: appContext) }.to(
+          throwError {
+            expect($0).to(beAKindOf(Conversions.HexColorOverflowException.self))
+            expect(($0 as! CodedError).description)
+              == Conversions.HexColorOverflowException(UInt64(hex)).description
+          })
       }
     }
-    
+
     describe("Date") {
       it("converts from `ISO 8601` String to Date") {
         let date = try Date.convert(from: "2023-12-27T10:58:20.654Z", appContext: appContext)
@@ -405,12 +440,13 @@ class ConvertiblesSpec: ExpoSpec {
         expect(components.month) == 12
         expect(components.day) == 27
       }
-      
+
       it("converts from `Date.now()` to Date") {
-        let date = try Date.convert(from: 1703718341639, appContext: appContext)
+        let date = try Date.convert(from: 1_703_718_341_639, appContext: appContext)
         // The current calendar uses the local timezone, so basically the `day` component
         // could differ depending on the current timezone. Set it to GMT for correctness.
-        let components = Calendar.current.dateComponents(in: TimeZone(abbreviation: "GMT")!, from: date)
+        let components = Calendar.current.dateComponents(
+          in: TimeZone(abbreviation: "GMT")!, from: date)
 
         expect(components.month) == 12
         expect(components.day) == 27
diff --git a/ios/Tests/DynamicEitherTypeSpec.swift b/ios/Tests/DynamicEitherTypeSpec.swift
index 78cdd2074346820c46415a543cf29d056133d0e2..7d29636b00f256c5e1e46d8dcc4e7b9e8c71f0f7 100644
--- a/ios/Tests/DynamicEitherTypeSpec.swift
+++ b/ios/Tests/DynamicEitherTypeSpec.swift
@@ -14,18 +14,25 @@ final class DynamicEitherTypeSpec: ExpoSpec {
     }
 
     it("converts from raw values") {
-      let either1 = try (~Either<Int, String>.self).cast(123, appContext: appContext) as! Either<Int, String>
+      let either1 =
+        try (~Either<Int, String>.self).cast(123, appContext: appContext) as! Either<Int, String>
       expect(try either1.as(Int.self)) == 123
 
-      let either2 = try (~Either<Int, String>.self).cast("expo", appContext: appContext) as! Either<Int, String>
+      let either2 =
+        try (~Either<Int, String>.self).cast("expo", appContext: appContext) as! Either<Int, String>
       expect(try either2.as(String.self)) == "expo"
     }
 
     it("converts from JS values") {
-      let either1 = try (~Either<Int, String>.self).cast(jsValue: .number(123), appContext: appContext) as! Either<Int, String>
+      let either1 =
+        try (~Either<Int, String>.self).cast(jsValue: .number(123), appContext: appContext)
+        as! Either<Int, String>
       expect(try either1.as(Int.self)) == 123
 
-      let either2 = try (~Either<Int, String>.self).cast(jsValue: .string("expo", runtime: runtime), appContext: appContext) as! Either<Int, String>
+      let either2 =
+        try (~Either<Int, String>.self).cast(
+          jsValue: .string("expo", runtime: runtime), appContext: appContext)
+        as! Either<Int, String>
       expect(try either2.as(String.self)) == "expo"
     }
 
@@ -33,18 +40,24 @@ final class DynamicEitherTypeSpec: ExpoSpec {
       expect({ try (~Either<String, Int>.self).cast(true, appContext: appContext) })
         .to(throwError(errorType: NeitherTypeException.self))
 
-      expect({ try (~Either<String, Bool>.self).cast(jsValue: .number(100), appContext: appContext) })
-        .to(throwError(errorType: NeitherTypeException.self))
+      expect({
+        try (~Either<String, Bool>.self).cast(jsValue: .number(100), appContext: appContext)
+      })
+      .to(throwError(errorType: NeitherTypeException.self))
 
       expect({ try (~EitherOfThree<String, Int, Double>.self).cast(false, appContext: appContext) })
         .to(throwError(errorType: NeitherTypeException.self))
 
-      expect({ try (~EitherOfFour<String, Int, Double, Bool>.self).cast([1, 2], appContext: appContext) })
-        .to(throwError(errorType: NeitherTypeException.self))
+      expect({
+        try (~EitherOfFour<String, Int, Double, Bool>.self).cast([1, 2], appContext: appContext)
+      })
+      .to(throwError(errorType: NeitherTypeException.self))
     }
 
     it("supports arrays") {
-      let either = try (~Either<String, [String]>.self).cast(["foo"], appContext: appContext) as! Either<String, [String]>
+      let either =
+        try (~Either<String, [String]>.self).cast(["foo"], appContext: appContext)
+        as! Either<String, [String]>
       let value: [String]? = either.get()
 
       expect(either.is([String].self)) == true
@@ -52,7 +65,9 @@ final class DynamicEitherTypeSpec: ExpoSpec {
     }
 
     it("supports convertibles (UIColor)") {
-      let either = try (~Either<Int, UIColor>.self).cast("blue", appContext: appContext) as! Either<Int, UIColor>
+      let either =
+        try (~Either<Int, UIColor>.self).cast("blue", appContext: appContext)
+        as! Either<Int, UIColor>
       let color: UIColor? = either.get()
 
       expect(either.is(Int.self)) == false
@@ -65,7 +80,9 @@ final class DynamicEitherTypeSpec: ExpoSpec {
         @Field
         var foo: String
       }
-      let either = try (~Either<String, TestRecord>.self).cast(["foo": "bar"], appContext: appContext) as! Either<String, TestRecord>
+      let either =
+        try (~Either<String, TestRecord>.self).cast(["foo": "bar"], appContext: appContext)
+        as! Either<String, TestRecord>
       let record: TestRecord? = either.get()
 
       expect(either.is(String.self)) == false
@@ -79,10 +96,13 @@ final class DynamicEitherTypeSpec: ExpoSpec {
       let nativeObject = TestSharedObject()
 
       // Register a pair of objects
-      _ = appContext.sharedObjectRegistry.createSharedJavaScriptObject(runtime: runtime, nativeObject: nativeObject)
+      _ = appContext.sharedObjectRegistry.createSharedJavaScriptObject(
+        runtime: runtime, nativeObject: nativeObject)
 
       // TODO: We should test with JS value, but currently we have no way to convert JavaScriptObject to JavaScriptValue
-      let either = try (~Either<TestSharedObject, String>.self).cast(nativeObject.sharedObjectId, appContext: appContext) as! Either<TestSharedObject, String>
+      let either =
+        try (~Either<TestSharedObject, String>.self).cast(
+          nativeObject.sharedObjectId, appContext: appContext) as! Either<TestSharedObject, String>
 
       expect(either.is(TestSharedObject.self)) == true
       expect(either.is(String.self)) == false
@@ -90,4 +110,3 @@ final class DynamicEitherTypeSpec: ExpoSpec {
     }
   }
 }
-
diff --git a/ios/Tests/DynamicTypeSpec.swift b/ios/Tests/DynamicTypeSpec.swift
index 6b8a5e2f1e9825e06929c17d8fec5259532ca4c7..4ec15767ad10212757955e1556a52b650f47dca4 100644
--- a/ios/Tests/DynamicTypeSpec.swift
+++ b/ios/Tests/DynamicTypeSpec.swift
@@ -80,7 +80,8 @@ final class DynamicTypeSpec: ExpoSpec {
         // float literal (Double) -> Double
         expect(try (~Double.self).cast(3.14, appContext: appContext) as? Double) == 3.14
         // Float64 -> Float64
-        expect(try (~Float64.self).cast(Float64(1.61), appContext: appContext) as? Float64) == Float64(1.61)
+        expect(try (~Float64.self).cast(Float64(1.61), appContext: appContext) as? Float64)
+          == Float64(1.61)
       }
       it("casts from different numeric type") {
         // integer literal (Int) -> Int64
@@ -93,7 +94,8 @@ final class DynamicTypeSpec: ExpoSpec {
         expect(try (~Float64.self).cast(6.6, appContext: appContext) as? Float64) == Float64(6.6)
       }
       it("casts from JS value") {
-        expect(try (~Double.self).cast(jsValue: .number(12.34), appContext: appContext) as? Double) == 12.34
+        expect(try (~Double.self).cast(jsValue: .number(12.34), appContext: appContext) as? Double)
+          == 12.34
         expect(try (~Int.self).cast(jsValue: .number(0.8), appContext: appContext) as? Int) == 1
       }
     }
@@ -108,7 +110,9 @@ final class DynamicTypeSpec: ExpoSpec {
         expect(try (~String.self).cast("foo", appContext: appContext) as? String) == "foo"
       }
       it("casts from JS value") {
-        expect(try (~String.self).cast(jsValue: .string("bar", runtime: runtime), appContext: appContext) as? String) == "bar"
+        expect(
+          try (~String.self).cast(jsValue: .string("bar", runtime: runtime), appContext: appContext)
+            as? String) == "bar"
       }
     }
 
@@ -122,8 +126,12 @@ final class DynamicTypeSpec: ExpoSpec {
       }
       describe("casts") {
         it("succeeds") {
-          expect(try (~[Double].self).cast([1.2, 3.4], appContext: appContext) as? [Double]) == [1.2, 3.4]
-          expect(try (~[[String]].self).cast([["hello", "expo"]], appContext: appContext) as? [[String]]) == [["hello", "expo"]]
+          expect(try (~[Double].self).cast([1.2, 3.4], appContext: appContext) as? [Double]) == [
+            1.2, 3.4,
+          ]
+          expect(
+            try (~[[String]].self).cast([["hello", "expo"]], appContext: appContext) as? [[String]])
+            == [["hello", "expo"]]
         }
         it("casts arrays") {
           let value = 9.9
@@ -137,7 +145,8 @@ final class DynamicTypeSpec: ExpoSpec {
           // The dynamic array type can arrayize the single element
           // if only the array element's dynamic type can cast it.
           expect(try (~[Int].self).cast(50, appContext: appContext) as? [Int]) == [50]
-          expect(try (~[String].self).cast("not an array", appContext: appContext) as? [String]) == ["not an array"]
+          expect(try (~[String].self).cast("not an array", appContext: appContext) as? [String])
+            == ["not an array"]
         }
         it("throws CastingException") {
           expect { try (~[String].self).cast(84, appContext: appContext) }.to(
@@ -181,9 +190,13 @@ final class DynamicTypeSpec: ExpoSpec {
       }
       describe("casts") {
         it("succeeds") {
-          expect(try (~CGPoint.self).cast([2.1, 3.7], appContext: appContext) as? CGPoint) == CGPoint(x: 2.1, y: 3.7)
-          expect(try (~CGVector.self).cast(["dx": 0.8, "dy": 4.1], appContext: appContext) as? CGVector) == CGVector(dx: 0.8, dy: 4.1)
-          expect(try (~URL.self).cast("/test/path", appContext: appContext) as? URL) == URL(fileURLWithPath: "/test/path")
+          expect(try (~CGPoint.self).cast([2.1, 3.7], appContext: appContext) as? CGPoint)
+            == CGPoint(x: 2.1, y: 3.7)
+          expect(
+            try (~CGVector.self).cast(["dx": 0.8, "dy": 4.1], appContext: appContext) as? CGVector)
+            == CGVector(dx: 0.8, dy: 4.1)
+          expect(try (~URL.self).cast("/test/path", appContext: appContext) as? URL)
+            == URL(fileURLWithPath: "/test/path")
         }
         it("throws ConvertingException") {
           expect { try (~CGRect.self).cast("not a rect", appContext: appContext) as? CGRect }.to(
@@ -235,18 +248,24 @@ final class DynamicTypeSpec: ExpoSpec {
       }
       describe("casts") {
         it("succeeds") {
-          expect(try (~StringTestEnum.self).cast("expo", appContext: appContext) as? StringTestEnum) == .expo
-          expect(try (~IntTestEnum.self).cast(1, appContext: appContext) as? IntTestEnum) == .positive
+          expect(try (~StringTestEnum.self).cast("expo", appContext: appContext) as? StringTestEnum)
+            == .expo
+          expect(try (~IntTestEnum.self).cast(1, appContext: appContext) as? IntTestEnum)
+            == .positive
         }
         it("throws EnumNoSuchValueException") {
-          expect { try (~StringTestEnum.self).cast("react native", appContext: appContext) as? StringTestEnum }.to(
+          expect {
+            try (~StringTestEnum.self).cast("react native", appContext: appContext)
+              as? StringTestEnum
+          }.to(
             throwError(errorType: EnumNoSuchValueException.self)
           )
         }
         it("throws EnumCastingException") {
-          expect { try (~IntTestEnum.self).cast(true, appContext: appContext) as? StringTestEnum }.to(
-            throwError(errorType: EnumCastingException.self)
-          )
+          expect { try (~IntTestEnum.self).cast(true, appContext: appContext) as? StringTestEnum }
+            .to(
+              throwError(errorType: EnumCastingException.self)
+            )
         }
       }
       describe("wraps") {
@@ -348,14 +367,20 @@ final class DynamicTypeSpec: ExpoSpec {
           let nativeObject = TestSharedObject()
           let jsObjectValue = try appContext.runtime.eval("({})")
 
-          appContext.sharedObjectRegistry.add(native: nativeObject, javaScript: try jsObjectValue.asObject())
+          appContext.sharedObjectRegistry.add(
+            native: nativeObject, javaScript: try jsObjectValue.asObject())
 
           // `DynamicSharedObjectType` only supports casting
           // from `JavaScriptValue`, but not from `JavaScriptObject`.
-          expect(try (~TestSharedObject.self).cast(jsValue: jsObjectValue, appContext: appContext) as? TestSharedObject) === nativeObject
+          expect(
+            try (~TestSharedObject.self).cast(jsValue: jsObjectValue, appContext: appContext)
+              as? TestSharedObject) === nativeObject
         }
         it("throws NativeSharedObjectNotFoundException") {
-          expect { try (~TestSharedObject.self).cast("a string", appContext: appContext) as? TestSharedObject }.to(
+          expect {
+            try (~TestSharedObject.self).cast("a string", appContext: appContext)
+              as? TestSharedObject
+          }.to(
             throwError(errorType: NativeSharedObjectNotFoundException.self)
           )
         }
@@ -392,10 +417,14 @@ final class DynamicTypeSpec: ExpoSpec {
 
       describe("casts") {
         it("succeeds") {
-          let either1 = try (~Either<Int, String>.self).cast(123, appContext: appContext) as! Either<Int, String>
+          let either1 =
+            try (~Either<Int, String>.self).cast(123, appContext: appContext)
+            as! Either<Int, String>
           expect(try either1.as(Int.self)) == 123
 
-          let either2 = try (~Either<Int, String>.self).cast("expo", appContext: appContext) as! Either<Int, String>
+          let either2 =
+            try (~Either<Int, String>.self).cast("expo", appContext: appContext)
+            as! Either<Int, String>
           expect(try either2.as(String.self)) == "expo"
         }
       }
diff --git a/ios/Tests/EventEmitterSpec.swift b/ios/Tests/EventEmitterSpec.swift
index f62522be2ef9c6b27258fbece47c059d6ae0daf4..59603446a42f4d1abc6f0cf964bd15b613a2c0b7 100644
--- a/ios/Tests/EventEmitterSpec.swift
+++ b/ios/Tests/EventEmitterSpec.swift
@@ -37,7 +37,7 @@ final class EventEmitterSpec: ExpoSpec {
           "result = null",
           "emitter.addListener('test', payload => { result = payload })",
           "emitter.emit('test', 'it\\'s a payload')",
-          "result"
+          "result",
         ])
         expect(result.kind) == .string
         expect(try result.asString()) == "it's a payload"
@@ -51,7 +51,7 @@ final class EventEmitterSpec: ExpoSpec {
           "emitter.addListener('test', listener)",
           "emitter.removeListener('test', listener)",
           "emitter.emit('test')",
-          "result"
+          "result",
         ])
         expect(result.kind) == .null
       }
@@ -64,19 +64,20 @@ final class EventEmitterSpec: ExpoSpec {
           "emitter.addListener('test', () => { result = 2 })",
           "emitter.removeAllListeners('test')",
           "emitter.emit('test')",
-          "result"
+          "result",
         ])
         expect(result.kind) == .null
       }
 
       it("emits with multiple arguments") {
-        let args = try runtime
+        let args =
+          try runtime
           .eval([
             "emitter = new expo.EventEmitter()",
             "result = null",
             "emitter.addListener('test', (a, b, c) => { result = [a, b, c] })",
             "emitter.emit('test', 14, 2, 24)",
-            "result"
+            "result",
           ])
           .asArray()
           .compactMap({ try $0?.asInt() })
@@ -92,7 +93,7 @@ final class EventEmitterSpec: ExpoSpec {
           "emitter = new expo.EventEmitter()",
           "emitter.addListener('test', () => {})",
           "emitter.addListener('test', () => {})",
-          "emitter.listenerCount('test')"
+          "emitter.listenerCount('test')",
         ])
         expect(listenerCount.kind) == .number
         expect(try listenerCount.asInt()) == 2
@@ -101,7 +102,7 @@ final class EventEmitterSpec: ExpoSpec {
       it("returns listener count without any listeners") {
         let listenerCount = try runtime.eval([
           "emitter = new expo.EventEmitter()",
-          "emitter.listenerCount('test')"
+          "emitter.listenerCount('test')",
         ])
         expect(listenerCount.kind) == .number
         expect(try listenerCount.asInt()) == 0
@@ -113,7 +114,7 @@ final class EventEmitterSpec: ExpoSpec {
           "emitter.addListener('test1', () => {})",
           "emitter.addListener('test1', () => {})",
           "emitter.addListener('test2', () => {})",
-          "emitter.listenerCount('test2')"
+          "emitter.listenerCount('test2')",
         ])
         expect(listenerCount.kind) == .number
         expect(try listenerCount.asInt()) == 1
@@ -124,13 +125,16 @@ final class EventEmitterSpec: ExpoSpec {
         let eventName = "testEvent"
         let listenerA = runtime.createSyncFunction("listenerA") { _, _ in .undefined }
         let listenerB = runtime.createSyncFunction("listenerB") { _, _ in .undefined }
-        let observer = try setupEventObserver(runtime: runtime, functionName: "startObserving") { arguments in
+        let observer = try setupEventObserver(runtime: runtime, functionName: "startObserving") {
+          arguments in
           expect(try arguments.first?.asString()) == eventName
           calls = calls + 1
         }
 
-        observer.addListener.call(withArguments: [eventName, listenerA], thisObject: observer.emitter, asConstructor: false)
-        observer.addListener.call(withArguments: [eventName, listenerB], thisObject: observer.emitter, asConstructor: false)
+        observer.addListener.call(
+          withArguments: [eventName, listenerA], thisObject: observer.emitter, asConstructor: false)
+        observer.addListener.call(
+          withArguments: [eventName, listenerB], thisObject: observer.emitter, asConstructor: false)
 
         expect(calls) == 1
       }
@@ -139,14 +143,18 @@ final class EventEmitterSpec: ExpoSpec {
         var calls: Int = 0
         let eventName = "testEvent"
         let listener = runtime.createSyncFunction("listener") { _, _ in .undefined }
-        let observer = try setupEventObserver(runtime: runtime, functionName: "stopObserving") { arguments in
+        let observer = try setupEventObserver(runtime: runtime, functionName: "stopObserving") {
+          arguments in
           expect(try arguments.first?.asString()) == eventName
           calls = calls + 1
         }
 
-        observer.addListener.call(withArguments: [eventName, listener], thisObject: observer.emitter, asConstructor: false)
-        observer.removeListener.call(withArguments: [eventName, listener], thisObject: observer.emitter, asConstructor: false)
-        observer.removeListener.call(withArguments: [eventName, listener], thisObject: observer.emitter, asConstructor: false)
+        observer.addListener.call(
+          withArguments: [eventName, listener], thisObject: observer.emitter, asConstructor: false)
+        observer.removeListener.call(
+          withArguments: [eventName, listener], thisObject: observer.emitter, asConstructor: false)
+        observer.removeListener.call(
+          withArguments: [eventName, listener], thisObject: observer.emitter, asConstructor: false)
 
         expect(calls) == 1
       }
@@ -155,14 +163,18 @@ final class EventEmitterSpec: ExpoSpec {
         var calls: Int = 0
         let eventName = "testEvent"
         let listener = runtime.createSyncFunction("listener") { _, _ in .undefined }
-        let observer = try setupEventObserver(runtime: runtime, functionName: "stopObserving") { arguments in
+        let observer = try setupEventObserver(runtime: runtime, functionName: "stopObserving") {
+          arguments in
           expect(try arguments.first?.asString()) == eventName
           calls = calls + 1
         }
 
-        observer.addListener.call(withArguments: [eventName, listener], thisObject: observer.emitter, asConstructor: false)
-        observer.removeAllListeners.call(withArguments: [eventName], thisObject: observer.emitter, asConstructor: false)
-        observer.removeAllListeners.call(withArguments: [eventName], thisObject: observer.emitter, asConstructor: false)
+        observer.addListener.call(
+          withArguments: [eventName, listener], thisObject: observer.emitter, asConstructor: false)
+        observer.removeAllListeners.call(
+          withArguments: [eventName], thisObject: observer.emitter, asConstructor: false)
+        observer.removeAllListeners.call(
+          withArguments: [eventName], thisObject: observer.emitter, asConstructor: false)
 
         expect(calls) == 1
       }
@@ -170,7 +182,7 @@ final class EventEmitterSpec: ExpoSpec {
       it("returns a subscription") {
         let subscription = try runtime.eval([
           "emitter = new expo.EventEmitter()",
-          "subscription = emitter.addListener('test', () => {})"
+          "subscription = emitter.addListener('test', () => {})",
         ])
 
         expect(try subscription.asObject().getPropertyNames()).to(contain("remove"))
@@ -184,7 +196,7 @@ final class EventEmitterSpec: ExpoSpec {
           "subscription = emitter.addListener('test', () => { wasCalled = true })",
           "subscription.remove()",
           "emitter.emit('test')",
-          "wasCalled"
+          "wasCalled",
         ])
 
         expect(try wasCalled.asBool()) == false
@@ -198,7 +210,7 @@ final class EventEmitterSpec: ExpoSpec {
           "subscription2 = emitter.addListener('test', () => { counter |= 2 })",
           "subscription1.remove()",
           "emitter.emit('test')",
-          "counter"
+          "counter",
         ])
 
         expect(try counter.asInt()) == 2
@@ -208,7 +220,7 @@ final class EventEmitterSpec: ExpoSpec {
         let emittersAreEqual = try runtime.eval([
           "emitterA = new expo.EventEmitter()",
           "emitterB = new expo.EventEmitter(emitterA)",
-          "emitterA === emitterB"
+          "emitterA === emitterB",
         ])
         expect(try emittersAreEqual.asBool()) == true
       }
@@ -223,7 +235,7 @@ final class EventEmitterSpec: ExpoSpec {
           "emitter.addListener('test', listener)",
           "emitter.addListener('test', () => result |= 2)",
           "emitter.emit('test')",
-          "result"
+          "result",
         ])
         expect(try result.asInt()) == 3
       }
@@ -237,7 +249,7 @@ final class EventEmitterSpec: ExpoSpec {
           "emitter.addListener('test', () => emitter.addListener('test', () => result |= 2))",
           "emitter.addListener('test', () => result |= 4)",
           "emitter.emit('test')",
-          "result"
+          "result",
         ])
         expect(try result.asInt()) == 5
       }
diff --git a/ios/Tests/ExceptionsSpec.swift b/ios/Tests/ExceptionsSpec.swift
index 5f9fe3e8c9e7679f021e50759474707c5ef43eb7..04be96c3cc59792e081d9d79e894bef2316feaef 100644
--- a/ios/Tests/ExceptionsSpec.swift
+++ b/ios/Tests/ExceptionsSpec.swift
@@ -13,17 +13,17 @@ final class ExceptionsSpec: ExpoSpec {
         let error = TestException()
         expect(error.name) == "TestException"
       }
-      
+
       it("has code") {
         let error = TestException()
         expect(error.code) == "ERR_TEST"
       }
-      
+
       it("has reason") {
         let error = TestException()
         expect(error.reason) == "This is the test exception"
       }
-      
+
       it("can be chained once") {
         func throwable() throws {
           do {
@@ -32,11 +32,13 @@ final class ExceptionsSpec: ExpoSpec {
             throw TestException().causedBy(error)
           }
         }
-        expect { try throwable() }.to(throwError { error in
-          testChainedExceptionTypes(error: error, types: [TestException.self, TestExceptionCause.self])
-        })
+        expect { try throwable() }.to(
+          throwError { error in
+            testChainedExceptionTypes(
+              error: error, types: [TestException.self, TestExceptionCause.self])
+          })
       }
-      
+
       it("can be chained twice") {
         func throwable() throws {
           do {
@@ -49,11 +51,14 @@ final class ExceptionsSpec: ExpoSpec {
             throw TestException().causedBy(error)
           }
         }
-        expect { try throwable() }.to(throwError { error in
-          testChainedExceptionTypes(error: error, types: [TestException.self, TestExceptionCause.self, TestExceptionCause.self])
-        })
+        expect { try throwable() }.to(
+          throwError { error in
+            testChainedExceptionTypes(
+              error: error,
+              types: [TestException.self, TestExceptionCause.self, TestExceptionCause.self])
+          })
       }
-      
+
       it("includes cause description") {
         func throwable() throws {
           do {
@@ -62,20 +67,21 @@ final class ExceptionsSpec: ExpoSpec {
             throw TestException().causedBy(error)
           }
         }
-        expect { try throwable() }.to(throwError { error in
-          if let error = error as? TestException, let cause = error.cause as? TestExceptionCause {
-            expect(error.description).to(contain(cause.description))
-          } else {
-            fail("Error and its cause are not of expected types.")
-          }
-        })
+        expect { try throwable() }.to(
+          throwError { error in
+            if let error = error as? TestException, let cause = error.cause as? TestExceptionCause {
+              expect(error.description).to(contain(cause.description))
+            } else {
+              fail("Error and its cause are not of expected types.")
+            }
+          })
       }
-      
+
       it("has root cause") {
         let a = TestException()
         let b = TestException().causedBy(a)
         let c = TestException().causedBy(b)
-        
+
         expect(c.rootCause as! TestException) === a
       }
     }
@@ -84,48 +90,52 @@ final class ExceptionsSpec: ExpoSpec {
       let runtime = try! appContext.runtime
 
       beforeSuite {
-        appContext.moduleRegistry.register(holder: mockModuleHolder(appContext) {
-          Name("TestModule")
+        appContext.moduleRegistry.register(
+          holder: mockModuleHolder(appContext) {
+            Name("TestModule")
 
-          Function("codedException") {
-            throw TestCodedException()
-          }
+            Function("codedException") {
+              throw TestCodedException()
+            }
 
-          AsyncFunction("codedExceptionThrowAsync") { () in
-            throw TestCodedException()
-          }
+            AsyncFunction("codedExceptionThrowAsync") { () in
+              throw TestCodedException()
+            }
 
-          AsyncFunction("codedExceptionRejectAsync") { (promise: Promise) in
-            promise.reject(TestCodedException())
-          }
+            AsyncFunction("codedExceptionRejectAsync") { (promise: Promise) in
+              promise.reject(TestCodedException())
+            }
 
-          AsyncFunction("codedExceptionConcurrentAsync") { () async throws in
-            throw TestCodedException()
-          }
-        })
+            AsyncFunction("codedExceptionConcurrentAsync") { () async throws in
+              throw TestCodedException()
+            }
+          })
       }
 
       it("sync function throw") {
-        let error = try runtime.eval("try { expo.modules.TestModule.codedException() } catch (error) { error }").asObject()
-        expect(error.getProperty("message").getString()).to(contain("FunctionCallException: Calling the 'codedException' function has failed"))
+        let error = try runtime.eval(
+          "try { expo.modules.TestModule.codedException() } catch (error) { error }"
+        ).asObject()
+        expect(error.getProperty("message").getString()).to(
+          contain("FunctionCallException: Calling the 'codedException' function has failed"))
         expect(error.getProperty("code").getString()).to(equal("E_TEST_CODE"))
       }
 
       // TODO: Find a way to evaluate async code
-//      it("async function throw") {
-//        let error = try runtime.eval("try { await expo.modules.TestModule.codedExceptionThrowAsync() } catch (error) { error }").asObject()
-//        expect(error.getProperty("code").getString()).to(equal("E_TEST_CODE"))
-//      }
-
-//      it("async function reject") {
-//        let error = try runtime.eval("try { await expo.modules.TestModule.codedExceptionRejectAsync() } catch (error) { error }").asObject()
-//        expect(error.getProperty("code").getString()).to(equal("E_TEST_CODE"))
-//      }
-
-//      it("async/concurrent function throw") {
-//        let error = try runtime.eval("try { await expo.modules.TestModule.codedExceptionConcurrentAsync() } catch (error) { error }").asObject()
-//        expect(error.getProperty("code").getString()).to(equal("E_TEST_CODE"))
-//      }
+      //      it("async function throw") {
+      //        let error = try runtime.eval("try { await expo.modules.TestModule.codedExceptionThrowAsync() } catch (error) { error }").asObject()
+      //        expect(error.getProperty("code").getString()).to(equal("E_TEST_CODE"))
+      //      }
+
+      //      it("async function reject") {
+      //        let error = try runtime.eval("try { await expo.modules.TestModule.codedExceptionRejectAsync() } catch (error) { error }").asObject()
+      //        expect(error.getProperty("code").getString()).to(equal("E_TEST_CODE"))
+      //      }
+
+      //      it("async/concurrent function throw") {
+      //        let error = try runtime.eval("try { await expo.modules.TestModule.codedExceptionConcurrentAsync() } catch (error) { error }").asObject()
+      //        expect(error.getProperty("code").getString()).to(equal("E_TEST_CODE"))
+      //      }
     }
   }
 }
@@ -144,15 +154,14 @@ class TestExceptionCause: Exception {
 
 class TestCodedException: Exception {
   init() {
-    super.init(name: "TestException",
-               description: "This is a test Exception with a code",
-               code: "E_TEST_CODE")
+    super.init(
+      name: "TestException",
+      description: "This is a test Exception with a code",
+      code: "E_TEST_CODE")
   }
 }
 
-/**
- Tests whether the exception chain matches given types and their order.
- */
+/// Tests whether the exception chain matches given types and their order.
 private func testChainedExceptionTypes(error: Error, types: [Error.Type]) {
   var next: Error? = error
 
@@ -160,7 +169,9 @@ private func testChainedExceptionTypes(error: Error, types: [Error.Type]) {
     let expectedErrorTypeName = String(describing: errorType)
     let currentErrorTypeName = String(describing: type(of: next!))
 
-    expect(currentErrorTypeName).to(equal(expectedErrorTypeName), description: "The cause is not of type \(expectedErrorTypeName)")
+    expect(currentErrorTypeName).to(
+      equal(expectedErrorTypeName), description: "The cause is not of type \(expectedErrorTypeName)"
+    )
 
     if let chainableException = next as? ChainableException {
       next = chainableException.cause
diff --git a/ios/Tests/ExpoModulesSpec.swift b/ios/Tests/ExpoModulesSpec.swift
index 30c63b3dc3404848ad13fc4c23359c05fde8a32b..cf9675f4436346ce8ecf32dce07bf3c05bf484ad 100644
--- a/ios/Tests/ExpoModulesSpec.swift
+++ b/ios/Tests/ExpoModulesSpec.swift
@@ -18,17 +18,18 @@ class ExpoModulesSpec: ExpoSpec {
     ]
 
     beforeSuite {
-      appContext.moduleRegistry.register(holder: mockModuleHolder(appContext) {
-        Name(testModuleName)
+      appContext.moduleRegistry.register(
+        holder: mockModuleHolder(appContext) {
+          Name(testModuleName)
 
-        Constants(constantsDict)
+          Constants(constantsDict)
 
-        Function(testFunctionName) { Double.pi }
+          Function(testFunctionName) { Double.pi }
 
-        Function(throwingFunctionName) {
-          throw exceptionToThrow
-        }
-      })
+          Function(throwingFunctionName) {
+            throw exceptionToThrow
+          }
+        })
     }
 
     describe("host object") {
@@ -67,23 +68,28 @@ class ExpoModulesSpec: ExpoSpec {
       }
 
       it("has function") {
-        expect(try runtime.eval("typeof expo.modules.TestModule.\(testFunctionName)").asString()) == "function"
+        expect(try runtime.eval("typeof expo.modules.TestModule.\(testFunctionName)").asString())
+          == "function"
         expect(try runtime.eval("expo.modules.TestModule.\(testFunctionName)").isFunction()) == true
       }
 
       it("calls function") {
-        expect(try runtime.eval("expo.modules.TestModule.\(testFunctionName)()").asDouble()) == Double.pi
+        expect(try runtime.eval("expo.modules.TestModule.\(testFunctionName)()").asDouble())
+          == Double.pi
       }
 
       it("throws from sync function") {
         // Invoke the throwing function and return the error (eval shouldn't rethrow here)
-        let error = try runtime.eval("try { expo.modules.TestModule.\(throwingFunctionName)() } catch (error) { error }").asObject()
+        let error = try runtime.eval(
+          "try { expo.modules.TestModule.\(throwingFunctionName)() } catch (error) { error }"
+        ).asObject()
 
         // We just check if it contains the description — they won't be equal for the following reasons:
         // - the `exceptionToThrow` is just the root cause, in fact it returns `FunctionCallException`
         // - the debug description contains the file and line number, so it's hard to mock the `FunctionCallException`
         // Ideally if we have a better way (error codes/names) to identify them w/o relying on the description that may change over time.
-        expect(error.getProperty("message").getString()).to(contain(exceptionToThrow.debugDescription))
+        expect(error.getProperty("message").getString()).to(
+          contain(exceptionToThrow.debugDescription))
       }
     }
   }
diff --git a/ios/Tests/ExpoRequestCdpInterceptorSpec.swift b/ios/Tests/ExpoRequestCdpInterceptorSpec.swift
index f3fdcd617453f03ae53858f090fb7606a9ef7222..1b1e4efb6c8518758b02d3fe97f0336c4b8ac05a 100644
--- a/ios/Tests/ExpoRequestCdpInterceptorSpec.swift
+++ b/ios/Tests/ExpoRequestCdpInterceptorSpec.swift
@@ -31,7 +31,7 @@ final class ExpoRequestCdpInterceptorSpec: ExpoSpec {
   private static func parseJSON(data: String) -> [String: Any] {
     var result: [String: Any]?
     if let data = data.data(using: .utf8) {
-        result = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any]
+      result = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any]
     }
     return result ?? [:]
   }
@@ -48,7 +48,9 @@ final class ExpoRequestCdpInterceptorSpec: ExpoSpec {
 
     it("simple json data") {
       waitUntil(timeout: .seconds(2)) { done in
-        self.session.dataTask(with: URL(string: "https://raw.githubusercontent.com/expo/expo/main/package.json")!) { (data, response, error) in
+        self.session.dataTask(
+          with: URL(string: "https://raw.githubusercontent.com/expo/expo/main/package.json")!
+        ) { (data, response, error) in
           DispatchQueue.main.async {
             expect(self.mockDelegate.events.count).to(equal(5))
 
@@ -59,7 +61,8 @@ final class ExpoRequestCdpInterceptorSpec: ExpoSpec {
             let request = params["request"] as! [String: Any]
             let requestId = params["requestId"] as! String
             expect(method).to(equal("Network.requestWillBeSent"))
-            expect(request["url"] as? String).to(equal("https://raw.githubusercontent.com/expo/expo/main/package.json"))
+            expect(request["url"] as? String).to(
+              equal("https://raw.githubusercontent.com/expo/expo/main/package.json"))
 
             // Network.requestWillBeSentExtraInfo
             json = self.parseJSON(data: self.mockDelegate.events[1])
@@ -104,7 +107,8 @@ final class ExpoRequestCdpInterceptorSpec: ExpoSpec {
 
     it("http 302 redirection") {
       waitUntil(timeout: .seconds(2)) { done in
-        self.session.dataTask(with: URL(string: "https://github.com/expo.png")!) { (data, response, error) in
+        self.session.dataTask(with: URL(string: "https://github.com/expo.png")!) {
+          (data, response, error) in
           DispatchQueue.main.async {
             expect(self.mockDelegate.events.count).to(equal(7))
 
@@ -166,7 +170,9 @@ final class ExpoRequestCdpInterceptorSpec: ExpoSpec {
 
     it("respect image mimeType to CDP event") {
       waitUntil(timeout: .seconds(2)) { done in
-        self.session.dataTask(with: URL(string: "https://avatars.githubusercontent.com/u/12504344")!) { (data, response, error) in
+        self.session.dataTask(
+          with: URL(string: "https://avatars.githubusercontent.com/u/12504344")!
+        ) { (data, response, error) in
           DispatchQueue.main.async {
             expect(self.mockDelegate.events.count).to(equal(5))
 
@@ -191,7 +197,12 @@ final class ExpoRequestCdpInterceptorSpec: ExpoSpec {
 
     it("skip `receivedResponseBody` when response size exceeding 1MB limit") {
       waitUntil(timeout: .seconds(5)) { done in
-        self.session.dataTask(with: URL(string: "https://raw.githubusercontent.com/expo/expo/main/apps/native-component-list/assets/videos/ace.mp4")!) { (data, response, error) in
+        self.session.dataTask(
+          with: URL(
+            string:
+              "https://raw.githubusercontent.com/expo/expo/main/apps/native-component-list/assets/videos/ace.mp4"
+          )!
+        ) { (data, response, error) in
           DispatchQueue.main.async {
             expect(self.mockDelegate.events.count).to(equal(4))
 
diff --git a/ios/Tests/FileSystemLegacyUtilitiesSpec.swift b/ios/Tests/FileSystemLegacyUtilitiesSpec.swift
index 1306c3d92c7e27d73b4b132d4b5d18df3cd31ce2..813d1c17098f68df4d6622f99254c343fd2deaf9 100644
--- a/ios/Tests/FileSystemLegacyUtilitiesSpec.swift
+++ b/ios/Tests/FileSystemLegacyUtilitiesSpec.swift
@@ -10,7 +10,8 @@ final class FileSystemLegacyUtilitiesSpec: ExpoSpec {
 
     describe("getPathPermissions") {
       it("should return read/write permissions for filePath with `file:` scheme") {
-        let dirUrl = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask)[0]
+        let dirUrl = FileManager.default.urls(
+          for: .applicationSupportDirectory, in: .userDomainMask)[0]
         let fileUrl = dirUrl.appendingPathComponent("dir/test.txt")
         let filePath = fileUrl.absoluteString
         expect(filePath.starts(with: "file:")) == true
@@ -18,7 +19,8 @@ final class FileSystemLegacyUtilitiesSpec: ExpoSpec {
       }
 
       it("should return read/write permissions for filePath without `file:` scheme") {
-        let dirUrl = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask)[0]
+        let dirUrl = FileManager.default.urls(
+          for: .applicationSupportDirectory, in: .userDomainMask)[0]
         let fileUrl = dirUrl.appendingPathComponent("dir/test.txt")
         let filePath = fileUrl.path
         expect(filePath.starts(with: "file:")) == false
diff --git a/ios/Tests/FunctionSpec.swift b/ios/Tests/FunctionSpec.swift
index e3d1103e6d70b11d1d9540747c3c9d5e50b54d17..898c2692127d63e863d650000b3453199d86869a 100644
--- a/ios/Tests/FunctionSpec.swift
+++ b/ios/Tests/FunctionSpec.swift
@@ -88,7 +88,7 @@ class FunctionSpec: ExpoSpec {
         }
         let dict = [
           "property": "Hello",
-          "propertyWithCustomKey": "Expo!"
+          "propertyWithCustomKey": "Expo!",
         ]
 
         it("converts to simple record when passed as an argument") {
@@ -127,16 +127,21 @@ class FunctionSpec: ExpoSpec {
         }
 
         it("returns the record back (sync)") {
-          let result = try Function(functionName) { (record: TestRecord) in record }
+          let result =
+            try Function(functionName) { (record: TestRecord) in record }
             .call(by: nil, withArguments: [dict], appContext: appContext) as? TestRecord
 
-          guard let result = Conversions.convertFunctionResult(result, appContext: appContext) as? TestRecord.Dict else {
+          guard
+            let result = Conversions.convertFunctionResult(result, appContext: appContext)
+              as? TestRecord.Dict
+          else {
             return fail()
           }
 
           expect(result).notTo(beNil())
           expect(result["property"] as? String).to(equal(dict["property"]))
-          expect(result["propertyWithCustomKey"] as? String).to(equal(dict["propertyWithCustomKey"]))
+          expect(result["propertyWithCustomKey"] as? String).to(
+            equal(dict["propertyWithCustomKey"]))
         }
 
         it("returns the record back (async)") {
@@ -155,7 +160,8 @@ class FunctionSpec: ExpoSpec {
               let valueAsDict = value as! Record.Dict
 
               expect(valueAsDict["property"] as? String).to(equal(dict["property"]))
-              expect(valueAsDict["propertyWithCustomKey"] as? String).to(equal(dict["propertyWithCustomKey"]))
+              expect(valueAsDict["propertyWithCustomKey"] as? String).to(
+                equal(dict["propertyWithCustomKey"]))
               done()
             }
           }
@@ -190,13 +196,17 @@ class FunctionSpec: ExpoSpec {
           return returnedValue
         }
 
-        expect({ (try fn.call(by: nil, withArguments: ["test"], appContext: appContext)) as? String })
-          .notTo(throwError())
-          .to(equal(returnedValue))
+        expect({
+          (try fn.call(by: nil, withArguments: ["test"], appContext: appContext)) as? String
+        })
+        .notTo(throwError())
+        .to(equal(returnedValue))
 
-        expect({ (try fn.call(by: nil, withArguments: ["test", 3], appContext: appContext)) as? String })
-          .notTo(throwError())
-          .to(equal(returnedValue))
+        expect({
+          (try fn.call(by: nil, withArguments: ["test", 3], appContext: appContext)) as? String
+        })
+        .notTo(throwError())
+        .to(equal(returnedValue))
       }
 
       it("throws when called without required arguments") {
@@ -205,13 +215,14 @@ class FunctionSpec: ExpoSpec {
         }
 
         expect({ try fn.call(by: nil, withArguments: [], appContext: appContext) })
-          .to(throwError(errorType: FunctionCallException.self) { error in
-            expect(error.rootCause).to(beAKindOf(InvalidArgsNumberException.self))
-            let exception = error.rootCause as! InvalidArgsNumberException
-            expect(exception.param.received) == 0
-            expect(exception.param.required) == 1
-            expect(exception.param.expected) == 2
-          })
+          .to(
+            throwError(errorType: FunctionCallException.self) { error in
+              expect(error.rootCause).to(beAKindOf(InvalidArgsNumberException.self))
+              let exception = error.rootCause as! InvalidArgsNumberException
+              expect(exception.param.received) == 0
+              expect(exception.param.required) == 1
+              expect(exception.param.expected) == 2
+            })
       }
 
       it("throws when called with arguments of incompatible types") {
@@ -246,50 +257,51 @@ class FunctionSpec: ExpoSpec {
       }
 
       beforeSuite {
-        appContext.moduleRegistry.register(holder: mockModuleHolder(appContext) {
-          Name("TestModule")
+        appContext.moduleRegistry.register(
+          holder: mockModuleHolder(appContext) {
+            Name("TestModule")
 
-          Function("returnPi") { Double.pi }
+            Function("returnPi") { Double.pi }
 
-          Function("returnNull") { () -> Double? in
-            return nil
-          }
+            Function("returnNull") { () -> Double? in
+              return nil
+            }
 
-          Function("returnUndefined") { () -> JavaScriptValue in
-            return .undefined
-          }
+            Function("returnUndefined") { () -> JavaScriptValue in
+              return .undefined
+            }
 
-          Function("isArgNull") { (arg: Double?) -> Bool in
-            return arg == nil
-          }
+            Function("isArgNull") { (arg: Double?) -> Bool in
+              return arg == nil
+            }
 
-          Function("returnObjectDefinition") { (initial: Int) -> ObjectDefinition in
-            var foo = initial
+            Function("returnObjectDefinition") { (initial: Int) -> ObjectDefinition in
+              var foo = initial
 
-            return Object {
-              Function("increment") { () -> Int in
-                foo += 1
-                return foo
+              return Object {
+                Function("increment") { () -> Int in
+                  foo += 1
+                  return foo
+                }
               }
             }
-          }
 
-          Function("withFunction") { (fn: JavaScriptFunction<String>) -> String in
-            return try fn.call("foo", "bar")
-          }
+            Function("withFunction") { (fn: JavaScriptFunction<String>) -> String in
+              return try fn.call("foo", "bar")
+            }
 
-          Function("withCGFloat") { (f: CGFloat) in
-            return "\(f)"
-          }
+            Function("withCGFloat") { (f: CGFloat) in
+              return "\(f)"
+            }
 
-          Function("withRecord") { (f: TestRecord) in
-            return "\(f.property)"
-          }
+            Function("withRecord") { (f: TestRecord) in
+              return "\(f.property)"
+            }
 
-          Function("withOptionalRecord") { (f: TestRecord?) in
-            return "\(f?.property ?? "no value")"
-          }
-        })
+            Function("withOptionalRecord") { (f: TestRecord?) in
+              return "\(f?.property ?? "no value")"
+            }
+          })
       }
 
       it("returns values") {
@@ -305,7 +317,8 @@ class FunctionSpec: ExpoSpec {
 
       it("returns object made from definition") {
         let initialValue = Int.random(in: 1..<100)
-        let object = try runtime.eval("object = expo.modules.TestModule.returnObjectDefinition(\(initialValue))")
+        let object = try runtime.eval(
+          "object = expo.modules.TestModule.returnObjectDefinition(\(initialValue))")
 
         expect(object.kind) == .object
         expect(object.getObject().hasProperty("increment")) == true
@@ -328,15 +341,20 @@ class FunctionSpec: ExpoSpec {
       }
 
       it("accepts record") {
-        expect(try runtime.eval("expo.modules.TestModule.withRecord({property: \"123\"})").asString()) == "123"
+        expect(
+          try runtime.eval("expo.modules.TestModule.withRecord({property: \"123\"})").asString())
+          == "123"
       }
 
       it("accepts no optional record") {
-        expect(try runtime.eval("expo.modules.TestModule.withOptionalRecord()").asString()) == "no value"
+        expect(try runtime.eval("expo.modules.TestModule.withOptionalRecord()").asString())
+          == "no value"
       }
 
       it("accepts optional record") {
-        expect(try runtime.eval("expo.modules.TestModule.withOptionalRecord({property: \"123\"})").asString()) == "123"
+        expect(
+          try runtime.eval("expo.modules.TestModule.withOptionalRecord({property: \"123\"})")
+            .asString()) == "123"
       }
     }
   }
diff --git a/ios/Tests/FunctionWithConvertiblesSpec.swift b/ios/Tests/FunctionWithConvertiblesSpec.swift
index e45ccfc8942eaab65b540814e783efc7a2302b21..56fb3ee94294751a756986d166c772a611c90788 100644
--- a/ios/Tests/FunctionWithConvertiblesSpec.swift
+++ b/ios/Tests/FunctionWithConvertiblesSpec.swift
@@ -17,7 +17,8 @@ class FunctionWithConvertiblesSpec: ExpoSpec {
       let height = 592.1
 
       mockModuleHolder(appContext) {
-        AsyncFunction(functionName) { (point: CGPoint, size: CGSize, vector: CGVector, rect: CGRect) in
+        AsyncFunction(functionName) {
+          (point: CGPoint, size: CGSize, vector: CGVector, rect: CGRect) in
           expect(point.x) == x
           expect(point.y) == y
           expect(size.width) == width
@@ -30,36 +31,43 @@ class FunctionWithConvertiblesSpec: ExpoSpec {
           expect(rect.height) == height
         }
       }
-      .callSync(function: functionName, args: [
-        [x, y], // point
-        ["width": width, "height": height], // size
-        ["dx": x, "dy": y], // vector
-        [x, y, width, height] // rect
-      ])
+      .callSync(
+        function: functionName,
+        args: [
+          [x, y],  // point
+          ["width": width, "height": height],  // size
+          ["dx": x, "dy": y],  // vector
+          [x, y, width, height],  // rect
+        ])
     }
 
     it("converts arguments to CGColor") {
-      func testColorComponents(_ color: CGColor, _ red: CGFloat, _ green: CGFloat, _ blue: CGFloat, _ alpha: CGFloat) {
-        expect(color.components?[0]) == red   / 255.0
+      func testColorComponents(
+        _ color: CGColor, _ red: CGFloat, _ green: CGFloat, _ blue: CGFloat, _ alpha: CGFloat
+      ) {
+        expect(color.components?[0]) == red / 255.0
         expect(color.components?[1]) == green / 255.0
-        expect(color.components?[2]) == blue  / 255.0
+        expect(color.components?[2]) == blue / 255.0
         expect(color.components?[3]) == alpha / 255.0
       }
 
       mockModuleHolder(appContext) {
-        AsyncFunction(functionName) { (color1: CGColor, color2: CGColor, color3: CGColor, color4: CGColor) in
+        AsyncFunction(functionName) {
+          (color1: CGColor, color2: CGColor, color3: CGColor, color4: CGColor) in
           testColorComponents(color1, 0x2A, 0x4B, 0x5D, 0xFF)
           testColorComponents(color2, 0x11, 0xFF, 0x00, 0xDD)
           testColorComponents(color3, 0x66, 0x00, 0xCC, 0xAA)
           testColorComponents(color4, 0x00, 0x00, 0x00, 0x00)
         }
       }
-      .callSync(function: functionName, args: [
-        "#2A4B5D",
-        0xDD11FF00,
-        "60CA",
-        0
-      ])
+      .callSync(
+        function: functionName,
+        args: [
+          "#2A4B5D",
+          0xDD11_FF00,
+          "60CA",
+          0,
+        ])
     }
   }
 }
diff --git a/ios/Tests/JavaScriptRuntimeSpec.swift b/ios/Tests/JavaScriptRuntimeSpec.swift
index 6b6f27d13f1f9f96242497f13ac7c21c25ee0f0a..adf843cabd8a387f6e66227b94f9432630409d7f 100644
--- a/ios/Tests/JavaScriptRuntimeSpec.swift
+++ b/ios/Tests/JavaScriptRuntimeSpec.swift
@@ -84,14 +84,17 @@ class JavaScriptRuntimeSpec: ExpoSpec {
       }
 
       it("throws evaluation exception") {
-        expect({ try runtime.eval("foo") }).to(throwError { error in
-          expect(error).to(beAKindOf(JavaScriptEvalException.self))
-          #if canImport(reacthermes)
-          expect((error as! JavaScriptEvalException).reason).to(contain("Property 'foo' doesn't exist"))
-          #else
-          expect((error as! JavaScriptEvalException).reason).to(contain("Can't find variable: foo"))
-          #endif
-        })
+        expect({ try runtime.eval("foo") }).to(
+          throwError { error in
+            expect(error).to(beAKindOf(JavaScriptEvalException.self))
+            #if canImport(reacthermes)
+              expect((error as! JavaScriptEvalException).reason).to(
+                contain("Property 'foo' doesn't exist"))
+            #else
+              expect((error as! JavaScriptEvalException).reason).to(
+                contain("Can't find variable: foo"))
+            #endif
+          })
       }
     }
   }
diff --git a/ios/Tests/LoggerSpec.swift b/ios/Tests/LoggerSpec.swift
index e6501663fb606094857ce8e67370f3c2fac600be..3aa8ab0b08fdddb7b4ec2db0bb6735c5335155f5 100644
--- a/ios/Tests/LoggerSpec.swift
+++ b/ios/Tests/LoggerSpec.swift
@@ -5,14 +5,15 @@ import ExpoModulesTestCore
 @testable import ExpoModulesCore
 
 final class LoggerSpec: ExpoSpec {
-  class TestLogHandler : LogHandler {
-    struct TestLogHandlerLogEntry : Equatable {
+  class TestLogHandler: LogHandler {
+    struct TestLogHandlerLogEntry: Equatable {
       let type: LogType
       let message: String
 
       static func == (lhs: TestLogHandlerLogEntry, rhs: TestLogHandlerLogEntry) -> Bool {
         // slightly-fuzzy matching for testing only due to prepending emoji to message
-        return lhs.type == rhs.type && (lhs.message.contains(rhs.message) || rhs.message.contains(lhs.message))
+        return lhs.type == rhs.type
+          && (lhs.message.contains(rhs.message) || rhs.message.contains(lhs.message))
       }
     }
 
@@ -33,27 +34,33 @@ final class LoggerSpec: ExpoSpec {
       let logger = Logger(logHandlers: [loggerHandler])
 
       logger.trace("hello")
-      expect(loggerHandler.logEntries.first) == TestLogHandler.TestLogHandlerLogEntry(type: .trace, message: "hello")
+      expect(loggerHandler.logEntries.first)
+        == TestLogHandler.TestLogHandlerLogEntry(type: .trace, message: "hello")
       loggerHandler.clear()
 
       logger.debug("hello")
-      expect(loggerHandler.logEntries.first) == TestLogHandler.TestLogHandlerLogEntry(type: .debug, message: "hello")
+      expect(loggerHandler.logEntries.first)
+        == TestLogHandler.TestLogHandlerLogEntry(type: .debug, message: "hello")
       loggerHandler.clear()
 
       logger.info("hello")
-      expect(loggerHandler.logEntries.first) == TestLogHandler.TestLogHandlerLogEntry(type: .info, message: "hello")
+      expect(loggerHandler.logEntries.first)
+        == TestLogHandler.TestLogHandlerLogEntry(type: .info, message: "hello")
       loggerHandler.clear()
 
       logger.warn("hello")
-      expect(loggerHandler.logEntries.first) == TestLogHandler.TestLogHandlerLogEntry(type: .warn, message: "hello")
+      expect(loggerHandler.logEntries.first)
+        == TestLogHandler.TestLogHandlerLogEntry(type: .warn, message: "hello")
       loggerHandler.clear()
 
       logger.error("hello")
-      expect(loggerHandler.logEntries.first) == TestLogHandler.TestLogHandlerLogEntry(type: .error, message: "hello")
+      expect(loggerHandler.logEntries.first)
+        == TestLogHandler.TestLogHandlerLogEntry(type: .error, message: "hello")
       loggerHandler.clear()
 
       logger.fatal("hello")
-      expect(loggerHandler.logEntries.first) == TestLogHandler.TestLogHandlerLogEntry(type: .fatal, message: "hello")
+      expect(loggerHandler.logEntries.first)
+        == TestLogHandler.TestLogHandlerLogEntry(type: .fatal, message: "hello")
       loggerHandler.clear()
     }
 
diff --git a/ios/Tests/Mocks/ModuleMocks.swift b/ios/Tests/Mocks/ModuleMocks.swift
index 256e7aa0ca69e46492c743da4f4807aad290aecb..90f3cdc0fc193df331b3b4a08c86ea70b46a1ead 100644
--- a/ios/Tests/Mocks/ModuleMocks.swift
+++ b/ios/Tests/Mocks/ModuleMocks.swift
@@ -31,10 +31,19 @@ class CustomModule: Module {
 
 typealias MockedDefinitionFunc = (CustomModule) -> ModuleDefinition
 
-func mockModuleHolder(_ appContext: AppContext, @ModuleDefinitionBuilder _ definitionBody: @escaping () -> ModuleDefinition) -> ModuleHolder {
-  return ModuleHolder(appContext: appContext, module: CustomModule(appContext: appContext, { _ in definitionBody() }))
+func mockModuleHolder(
+  _ appContext: AppContext,
+  @ModuleDefinitionBuilder _ definitionBody: @escaping () -> ModuleDefinition
+) -> ModuleHolder {
+  return ModuleHolder(
+    appContext: appContext, module: CustomModule(appContext: appContext, { _ in definitionBody() }))
 }
 
-func mockModuleHolder(_ appContext: AppContext, @ModuleDefinitionBuilder _ definitionBody: @escaping (CustomModule) -> ModuleDefinition) -> ModuleHolder {
-  return ModuleHolder(appContext: appContext, module: CustomModule(appContext: appContext, { module in definitionBody(module) }))
+func mockModuleHolder(
+  _ appContext: AppContext,
+  @ModuleDefinitionBuilder _ definitionBody: @escaping (CustomModule) -> ModuleDefinition
+) -> ModuleHolder {
+  return ModuleHolder(
+    appContext: appContext,
+    module: CustomModule(appContext: appContext, { module in definitionBody(module) }))
 }
diff --git a/ios/Tests/Mocks/ModulesProviderMock.swift b/ios/Tests/Mocks/ModulesProviderMock.swift
index 116c0402e425c4b9128ce15cfdf2cb34cf074121..58daa450c7400f8e9645955aa9a71dfbc63efcf9 100644
--- a/ios/Tests/Mocks/ModulesProviderMock.swift
+++ b/ios/Tests/Mocks/ModulesProviderMock.swift
@@ -2,7 +2,6 @@ import ExpoModulesCore
 
 public class ModulesProviderMock: ModulesProvider {
   public override func getModuleClasses() -> [AnyModule.Type] {
-    return [
-    ]
+    return []
   }
 }
diff --git a/ios/Tests/ModuleEventListenersSpec.swift b/ios/Tests/ModuleEventListenersSpec.swift
index 9d8b34b6a4eacbc930b5bc548b43f7e0254a05b4..dcc216adad42c88a174185359f77f3e7a1f07c5d 100644
--- a/ios/Tests/ModuleEventListenersSpec.swift
+++ b/ios/Tests/ModuleEventListenersSpec.swift
@@ -2,14 +2,12 @@ import ExpoModulesTestCore
 
 @testable import ExpoModulesCore
 
-/**
- This test spec covers module's event listeners which can listen to:
- - module's lifecycle events
- - app's lifecycle notifications
- - custom events sent to the module registry
-
- NOTE: Each test registers the module because only registered modules can capture events.
- */
+/// This test spec covers module's event listeners which can listen to:
+/// - module's lifecycle events
+/// - app's lifecycle notifications
+/// - custom events sent to the module registry
+///
+/// NOTE: Each test registers the module because only registered modules can capture events.
 class ModuleEventListenersSpec: ExpoSpec {
   override class func spec() {
     var appContext: AppContext!
@@ -52,7 +50,7 @@ class ModuleEventListenersSpec: ExpoSpec {
           }
         }
         appContext.moduleRegistry.register(holder: holder)
-        appContext = nil // This must deallocate the app context
+        appContext = nil  // This must deallocate the app context
       }
     }
 
@@ -77,7 +75,8 @@ class ModuleEventListenersSpec: ExpoSpec {
           }
         }
         appContext.moduleRegistry.register(holder: holder)
-        NotificationCenter.default.post(name: UIApplication.willEnterForegroundNotification, object: nil)
+        NotificationCenter.default.post(
+          name: UIApplication.willEnterForegroundNotification, object: nil)
       }
     }
 
@@ -89,7 +88,8 @@ class ModuleEventListenersSpec: ExpoSpec {
           }
         }
         appContext.moduleRegistry.register(holder: holder)
-        NotificationCenter.default.post(name: UIApplication.didBecomeActiveNotification, object: nil)
+        NotificationCenter.default.post(
+          name: UIApplication.didBecomeActiveNotification, object: nil)
       }
     }
 
@@ -101,7 +101,8 @@ class ModuleEventListenersSpec: ExpoSpec {
           }
         }
         appContext.moduleRegistry.register(holder: holder)
-        NotificationCenter.default.post(name: UIApplication.didEnterBackgroundNotification, object: nil)
+        NotificationCenter.default.post(
+          name: UIApplication.didEnterBackgroundNotification, object: nil)
       }
     }
   }
diff --git a/ios/Tests/PropertyDefinitionSpec.swift b/ios/Tests/PropertyDefinitionSpec.swift
index 35fc80ba71e805e98407ac14c731d6b0248b24d4..8d084725a458926631d9dd6d661c2bccf169d51d 100644
--- a/ios/Tests/PropertyDefinitionSpec.swift
+++ b/ios/Tests/PropertyDefinitionSpec.swift
@@ -54,15 +54,18 @@ class PropertyDefinitionSpec: ExpoSpec {
       }
 
       it("is enumerable") {
-        let keys = try runtime.eval("Object.keys(expo.modules.PropertyTest)").getArray().map { $0.getString() } ?? []
+        let keys =
+          try runtime.eval("Object.keys(expo.modules.PropertyTest)").getArray().map {
+            $0.getString()
+          } ?? []
         expect(keys).to(contain("readOnly", "writable", "undefined"))
       }
 
-// TODO: Using JavaScriptObject as the owner is no longer possible, but we may want to bring this feature back
-//      it("is called with the caller") {
-//        let value = try runtime?.eval("expo.modules.PropertyTest.withCaller")
-//        expect(value?.getString()) == "foo"
-//      }
+      // TODO: Using JavaScriptObject as the owner is no longer possible, but we may want to bring this feature back
+      //      it("is called with the caller") {
+      //        let value = try runtime?.eval("expo.modules.PropertyTest.withCaller")
+      //        expect(value?.getString()) == "foo"
+      //      }
 
       it("returns undefined when getter is not specified") {
         let value = try runtime.eval("expo.modules.PropertyTest.undefined")
@@ -90,7 +93,7 @@ class PropertyDefinitionSpec: ExpoSpec {
         let value = try runtime.eval([
           "object = new expo.modules.PropertyTest.TestClass()",
           "object.someValue = \(newValue)",
-          "object.someValue"
+          "object.someValue",
         ])
 
         expect(value.kind) == .number
@@ -102,7 +105,7 @@ class PropertyDefinitionSpec: ExpoSpec {
         it("gets immutable property") {
           let value = try runtime.eval([
             "object = new expo.modules.PropertyTest.TestClass()",
-            "object.immutableKeyPathProperty"
+            "object.immutableKeyPathProperty",
           ])
 
           expect(value.kind) == .number
@@ -114,7 +117,7 @@ class PropertyDefinitionSpec: ExpoSpec {
           let value = try runtime.eval([
             "object = new expo.modules.PropertyTest.TestClass()",
             "object.immutableKeyPathProperty = \(newValue)",
-            "object.immutableKeyPathProperty"
+            "object.immutableKeyPathProperty",
           ])
 
           // Returned value didn't change, it doesn't equal to `newValue`
@@ -127,7 +130,7 @@ class PropertyDefinitionSpec: ExpoSpec {
           let value = try runtime.eval([
             "object = new expo.modules.PropertyTest.TestClass()",
             "object.mutableKeyPathProperty = \(newValue)",
-            "object.mutableKeyPathProperty"
+            "object.mutableKeyPathProperty",
           ])
 
           expect(value.kind) == .number
@@ -155,12 +158,12 @@ class PropertyTestModule: Module {
         writablePropertyValue = value
       }
 
-// TODO: Using JavaScriptObject as the owner is no longer possible, but we may want to bring this feature back
-//            Property("withCaller") { (caller: JavaScriptObject) -> String in
-//              // Here, the caller is a JS object of the module.
-//              // Return another property of itself.
-//              return caller.getProperty("readOnly").getString()
-//            }
+    // TODO: Using JavaScriptObject as the owner is no longer possible, but we may want to bring this feature back
+    //            Property("withCaller") { (caller: JavaScriptObject) -> String in
+    //              // Here, the caller is a JS object of the module.
+    //              // Return another property of itself.
+    //              return caller.getProperty("readOnly").getString()
+    //            }
 
     Property("undefined")
 
@@ -185,7 +188,7 @@ class PropertyTestModule: Module {
   }
 }
 
-fileprivate final class TestClass: SharedObject {
+private final class TestClass: SharedObject {
   static let constantValue = Int.random(in: 1..<100)
 
   var someValue = TestClass.constantValue
diff --git a/ios/Tests/RecordSpec.swift b/ios/Tests/RecordSpec.swift
index db70d1eba15f3864b936d72719f4ca30b43497e9..8e70b51c6ef6541fd068c925b6726daa0540416f 100644
--- a/ios/Tests/RecordSpec.swift
+++ b/ios/Tests/RecordSpec.swift
@@ -7,7 +7,7 @@ class RecordSpec: ExpoSpec {
     let appContext = AppContext.create()
 
     it("initializes with empty dictionary") {
-      struct TestRecord: Record { }
+      struct TestRecord: Record {}
       _ = try TestRecord(from: [:], appContext: appContext)
     }
 
@@ -61,9 +61,10 @@ class RecordSpec: ExpoSpec {
         @Field(.required) var a: Int
       }
 
-      expect { try TestRecord(from: [:], appContext: appContext) }.to(throwError { error in
-        expect(error).to(beAKindOf(FieldRequiredException.self))
-      })
+      expect { try TestRecord(from: [:], appContext: appContext) }.to(
+        throwError { error in
+          expect(error).to(beAKindOf(FieldRequiredException.self))
+        })
     }
 
     it("throws when casting is not possible") {
@@ -72,9 +73,10 @@ class RecordSpec: ExpoSpec {
       }
       let dict = ["a": "try with String instead of Int"]
 
-      expect { try TestRecord(from: dict, appContext: appContext) }.to(throwError { error in
-        expect(error).to(beAKindOf(FieldInvalidTypeException.self))
-      })
+      expect { try TestRecord(from: dict, appContext: appContext) }.to(
+        throwError { error in
+          expect(error).to(beAKindOf(FieldInvalidTypeException.self))
+        })
     }
   }
 }
diff --git a/ios/Tests/SharedObjectRegistrySpec.swift b/ios/Tests/SharedObjectRegistrySpec.swift
index 84e8c397a28fc0459765e5a0a2c8a4e0b42fc488..0d010185b2bec40f4490e5472b2b36a3421b5a21 100644
--- a/ios/Tests/SharedObjectRegistrySpec.swift
+++ b/ios/Tests/SharedObjectRegistrySpec.swift
@@ -30,7 +30,8 @@ final class SharedObjectRegistrySpec: ExpoSpec {
     describe("add") {
       it("adds using nextId") {
         let nextId = sharedObjectRegistry.nextId
-        let id = sharedObjectRegistry.add(native: TestSharedObject(), javaScript: runtime.createObject())
+        let id = sharedObjectRegistry.add(
+          native: TestSharedObject(), javaScript: runtime.createObject())
         expect(nextId) == id
       }
       it("is increasing size") {
@@ -66,7 +67,8 @@ final class SharedObjectRegistrySpec: ExpoSpec {
 
     describe("delete") {
       it("deletes objects pair") {
-        let id = sharedObjectRegistry.add(native: TestSharedObject(), javaScript: runtime.createObject())
+        let id = sharedObjectRegistry.add(
+          native: TestSharedObject(), javaScript: runtime.createObject())
         sharedObjectRegistry.delete(id)
         expect(sharedObjectRegistry.get(id)).to(beNil())
       }
@@ -106,4 +108,4 @@ final class SharedObjectRegistrySpec: ExpoSpec {
   }
 }
 
-fileprivate final class TestSharedObject: SharedObject {}
+private final class TestSharedObject: SharedObject {}
diff --git a/ios/Tests/SharedObjectSpec.swift b/ios/Tests/SharedObjectSpec.swift
index 4951392275752f63b89450b07e68507092610301..5fa9492b06e9ac6da84a23753ad43f39f5359f28 100644
--- a/ios/Tests/SharedObjectSpec.swift
+++ b/ios/Tests/SharedObjectSpec.swift
@@ -34,7 +34,8 @@ final class SharedObjectSpec: ExpoSpec {
       }
 
       it("inherits from EventEmitter") {
-        let isEventEmitter = try runtime.eval("new expo.SharedObject() instanceof expo.EventEmitter")
+        let isEventEmitter = try runtime.eval(
+          "new expo.SharedObject() instanceof expo.EventEmitter")
         expect(isEventEmitter.kind) == .bool
         expect(try isEventEmitter.asBool()) == true
       }
@@ -42,18 +43,22 @@ final class SharedObjectSpec: ExpoSpec {
 
     describe("Concrete JS class") {
       it("exists") {
-        let sharedObjectClass = try runtime.eval("expo.modules.SharedObjectModule.SharedObjectExample")
+        let sharedObjectClass = try runtime.eval(
+          "expo.modules.SharedObjectModule.SharedObjectExample")
         expect(sharedObjectClass.kind) == .function
       }
 
       it("has base class prototype") {
-        let hasBaseClassPrototype = try runtime.eval("expo.modules.SharedObjectModule.SharedObjectExample.prototype instanceof expo.SharedObject")
+        let hasBaseClassPrototype = try runtime.eval(
+          "expo.modules.SharedObjectModule.SharedObjectExample.prototype instanceof expo.SharedObject"
+        )
         expect(hasBaseClassPrototype.kind) == .bool
         expect(try hasBaseClassPrototype.asBool()) == true
       }
 
       it("creates new instance") {
-        let sharedObject = try runtime.eval("new expo.modules.SharedObjectModule.SharedObjectExample()")
+        let sharedObject = try runtime.eval(
+          "new expo.modules.SharedObjectModule.SharedObjectExample()")
         expect(sharedObject.kind) == .object
       }
 
@@ -66,7 +71,7 @@ final class SharedObjectSpec: ExpoSpec {
       it("is instance of") {
         let isInstanceOf = try runtime.eval([
           "sharedObject = new expo.modules.SharedObjectModule.SharedObjectExample()",
-          "sharedObject instanceof expo.modules.SharedObjectModule.SharedObjectExample"
+          "sharedObject instanceof expo.modules.SharedObjectModule.SharedObjectExample",
         ])
         expect(isInstanceOf.kind) == .bool
         expect(try isInstanceOf.asBool()) == true
@@ -75,7 +80,7 @@ final class SharedObjectSpec: ExpoSpec {
       it("is instance of base class") {
         let isInstanceOfBaseClass = try runtime.eval([
           "sharedObject = new expo.modules.SharedObjectModule.SharedObjectExample()",
-          "sharedObject instanceof expo.SharedObject"
+          "sharedObject instanceof expo.SharedObject",
         ])
         expect(isInstanceOfBaseClass.kind) == .bool
         expect(try isInstanceOfBaseClass.asBool()) == true
@@ -84,7 +89,7 @@ final class SharedObjectSpec: ExpoSpec {
       it("has function from base class") {
         let releaseFunction = try runtime.eval([
           "sharedObject = new expo.modules.SharedObjectModule.SharedObjectExample()",
-          "sharedObject.release"
+          "sharedObject.release",
         ])
         expect(releaseFunction.kind) == .function
       }
@@ -92,7 +97,7 @@ final class SharedObjectSpec: ExpoSpec {
       it("returns this") {
         let isReturningItself = try runtime.eval([
           "sharedObject = new expo.modules.SharedObjectModule.SharedObjectExample()",
-          "sharedObject === sharedObject.returnThis()"
+          "sharedObject === sharedObject.returnThis()",
         ])
         expect(isReturningItself.kind) == .bool
         expect(try isReturningItself.asBool()) == true
@@ -103,36 +108,38 @@ final class SharedObjectSpec: ExpoSpec {
       // Event emitting requires Xcode 15.0, but we're still using Xcode 14
       // to run these tests on GitHub Actions due to some performance issues.
       #if swift(>=5.9)
-      it("emits events") {
-        // Create the shared object
-        let jsObject = try runtime
-          .eval("sharedObject = new expo.modules.SharedObjectModule.SharedObjectExample()")
-          .asObject()
-
-        // Add a listener that adds three arguments
-        try runtime.eval([
-          "result = null",
-          "sharedObject.addListener('test event', (number, string, record) => { result = { number, string, record } })"
-        ])
-
-        // Get the native instance
-        let nativeObject = appContext.sharedObjectRegistry.toNativeObject(jsObject)
-
-        struct EventRecord: Record {
-          @Field var boolean: Bool = true
+        it("emits events") {
+          // Create the shared object
+          let jsObject =
+            try runtime
+            .eval("sharedObject = new expo.modules.SharedObjectModule.SharedObjectExample()")
+            .asObject()
+
+          // Add a listener that adds three arguments
+          try runtime.eval([
+            "result = null",
+            "sharedObject.addListener('test event', (number, string, record) => { result = { number, string, record } })",
+          ])
+
+          // Get the native instance
+          let nativeObject = appContext.sharedObjectRegistry.toNativeObject(jsObject)
+
+          struct EventRecord: Record {
+            @Field var boolean: Bool = true
+          }
+
+          // Emit an event from the native object to JS
+          nativeObject?.emit(event: "test event", arguments: 123, "test", EventRecord())
+
+          // Check the value that is set by the listener
+          let result = try runtime.eval("result").asObject()
+
+          expect(try result.getProperty("number").asInt()) == 123
+          expect(try result.getProperty("string").asString()) == "test"
+          expect(try result.getProperty("record").asObject().getProperty("boolean").asBool())
+            == true
         }
-
-        // Emit an event from the native object to JS
-        nativeObject?.emit(event: "test event", arguments: 123, "test", EventRecord())
-
-        // Check the value that is set by the listener
-        let result = try runtime.eval("result").asObject()
-
-        expect(try result.getProperty("number").asInt()) == 123
-        expect(try result.getProperty("string").asString()) == "test"
-        expect(try result.getProperty("record").asObject().getProperty("boolean").asBool()) == true
-      }
-      #endif // swift(>=5.9)
+      #endif  // swift(>=5.9)
     }
   }
 }
diff --git a/ios/Tests/SharedRefSpec.swift b/ios/Tests/SharedRefSpec.swift
index b9e8d9db5f45ac327cd0f1f230f03a013e6bb16a..46ec75f6cec7fd05a1d5d504a7ab639856e6dc34 100644
--- a/ios/Tests/SharedRefSpec.swift
+++ b/ios/Tests/SharedRefSpec.swift
@@ -23,7 +23,8 @@ final class SharedRefSpec: ExpoSpec {
     }
 
     it("creates shared data") {
-      let result = try runtime.eval("expo.modules.FirstModule.createSharedData('\(sharedDataString)')")
+      let result = try runtime.eval(
+        "expo.modules.FirstModule.createSharedData('\(sharedDataString)')")
 
       expect(result.kind) == .object
     }
@@ -31,16 +32,16 @@ final class SharedRefSpec: ExpoSpec {
     it("shares Data object") {
       let result = try runtime.eval([
         "sharedData = expo.modules.FirstModule.createSharedData('\(sharedDataString)')",
-        "expo.modules.SecondModule.stringFromSharedData(sharedData)"
+        "expo.modules.SecondModule.stringFromSharedData(sharedData)",
       ])
 
       expect(result.kind) == .string
       expect(try result.asString()) == sharedDataString
     }
-    
+
     it("has native ref type") {
       let result = try runtime.eval("expo.modules.FirstModule.createSharedString().nativeRefType")
-      
+
       expect(result.kind) == .string
       expect(try result.asString()) == "string"
     }
@@ -51,9 +52,7 @@ private let sharedDataString = "I can be shared among independent modules"
 
 private class SharedString: SharedRef<String> {
   override var nativeRefType: String {
-    get {
-      "string"
-    }
+    "string"
   }
 }
 
@@ -63,7 +62,7 @@ private class FirstModule: Module {
       let data = Data(string.utf8)
       return SharedRef<Data>(data)
     }
-    
+
     Function("createSharedString") {
       SharedString("string")
     }
diff --git a/ios/Tests/TypedArraysSpec.swift b/ios/Tests/TypedArraysSpec.swift
index 6e06f2f0990b6202d35fc3fd38fb3b0d7400dafc..7a3c5633820a93196377cad222b468fbadc9c529 100644
--- a/ios/Tests/TypedArraysSpec.swift
+++ b/ios/Tests/TypedArraysSpec.swift
@@ -16,7 +16,8 @@ final class TypedArraysSpec: ExpoSpec {
 
       // Gets the value at index 3 from the array
       it("reads from Int8Array") {
-        let intValue = try runtime
+        let intValue =
+          try runtime
           .eval([
             "typedArray = new Int8Array([2, 1, 3, 7])",
             "expo.modules.TypedArrays.int8_subscript_get(typedArray, 3)",
@@ -29,7 +30,8 @@ final class TypedArraysSpec: ExpoSpec {
       // Sets the value at index 1 to the random int
       it("writes to Int8Array") {
         let randomInt = Int.random(in: -128...127)
-        let array = try runtime
+        let array =
+          try runtime
           .eval([
             "typedArray = new Int8Array(3)",
             "expo.modules.TypedArrays.int8_subscript_set(typedArray, 1, \(randomInt))",
@@ -37,17 +39,18 @@ final class TypedArraysSpec: ExpoSpec {
           ])
           .asArray()
 
-        expect(array[0]?.getInt()) == 0 // Remains unset
+        expect(array[0]?.getInt()) == 0  // Remains unset
         expect(array[1]?.getInt()) == randomInt
-        expect(array[2]?.getInt()) == 0 // Remains unset
+        expect(array[2]?.getInt()) == 0  // Remains unset
       }
 
       // Gets a slice from the array from index 1 to 3
       it("reads from UInt16Array slice") {
-        let values = try runtime
+        let values =
+          try runtime
           .eval([
             "typedArray = new Uint16Array([0, 8, 4, 1])",
-            "expo.modules.TypedArrays.uint16_subscript_range_get(typedArray, 1, 3)"
+            "expo.modules.TypedArrays.uint16_subscript_range_get(typedArray, 1, 3)",
           ])
           .asArray()
           .map({ try $0?.asInt() })
@@ -62,7 +65,8 @@ final class TypedArraysSpec: ExpoSpec {
       it("writes to UInt16Array slice") {
         let random1 = Int.random(in: 0...65535)
         let random2 = Int.random(in: 0...65535)
-        let values = try runtime
+        let values =
+          try runtime
           .eval([
             "typedArray = new Uint16Array(4)",
             "expo.modules.TypedArrays.uint16_subscript_range_set(typedArray, 1, 2, [\(random1), \(random2)])",
@@ -70,14 +74,15 @@ final class TypedArraysSpec: ExpoSpec {
           ])
           .asArray()
 
-        expect(values[0]?.getInt()) == 0 // Remains unset
+        expect(values[0]?.getInt()) == 0  // Remains unset
         expect(values[1]?.getInt()) == random1
         expect(values[2]?.getInt()) == random2
-        expect(values[3]?.getInt()) == 0 // Remains unset
+        expect(values[3]?.getInt()) == 0  // Remains unset
       }
 
       it("returns itself") {
-        let input = try runtime.eval("typedArray = new Float32Array([1.2, 3.4]); typedArray").asTypedArray()
+        let input = try runtime.eval("typedArray = new Float32Array([1.2, 3.4]); typedArray")
+          .asTypedArray()
         let output = try runtime.eval("expo.modules.TypedArrays.return(typedArray)").asTypedArray()
 
         expect(input.getProperty("0").getDouble()) == output.getProperty("0").getDouble()
@@ -87,7 +92,8 @@ final class TypedArraysSpec: ExpoSpec {
 
       it("writes to unsafe raw pointer") {
         let count = 6
-        let values = try runtime
+        let values =
+          try runtime
           .eval([
             "typedArray = new Uint8Array(\(count))",
             "Array.from(expo.modules.TypedArrays.writeToUnsafeRawPointer(typedArray))",
@@ -104,7 +110,7 @@ final class TypedArraysSpec: ExpoSpec {
   }
 }
 
-fileprivate final class TypedArraysModule: Module {
+private final class TypedArraysModule: Module {
   func definition() -> ModuleDefinition {
     Name("TypedArrays")
 
@@ -120,7 +126,8 @@ fileprivate final class TypedArraysModule: Module {
       return array[start...end]
     }
 
-    Function("uint16_subscript_range_set") { (array: Uint16Array, start: Int, end: Int, values: [UInt16]) in
+    Function("uint16_subscript_range_set") {
+      (array: Uint16Array, start: Int, end: Int, values: [UInt16]) in
       array[start...end] = values
     }
 
diff --git a/ios/Tests/ViewDefinitionSpec.swift b/ios/Tests/ViewDefinitionSpec.swift
index 8fdf5a8539d5dd1675772b12ef58ebaadbf79b8c..9427970caafdc32cf134fc1f49d164335968b26c 100644
--- a/ios/Tests/ViewDefinitionSpec.swift
+++ b/ios/Tests/ViewDefinitionSpec.swift
@@ -25,7 +25,8 @@ final class ViewDefinitionSpec: ExpoSpec {
             view.text = value
           }
         }
-        try definition.propsDict()["content"]?.set(value: content, onView: textView, appContext: appContext)
+        try definition.propsDict()["content"]?.set(
+          value: content, onView: textView, appContext: appContext)
         expect(textView.text) == content
       }
 
@@ -38,7 +39,8 @@ final class ViewDefinitionSpec: ExpoSpec {
             expect(view).to(beAKindOf(UITextView.self))
           }
         }
-        try definition.propsDict()["content"]?.set(value: content, onView: textView, appContext: appContext)
+        try definition.propsDict()["content"]?.set(
+          value: content, onView: textView, appContext: appContext)
       }
     }
 
diff --git a/ios/Utilities.swift b/ios/Utilities.swift
index 09a9efe4e4f620e159c0399749581ab8a13a8257..8ec2fbb709df43122e898144114ad23c8b5932c3 100644
--- a/ios/Utilities.swift
+++ b/ios/Utilities.swift
@@ -1,10 +1,10 @@
 // Copyright 2022-present 650 Industries. All rights reserved.
 
-/**
- Executes the given Swift closure and if it throws, the `NSError` is set on the given `NSErrorPointer` and the original error is rethrown.
- This is especially useful for ObjC<->Swift interop, specifically when the ObjC needs to catch errors thrown by Swift closure.
- */
-internal func runWithErrorPointer<R>(_ errorPointer: NSErrorPointer, _ closure: () throws -> R) rethrows -> R? {
+/// Executes the given Swift closure and if it throws, the `NSError` is set on the given `NSErrorPointer` and the original error is rethrown.
+/// This is especially useful for ObjC<->Swift interop, specifically when the ObjC needs to catch errors thrown by Swift closure.
+internal func runWithErrorPointer<R>(_ errorPointer: NSErrorPointer, _ closure: () throws -> R)
+  rethrows -> R?
+{
   do {
     return try closure()
   } catch {
@@ -13,47 +13,41 @@ internal func runWithErrorPointer<R>(_ errorPointer: NSErrorPointer, _ closure:
   }
 }
 
-/**
- Converts Swift errors to `NSError` so that they can be handled from the ObjC code.
- */
+/// Converts Swift errors to `NSError` so that they can be handled from the ObjC code.
 internal func toNSError(_ error: Error) -> NSError {
   if let error = error as? Exception {
-    return NSError(domain: "dev.expo.modules", code: 0, userInfo: [
-      "name": error.name,
-      "code": error.code,
-      "message": error.debugDescription,
-    ])
+    return NSError(
+      domain: "dev.expo.modules", code: 0,
+      userInfo: [
+        "name": error.name,
+        "code": error.code,
+        "message": error.debugDescription,
+      ])
   }
   return error as NSError
 }
 
 // MARK: - URLs
 
-/**
- A string with non-alphanumeric url-safe characters according to RFC 3986.
- These characters might have to be explicitly percent-encoded when used in URL components other than intended.
- */
+/// A string with non-alphanumeric url-safe characters according to RFC 3986.
+/// These characters might have to be explicitly percent-encoded when used in URL components other than intended.
 internal let urlAllowedCharacters = "-._~:/?#[]@!$&'()*+,;="
 
-/**
- A `CharacterSet` instance containing all alphanumerics and characters allowed in at least one part of a URL.
- */
-internal let urlAllowedCharactersSet = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: urlAllowedCharacters))
+/// A `CharacterSet` instance containing all alphanumerics and characters allowed in at least one part of a URL.
+internal let urlAllowedCharactersSet = CharacterSet.alphanumerics.union(
+  CharacterSet(charactersIn: urlAllowedCharacters))
 
-/**
- Returns the given string with percent-encoded characters that are not allowed in any of the URL components as defined by RFC 3986.
- This is useful for auto-encoding unicode characters.
- */
+/// Returns the given string with percent-encoded characters that are not allowed in any of the URL components as defined by RFC 3986.
+/// This is useful for auto-encoding unicode characters.
 internal func percentEncodeUrlString(_ url: String) -> String? {
   let encodedString = url.addingPercentEncoding(withAllowedCharacters: urlAllowedCharactersSet)
   return encodedString?.replacingOccurrences(of: "%25", with: "%")
 }
 
-/**
- Checks whether the given string is a file URL path (URL string without the scheme).
- */
+/// Checks whether the given string is a file URL path (URL string without the scheme).
 internal func isFileUrlPath(_ path: String) -> Bool {
-  guard let encodedPath = path.addingPercentEncoding(withAllowedCharacters: urlAllowedCharactersSet) else {
+  guard let encodedPath = path.addingPercentEncoding(withAllowedCharacters: urlAllowedCharactersSet)
+  else {
     return false
   }
   return URL(string: encodedPath)?.scheme == nil
@@ -71,7 +65,8 @@ internal func convertToUrl(string value: String) -> URL? {
   } else {
     // URLComponents on iOS 15 and lower does not well support RFC 3986.
     // We have to fallback URL(fileURLWithPath:) first.
-    url = value.hasPrefix("/")
+    url =
+      value.hasPrefix("/")
       ? URL(fileURLWithPath: value)
       : URLComponents(string: value)?.url ?? URL(string: value)
   }
@@ -83,9 +78,7 @@ internal func convertToUrl(string value: String) -> URL? {
   return url.scheme != nil ? url : URL(fileURLWithPath: value)
 }
 
-/**
- A collection of utility functions for various Expo Modules common tasks.
- */
+/// A collection of utility functions for various Expo Modules common tasks.
 public struct Utilities {
   /**
    Converts a `String` to a `URL`.
diff --git a/ios/Uuidv5/Uuidv5.swift b/ios/Uuidv5/Uuidv5.swift
index 1a3419aa89b4b6dbcde26377c4d928a0084f44aa..1ec03fb9c1e2667f32b3f85bf01ec14704ec2b50 100644
--- a/ios/Uuidv5/Uuidv5.swift
+++ b/ios/Uuidv5/Uuidv5.swift
@@ -1,6 +1,6 @@
-import Foundation
 import CommonCrypto
 import CryptoKit
+import Foundation
 
 func uuidv5(name: String, namespace: UUID) -> UUID {
   var spaceUID = namespace.uuid
@@ -12,7 +12,9 @@ func uuidv5(name: String, namespace: UUID) -> UUID {
 
   // Compute SHA1 digest
   var digest = [UInt8](repeating: 0, count: Int(CC_SHA1_DIGEST_LENGTH))
-  data.withUnsafeBytes { (ptr: UnsafeRawBufferPointer) -> Void in CC_SHA1(ptr.baseAddress, CC_LONG(data.count), &digest) }
+  data.withUnsafeBytes { (ptr: UnsafeRawBufferPointer) -> Void in
+    CC_SHA1(ptr.baseAddress, CC_LONG(data.count), &digest)
+  }
 
   // Set version bits:
   digest[6] = digest[6] & 0x0F | UInt8(5) << 4
