///
/// HybridRNCandleSpecSwift.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include "HybridRNCandleSpec.hpp"

// Forward declaration of `HybridRNCandleSpec_cxx` to properly resolve imports.
namespace ReactNativeCandle { class HybridRNCandleSpec_cxx; }

// Forward declaration of `Service` to properly resolve imports.
namespace margelo::nitro::rncandle { enum class Service; }
// Forward declaration of `PresentationBackground` to properly resolve imports.
namespace margelo::nitro::rncandle { enum class PresentationBackground; }
// Forward declaration of `PresentationStyle` to properly resolve imports.
namespace margelo::nitro::rncandle { enum class PresentationStyle; }
// Forward declaration of `LinkedAccount` to properly resolve imports.
namespace margelo::nitro::rncandle { struct LinkedAccount; }
// Forward declaration of `Details` to properly resolve imports.
namespace margelo::nitro::rncandle { struct Details; }
// Forward declaration of `State` to properly resolve imports.
namespace margelo::nitro::rncandle { enum class State; }
// Forward declaration of `AppUser` to properly resolve imports.
namespace margelo::nitro::rncandle { struct AppUser; }
// Forward declaration of `AssetAccount` to properly resolve imports.
namespace margelo::nitro::rncandle { struct AssetAccount; }
// Forward declaration of `LegalAccountKind` to properly resolve imports.
namespace margelo::nitro::rncandle { enum class LegalAccountKind; }
// Forward declaration of `FiatAccountDetails` to properly resolve imports.
namespace margelo::nitro::rncandle { struct FiatAccountDetails; }
// Forward declaration of `MarketAccountDetails` to properly resolve imports.
namespace margelo::nitro::rncandle { struct MarketAccountDetails; }
// Forward declaration of `ACHDetails` to properly resolve imports.
namespace margelo::nitro::rncandle { struct ACHDetails; }
// Forward declaration of `ACHAccountKind` to properly resolve imports.
namespace margelo::nitro::rncandle { enum class ACHAccountKind; }
// Forward declaration of `WireDetails` to properly resolve imports.
namespace margelo::nitro::rncandle { struct WireDetails; }
// Forward declaration of `AssetAccountQuery` to properly resolve imports.
namespace margelo::nitro::rncandle { struct AssetAccountQuery; }
// Forward declaration of `AssetAccountKind` to properly resolve imports.
namespace margelo::nitro::rncandle { enum class AssetAccountKind; }
// Forward declaration of `Trade` to properly resolve imports.
namespace margelo::nitro::rncandle { struct Trade; }
// Forward declaration of `TradeState` to properly resolve imports.
namespace margelo::nitro::rncandle { enum class TradeState; }
// Forward declaration of `Counterparty` to properly resolve imports.
namespace margelo::nitro::rncandle { struct Counterparty; }
// Forward declaration of `MerchantCounterparty` to properly resolve imports.
namespace margelo::nitro::rncandle { struct MerchantCounterparty; }
// Forward declaration of `MerchantLocation` to properly resolve imports.
namespace margelo::nitro::rncandle { struct MerchantLocation; }
// Forward declaration of `UserCounterparty` to properly resolve imports.
namespace margelo::nitro::rncandle { struct UserCounterparty; }
// Forward declaration of `ServiceCounterparty` to properly resolve imports.
namespace margelo::nitro::rncandle { struct ServiceCounterparty; }
// Forward declaration of `TradeAsset` to properly resolve imports.
namespace margelo::nitro::rncandle { struct TradeAsset; }
// Forward declaration of `FiatAsset` to properly resolve imports.
namespace margelo::nitro::rncandle { struct FiatAsset; }
// Forward declaration of `MarketTradeAsset` to properly resolve imports.
namespace margelo::nitro::rncandle { struct MarketTradeAsset; }
// Forward declaration of `TransportAsset` to properly resolve imports.
namespace margelo::nitro::rncandle { struct TransportAsset; }
// Forward declaration of `Coordinates` to properly resolve imports.
namespace margelo::nitro::rncandle { struct Coordinates; }
// Forward declaration of `Address` to properly resolve imports.
namespace margelo::nitro::rncandle { struct Address; }
// Forward declaration of `OtherAsset` to properly resolve imports.
namespace margelo::nitro::rncandle { struct OtherAsset; }
// Forward declaration of `NothingAsset` to properly resolve imports.
namespace margelo::nitro::rncandle { struct NothingAsset; }
// Forward declaration of `TradeQuery` to properly resolve imports.
namespace margelo::nitro::rncandle { struct TradeQuery; }
// Forward declaration of `AssetKind` to properly resolve imports.
namespace margelo::nitro::rncandle { enum class AssetKind; }
// Forward declaration of `CounterpartyKind` to properly resolve imports.
namespace margelo::nitro::rncandle { enum class CounterpartyKind; }
// Forward declaration of `TradeQuote` to properly resolve imports.
namespace margelo::nitro::rncandle { struct TradeQuote; }
// Forward declaration of `TradeQuoteRequest` to properly resolve imports.
namespace margelo::nitro::rncandle { struct TradeQuoteRequest; }
// Forward declaration of `TradeAssetQuoteRequest` to properly resolve imports.
namespace margelo::nitro::rncandle { struct TradeAssetQuoteRequest; }
// Forward declaration of `FiatAssetQuoteRequest` to properly resolve imports.
namespace margelo::nitro::rncandle { struct FiatAssetQuoteRequest; }
// Forward declaration of `MarketAssetQuoteRequest` to properly resolve imports.
namespace margelo::nitro::rncandle { struct MarketAssetQuoteRequest; }
// Forward declaration of `MarketAssetKind` to properly resolve imports.
namespace margelo::nitro::rncandle { enum class MarketAssetKind; }
// Forward declaration of `TransportAssetQuoteRequest` to properly resolve imports.
namespace margelo::nitro::rncandle { struct TransportAssetQuoteRequest; }
// Forward declaration of `NothingAssetQuoteRequest` to properly resolve imports.
namespace margelo::nitro::rncandle { struct NothingAssetQuoteRequest; }
// Forward declaration of `AnyMap` to properly resolve imports.
namespace NitroModules { class AnyMap; }
// Forward declaration of `ToolCall` to properly resolve imports.
namespace margelo::nitro::rncandle { struct ToolCall; }

#include <optional>
#include <vector>
#include "Service.hpp"
#include <string>
#include "PresentationBackground.hpp"
#include "PresentationStyle.hpp"
#include <functional>
#include "LinkedAccount.hpp"
#include "Details.hpp"
#include "State.hpp"
#include "AppUser.hpp"
#include <NitroModules/Promise.hpp>
#include "AssetAccount.hpp"
#include "LegalAccountKind.hpp"
#include <variant>
#include "FiatAccountDetails.hpp"
#include "MarketAccountDetails.hpp"
#include "ACHDetails.hpp"
#include "ACHAccountKind.hpp"
#include "WireDetails.hpp"
#include "AssetAccountQuery.hpp"
#include "AssetAccountKind.hpp"
#include "Trade.hpp"
#include "TradeState.hpp"
#include "Counterparty.hpp"
#include "MerchantCounterparty.hpp"
#include "MerchantLocation.hpp"
#include "UserCounterparty.hpp"
#include "ServiceCounterparty.hpp"
#include "TradeAsset.hpp"
#include "FiatAsset.hpp"
#include "MarketTradeAsset.hpp"
#include "TransportAsset.hpp"
#include "Coordinates.hpp"
#include "Address.hpp"
#include "OtherAsset.hpp"
#include "NothingAsset.hpp"
#include "TradeQuery.hpp"
#include "AssetKind.hpp"
#include "CounterpartyKind.hpp"
#include "TradeQuote.hpp"
#include "TradeQuoteRequest.hpp"
#include "TradeAssetQuoteRequest.hpp"
#include "FiatAssetQuoteRequest.hpp"
#include "MarketAssetQuoteRequest.hpp"
#include "MarketAssetKind.hpp"
#include "TransportAssetQuoteRequest.hpp"
#include "NothingAssetQuoteRequest.hpp"
#include <NitroModules/AnyMap.hpp>
#include "ToolCall.hpp"

#include "ReactNativeCandle-Swift-Cxx-Umbrella.hpp"

namespace margelo::nitro::rncandle {

  /**
   * The C++ part of HybridRNCandleSpec_cxx.swift.
   *
   * HybridRNCandleSpecSwift (C++) accesses HybridRNCandleSpec_cxx (Swift), and might
   * contain some additional bridging code for C++ <> Swift interop.
   *
   * Since this obviously introduces an overhead, I hope at some point in
   * the future, HybridRNCandleSpec_cxx can directly inherit from the C++ class HybridRNCandleSpec
   * to simplify the whole structure and memory management.
   */
  class HybridRNCandleSpecSwift: public virtual HybridRNCandleSpec {
  public:
    // Constructor from a Swift instance
    explicit HybridRNCandleSpecSwift(const ReactNativeCandle::HybridRNCandleSpec_cxx& swiftPart):
      HybridObject(HybridRNCandleSpec::TAG),
      _swiftPart(swiftPart) { }

  public:
    // Get the Swift part
    inline ReactNativeCandle::HybridRNCandleSpec_cxx& getSwiftPart() noexcept {
      return _swiftPart;
    }

  public:
    // Get memory pressure
    inline size_t getExternalMemorySize() noexcept override {
      return _swiftPart.getMemorySize();
    }

  public:
    // Properties
    

  public:
    // Methods
    inline void candleLinkSheet(bool isPresented, const std::optional<std::vector<Service>>& services, double cornerRadius, const std::optional<std::string>& customerName, bool showDynamicLoading, PresentationBackground presentationBackground, PresentationStyle presentationStyle, const std::function<void(const LinkedAccount& /* account */)>& onSuccess) override {
      auto __result = _swiftPart.candleLinkSheet(std::forward<decltype(isPresented)>(isPresented), services, std::forward<decltype(cornerRadius)>(cornerRadius), customerName, std::forward<decltype(showDynamicLoading)>(showDynamicLoading), static_cast<int>(presentationBackground), static_cast<int>(presentationStyle), onSuccess);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void initialize(const AppUser& appUser) override {
      auto __result = _swiftPart.initialize(appUser);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline std::shared_ptr<Promise<std::vector<LinkedAccount>>> getLinkedAccounts() override {
      auto __result = _swiftPart.getLinkedAccounts();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> unlinkAccount(const std::string& linkedAccountID) override {
      auto __result = _swiftPart.unlinkAccount(linkedAccountID);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<std::vector<AssetAccount>>> getAssetAccounts(const AssetAccountQuery& query) override {
      auto __result = _swiftPart.getAssetAccounts(query);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<std::vector<Trade>>> getTrades(const TradeQuery& query) override {
      auto __result = _swiftPart.getTrades(query);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<std::vector<TradeQuote>>> getTradeQuotes(const TradeQuoteRequest& request) override {
      auto __result = _swiftPart.getTradeQuotes(request);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> deleteUser() override {
      auto __result = _swiftPart.deleteUser();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<std::vector<std::shared_ptr<AnyMap>>>> getAvailableTools() override {
      auto __result = _swiftPart.getAvailableTools();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<std::string>> executeTool(const ToolCall& tool) override {
      auto __result = _swiftPart.executeTool(tool);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }

  private:
    ReactNativeCandle::HybridRNCandleSpec_cxx _swiftPart;
  };

} // namespace margelo::nitro::rncandle
