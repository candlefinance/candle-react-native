///
/// TradesResponse.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import NitroModules

/// Represents an instance of `TradesResponse`, backed by a C++ struct.
public typealias TradesResponse = margelo.nitro.rncandle.TradesResponse

extension TradesResponse {
  private typealias bridge = margelo.nitro.rncandle.bridge.swift

  /**
   * Create a new instance of `TradesResponse`.
   */
  public init(linkedAccounts: [LinkedAccountStatusRef], trades: [Trade]) {
    self.init(
      { () -> bridge.std__vector_LinkedAccountStatusRef_ in
        var __vector = bridge.create_std__vector_LinkedAccountStatusRef_(linkedAccounts.count)
        for __item in linkedAccounts {
          __vector.push_back(__item)
        }
        return __vector
      }(),
      { () -> bridge.std__vector_Trade_ in
        var __vector = bridge.create_std__vector_Trade_(trades.count)
        for __item in trades {
          __vector.push_back(__item)
        }
        return __vector
      }())
  }

  public var linkedAccounts: [LinkedAccountStatusRef] {
    @inline(__always)
    get {
      return self.__linkedAccounts.map({ __item in __item })
    }
    @inline(__always)
    set {
      self.__linkedAccounts = { () -> bridge.std__vector_LinkedAccountStatusRef_ in
        var __vector = bridge.create_std__vector_LinkedAccountStatusRef_(newValue.count)
        for __item in newValue {
          __vector.push_back(__item)
        }
        return __vector
      }()
    }
  }

  public var trades: [Trade] {
    @inline(__always)
    get {
      return self.__trades.map({ __item in __item })
    }
    @inline(__always)
    set {
      self.__trades = { () -> bridge.std__vector_Trade_ in
        var __vector = bridge.create_std__vector_Trade_(newValue.count)
        for __item in newValue {
          __vector.push_back(__item)
        }
        return __vector
      }()
    }
  }
}
